
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 79 01 00 00       	call   c00202b6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020162:	55                   	push   %ebp
c0020163:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020165:	8b 45 08             	mov    0x8(%ebp),%eax
c0020168:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002016d:	5d                   	pop    %ebp
c002016e:	c3                   	ret    

c002016f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002016f:	55                   	push   %ebp
c0020170:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020172:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020179:	0f 97 c0             	seta   %al
}
c002017c:	5d                   	pop    %ebp
c002017d:	c3                   	ret    

c002017e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002017e:	55                   	push   %ebp
c002017f:	89 e5                	mov    %esp,%ebp
c0020181:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0020184:	8b 45 08             	mov    0x8(%ebp),%eax
c0020187:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002018c:	76 1e                	jbe    c00201ac <ptov+0x2e>
c002018e:	83 ec 0c             	sub    $0xc,%esp
c0020191:	68 80 f4 02 c0       	push   $0xc002f480
c0020196:	68 9b f4 02 c0       	push   $0xc002f49b
c002019b:	68 c0 fa 02 c0       	push   $0xc002fac0
c00201a0:	6a 4a                	push   $0x4a
c00201a2:	68 b2 f4 02 c0       	push   $0xc002f4b2
c00201a7:	e8 c2 95 00 00       	call   c002976e <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00201af:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201b4:	c9                   	leave  
c00201b5:	c3                   	ret    

c00201b6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201b6:	55                   	push   %ebp
c00201b7:	89 e5                	mov    %esp,%ebp
c00201b9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201bc:	ff 75 08             	pushl  0x8(%ebp)
c00201bf:	e8 ab ff ff ff       	call   c002016f <is_kernel_vaddr>
c00201c4:	83 c4 04             	add    $0x4,%esp
c00201c7:	84 c0                	test   %al,%al
c00201c9:	75 1e                	jne    c00201e9 <vtop+0x33>
c00201cb:	83 ec 0c             	sub    $0xc,%esp
c00201ce:	68 c8 f4 02 c0       	push   $0xc002f4c8
c00201d3:	68 9b f4 02 c0       	push   $0xc002f49b
c00201d8:	68 e8 fa 02 c0       	push   $0xc002fae8
c00201dd:	6a 54                	push   $0x54
c00201df:	68 b2 f4 02 c0       	push   $0xc002f4b2
c00201e4:	e8 85 95 00 00       	call   c002976e <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00201e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00201ec:	05 00 00 00 40       	add    $0x40000000,%eax
}
c00201f1:	c9                   	leave  
c00201f2:	c3                   	ret    

c00201f3 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c00201f3:	55                   	push   %ebp
c00201f4:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00201f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00201f9:	c1 e8 0c             	shr    $0xc,%eax
c00201fc:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0020201:	5d                   	pop    %ebp
c0020202:	c3                   	ret    

c0020203 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020203:	55                   	push   %ebp
c0020204:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020206:	8b 45 08             	mov    0x8(%ebp),%eax
c0020209:	c1 e8 16             	shr    $0x16,%eax
}
c002020c:	5d                   	pop    %ebp
c002020d:	c3                   	ret    

c002020e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002020e:	55                   	push   %ebp
c002020f:	89 e5                	mov    %esp,%ebp
c0020211:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020214:	ff 75 08             	pushl  0x8(%ebp)
c0020217:	e8 46 ff ff ff       	call   c0020162 <pg_ofs>
c002021c:	83 c4 04             	add    $0x4,%esp
c002021f:	85 c0                	test   %eax,%eax
c0020221:	74 1e                	je     c0020241 <pde_create+0x33>
c0020223:	83 ec 0c             	sub    $0xc,%esp
c0020226:	68 e0 f4 02 c0       	push   $0xc002f4e0
c002022b:	68 9b f4 02 c0       	push   $0xc002f49b
c0020230:	68 c8 fa 02 c0       	push   $0xc002fac8
c0020235:	6a 48                	push   $0x48
c0020237:	68 f1 f4 02 c0       	push   $0xc002f4f1
c002023c:	e8 2d 95 00 00       	call   c002976e <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020241:	83 ec 0c             	sub    $0xc,%esp
c0020244:	ff 75 08             	pushl  0x8(%ebp)
c0020247:	e8 6a ff ff ff       	call   c00201b6 <vtop>
c002024c:	83 c4 10             	add    $0x10,%esp
c002024f:	83 c8 07             	or     $0x7,%eax
}
c0020252:	c9                   	leave  
c0020253:	c3                   	ret    

c0020254 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020254:	55                   	push   %ebp
c0020255:	89 e5                	mov    %esp,%ebp
c0020257:	83 ec 18             	sub    $0x18,%esp
c002025a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002025d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020260:	ff 75 08             	pushl  0x8(%ebp)
c0020263:	e8 fa fe ff ff       	call   c0020162 <pg_ofs>
c0020268:	83 c4 04             	add    $0x4,%esp
c002026b:	85 c0                	test   %eax,%eax
c002026d:	74 1e                	je     c002028d <pte_create_kernel+0x39>
c002026f:	83 ec 0c             	sub    $0xc,%esp
c0020272:	68 05 f5 02 c0       	push   $0xc002f505
c0020277:	68 9b f4 02 c0       	push   $0xc002f49b
c002027c:	68 d4 fa 02 c0       	push   $0xc002fad4
c0020281:	6a 58                	push   $0x58
c0020283:	68 f1 f4 02 c0       	push   $0xc002f4f1
c0020288:	e8 e1 94 00 00       	call   c002976e <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002028d:	83 ec 0c             	sub    $0xc,%esp
c0020290:	ff 75 08             	pushl  0x8(%ebp)
c0020293:	e8 1e ff ff ff       	call   c00201b6 <vtop>
c0020298:	83 c4 10             	add    $0x10,%esp
c002029b:	89 c2                	mov    %eax,%edx
c002029d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202a1:	74 07                	je     c00202aa <pte_create_kernel+0x56>
c00202a3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202a8:	eb 05                	jmp    c00202af <pte_create_kernel+0x5b>
c00202aa:	b8 00 00 00 00       	mov    $0x0,%eax
c00202af:	09 d0                	or     %edx,%eax
c00202b1:	83 c8 01             	or     $0x1,%eax
}
c00202b4:	c9                   	leave  
c00202b5:	c3                   	ret    

c00202b6 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202b6:	55                   	push   %ebp
c00202b7:	89 e5                	mov    %esp,%ebp
c00202b9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202bc:	e8 e0 00 00 00       	call   c00203a1 <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202c1:	e8 40 02 00 00       	call   c0020506 <read_command_line>
c00202c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202c9:	83 ec 0c             	sub    $0xc,%esp
c00202cc:	ff 75 f4             	pushl  -0xc(%ebp)
c00202cf:	e8 62 03 00 00       	call   c0020636 <parse_options>
c00202d4:	83 c4 10             	add    $0x10,%esp
c00202d7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202da:	e8 a1 07 00 00       	call   c0020a80 <thread_init>
  console_init ();  
c00202df:	e8 03 b6 00 00       	call   c002b8e7 <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c00202e4:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00202e9:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00202ec:	c1 e8 0a             	shr    $0xa,%eax
c00202ef:	83 ec 08             	sub    $0x8,%esp
c00202f2:	50                   	push   %eax
c00202f3:	68 18 f5 02 c0       	push   $0xc002f518
c00202f8:	e8 b2 70 00 00       	call   c00273af <printf>
c00202fd:	83 c4 10             	add    $0x10,%esp

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020300:	a1 e0 7f 03 c0       	mov    0xc0037fe0,%eax
c0020305:	83 ec 0c             	sub    $0xc,%esp
c0020308:	50                   	push   %eax
c0020309:	e8 c3 2e 00 00       	call   c00231d1 <palloc_init>
c002030e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020311:	e8 ca 32 00 00       	call   c00235e0 <malloc_init>
  paging_init ();
c0020316:	e8 b0 00 00 00       	call   c00203cb <paging_init>

  /* Segmentation. */
#ifdef USERPROG
  tss_init ();
c002031b:	e8 83 d6 00 00       	call   c002d9a3 <tss_init>
  gdt_init ();
c0020320:	e8 ab d3 00 00       	call   c002d6d0 <gdt_init>
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c0020325:	e8 ad 12 00 00       	call   c00215d7 <intr_init>
  timer_init ();
c002032a:	e8 62 3a 00 00       	call   c0023d91 <timer_init>
  kbd_init ();
c002032f:	e8 52 40 00 00       	call   c0024386 <kbd_init>
  input_init ();
c0020334:	e8 cb 62 00 00       	call   c0026604 <input_init>
#ifdef USERPROG
  exception_init ();
c0020339:	e8 4b ca 00 00       	call   c002cd89 <exception_init>
  syscall_init ();
c002033e:	e8 61 cd 00 00       	call   c002d0a4 <syscall_init>
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c0020343:	e8 d7 07 00 00       	call   c0020b1f <thread_start>
  serial_init_queue ();
c0020348:	e8 01 48 00 00       	call   c0024b4e <serial_init_queue>
  timer_calibrate ();
c002034d:	e8 70 3a 00 00       	call   c0023dc2 <timer_calibrate>

#ifdef FILESYS
  /* Initialize file system. */
  ide_init ();
c0020352:	e8 d5 55 00 00       	call   c002592c <ide_init>
  locate_block_devices ();
c0020357:	e8 1a 06 00 00       	call   c0020976 <locate_block_devices>
  filesys_init (format_filesys);
c002035c:	a0 80 88 03 c0       	mov    0xc0038880,%al
c0020361:	0f b6 c0             	movzbl %al,%eax
c0020364:	83 ec 0c             	sub    $0xc,%esp
c0020367:	50                   	push   %eax
c0020368:	e8 e7 d6 00 00       	call   c002da54 <filesys_init>
c002036d:	83 c4 10             	add    $0x10,%esp
#endif

  printf ("Boot complete.\n");
c0020370:	83 ec 0c             	sub    $0xc,%esp
c0020373:	68 3b f5 02 c0       	push   $0xc002f53b
c0020378:	e8 c3 b6 00 00       	call   c002ba40 <puts>
c002037d:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c0020380:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020383:	8b 00                	mov    (%eax),%eax
c0020385:	85 c0                	test   %eax,%eax
c0020387:	74 0e                	je     c0020397 <pintos_init+0xe1>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020389:	83 ec 0c             	sub    $0xc,%esp
c002038c:	ff 75 f4             	pushl  -0xc(%ebp)
c002038f:	e8 e3 04 00 00       	call   c0020877 <run_actions>
c0020394:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020397:	e8 66 6a 00 00       	call   c0026e02 <shutdown>
  thread_exit ();
c002039c:	e8 3f 0b 00 00       	call   c0020ee0 <thread_exit>

c00203a1 <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c00203a1:	55                   	push   %ebp
c00203a2:	89 e5                	mov    %esp,%ebp
c00203a4:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c00203a7:	ba 51 a6 03 c0       	mov    $0xc003a651,%edx
c00203ac:	b8 64 88 03 c0       	mov    $0xc0038864,%eax
c00203b1:	29 c2                	sub    %eax,%edx
c00203b3:	89 d0                	mov    %edx,%eax
c00203b5:	83 ec 04             	sub    $0x4,%esp
c00203b8:	50                   	push   %eax
c00203b9:	6a 00                	push   $0x0
c00203bb:	68 64 88 03 c0       	push   $0xc0038864
c00203c0:	e8 c3 87 00 00       	call   c0028b88 <memset>
c00203c5:	83 c4 10             	add    $0x10,%esp
}
c00203c8:	90                   	nop
c00203c9:	c9                   	leave  
c00203ca:	c3                   	ret    

c00203cb <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00203cb:	55                   	push   %ebp
c00203cc:	89 e5                	mov    %esp,%ebp
c00203ce:	53                   	push   %ebx
c00203cf:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203d2:	83 ec 0c             	sub    $0xc,%esp
c00203d5:	6a 03                	push   $0x3
c00203d7:	e8 6f 2f 00 00       	call   c002334b <palloc_get_page>
c00203dc:	83 c4 10             	add    $0x10,%esp
c00203df:	a3 48 a6 03 c0       	mov    %eax,0xc003a648
c00203e4:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c00203e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203fa:	e9 df 00 00 00       	jmp    c00204de <paging_init+0x113>
    {
      uintptr_t paddr = page * PGSIZE;
c00203ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020402:	c1 e0 0c             	shl    $0xc,%eax
c0020405:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c0020408:	83 ec 0c             	sub    $0xc,%esp
c002040b:	ff 75 e8             	pushl  -0x18(%ebp)
c002040e:	e8 6b fd ff ff       	call   c002017e <ptov>
c0020413:	83 c4 10             	add    $0x10,%esp
c0020416:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c0020419:	83 ec 0c             	sub    $0xc,%esp
c002041c:	ff 75 e4             	pushl  -0x1c(%ebp)
c002041f:	e8 df fd ff ff       	call   c0020203 <pd_no>
c0020424:	83 c4 10             	add    $0x10,%esp
c0020427:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c002042a:	83 ec 0c             	sub    $0xc,%esp
c002042d:	ff 75 e4             	pushl  -0x1c(%ebp)
c0020430:	e8 be fd ff ff       	call   c00201f3 <pt_no>
c0020435:	83 c4 10             	add    $0x10,%esp
c0020438:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c002043b:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020442:	72 10                	jb     c0020454 <paging_init+0x89>
c0020444:	81 7d e4 00 40 03 c0 	cmpl   $0xc0034000,-0x1c(%ebp)
c002044b:	73 07                	jae    c0020454 <paging_init+0x89>
c002044d:	b8 01 00 00 00       	mov    $0x1,%eax
c0020452:	eb 05                	jmp    c0020459 <paging_init+0x8e>
c0020454:	b8 00 00 00 00       	mov    $0x0,%eax
c0020459:	88 45 db             	mov    %al,-0x25(%ebp)
c002045c:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c0020460:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020463:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002046a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002046d:	01 d0                	add    %edx,%eax
c002046f:	8b 00                	mov    (%eax),%eax
c0020471:	85 c0                	test   %eax,%eax
c0020473:	75 30                	jne    c00204a5 <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020475:	83 ec 0c             	sub    $0xc,%esp
c0020478:	6a 03                	push   $0x3
c002047a:	e8 cc 2e 00 00       	call   c002334b <palloc_get_page>
c002047f:	83 c4 10             	add    $0x10,%esp
c0020482:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020485:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020488:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002048f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020492:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020495:	83 ec 0c             	sub    $0xc,%esp
c0020498:	ff 75 f4             	pushl  -0xc(%ebp)
c002049b:	e8 6e fd ff ff       	call   c002020e <pde_create>
c00204a0:	83 c4 10             	add    $0x10,%esp
c00204a3:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c00204a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00204a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00204af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00204b2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00204b5:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c00204b9:	85 c0                	test   %eax,%eax
c00204bb:	0f 95 c0             	setne  %al
c00204be:	83 f0 01             	xor    $0x1,%eax
c00204c1:	0f b6 c0             	movzbl %al,%eax
c00204c4:	83 e0 01             	and    $0x1,%eax
c00204c7:	0f b6 c0             	movzbl %al,%eax
c00204ca:	83 ec 08             	sub    $0x8,%esp
c00204cd:	50                   	push   %eax
c00204ce:	ff 75 e4             	pushl  -0x1c(%ebp)
c00204d1:	e8 7e fd ff ff       	call   c0020254 <pte_create_kernel>
c00204d6:	83 c4 10             	add    $0x10,%esp
c00204d9:	89 03                	mov    %eax,(%ebx)
  for (page = 0; page < init_ram_pages; page++)
c00204db:	ff 45 f0             	incl   -0x10(%ebp)
c00204de:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00204e3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204e6:	0f 82 13 ff ff ff    	jb     c00203ff <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204ec:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c00204f1:	83 ec 0c             	sub    $0xc,%esp
c00204f4:	50                   	push   %eax
c00204f5:	e8 bc fc ff ff       	call   c00201b6 <vtop>
c00204fa:	83 c4 10             	add    $0x10,%esp
c00204fd:	0f 22 d8             	mov    %eax,%cr3
}
c0020500:	90                   	nop
c0020501:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020504:	c9                   	leave  
c0020505:	c3                   	ret    

c0020506 <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c0020506:	55                   	push   %ebp
c0020507:	89 e5                	mov    %esp,%ebp
c0020509:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c002050c:	83 ec 0c             	sub    $0xc,%esp
c002050f:	68 3a 7d 00 00       	push   $0x7d3a
c0020514:	e8 65 fc ff ff       	call   c002017e <ptov>
c0020519:	83 c4 10             	add    $0x10,%esp
c002051c:	8b 00                	mov    (%eax),%eax
c002051e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020521:	83 ec 0c             	sub    $0xc,%esp
c0020524:	68 3e 7d 00 00       	push   $0x7d3e
c0020529:	e8 50 fc ff ff       	call   c002017e <ptov>
c002052e:	83 c4 10             	add    $0x10,%esp
c0020531:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020534:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020537:	83 e8 80             	sub    $0xffffff80,%eax
c002053a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c002053d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020544:	eb 4e                	jmp    c0020594 <read_command_line+0x8e>
    {
      if (p >= end)
c0020546:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020549:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002054c:	72 19                	jb     c0020567 <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c002054e:	68 4c f5 02 c0       	push   $0xc002f54c
c0020553:	68 f0 fa 02 c0       	push   $0xc002faf0
c0020558:	68 d3 00 00 00       	push   $0xd3
c002055d:	68 6c f5 02 c0       	push   $0xc002f56c
c0020562:	e8 07 92 00 00       	call   c002976e <debug_panic>

      argv[i] = p;
c0020567:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002056a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002056d:	89 14 85 a0 88 03 c0 	mov    %edx,-0x3ffc7760(,%eax,4)
      p += strnlen (p, end - p) + 1;
c0020574:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0020577:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002057a:	29 c2                	sub    %eax,%edx
c002057c:	89 d0                	mov    %edx,%eax
c002057e:	83 ec 08             	sub    $0x8,%esp
c0020581:	50                   	push   %eax
c0020582:	ff 75 f4             	pushl  -0xc(%ebp)
c0020585:	e8 a4 86 00 00       	call   c0028c2e <strnlen>
c002058a:	83 c4 10             	add    $0x10,%esp
c002058d:	40                   	inc    %eax
c002058e:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < argc; i++) 
c0020591:	ff 45 f0             	incl   -0x10(%ebp)
c0020594:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020597:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002059a:	7c aa                	jl     c0020546 <read_command_line+0x40>
    }
  argv[argc] = NULL;
c002059c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002059f:	c7 04 85 a0 88 03 c0 	movl   $0x0,-0x3ffc7760(,%eax,4)
c00205a6:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c00205aa:	83 ec 0c             	sub    $0xc,%esp
c00205ad:	68 81 f5 02 c0       	push   $0xc002f581
c00205b2:	e8 f8 6d 00 00       	call   c00273af <printf>
c00205b7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00205c1:	eb 57                	jmp    c002061a <read_command_line+0x114>
    if (strchr (argv[i], ' ') == NULL)
c00205c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205c6:	8b 04 85 a0 88 03 c0 	mov    -0x3ffc7760(,%eax,4),%eax
c00205cd:	83 ec 08             	sub    $0x8,%esp
c00205d0:	6a 20                	push   $0x20
c00205d2:	50                   	push   %eax
c00205d3:	e8 d5 82 00 00       	call   c00288ad <strchr>
c00205d8:	83 c4 10             	add    $0x10,%esp
c00205db:	85 c0                	test   %eax,%eax
c00205dd:	75 1d                	jne    c00205fc <read_command_line+0xf6>
      printf (" %s", argv[i]);
c00205df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205e2:	8b 04 85 a0 88 03 c0 	mov    -0x3ffc7760(,%eax,4),%eax
c00205e9:	83 ec 08             	sub    $0x8,%esp
c00205ec:	50                   	push   %eax
c00205ed:	68 96 f5 02 c0       	push   $0xc002f596
c00205f2:	e8 b8 6d 00 00       	call   c00273af <printf>
c00205f7:	83 c4 10             	add    $0x10,%esp
c00205fa:	eb 1b                	jmp    c0020617 <read_command_line+0x111>
    else
      printf (" '%s'", argv[i]);
c00205fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205ff:	8b 04 85 a0 88 03 c0 	mov    -0x3ffc7760(,%eax,4),%eax
c0020606:	83 ec 08             	sub    $0x8,%esp
c0020609:	50                   	push   %eax
c002060a:	68 9a f5 02 c0       	push   $0xc002f59a
c002060f:	e8 9b 6d 00 00       	call   c00273af <printf>
c0020614:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c0020617:	ff 45 f0             	incl   -0x10(%ebp)
c002061a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002061d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020620:	7c a1                	jl     c00205c3 <read_command_line+0xbd>
  printf ("\n");
c0020622:	83 ec 0c             	sub    $0xc,%esp
c0020625:	6a 0a                	push   $0xa
c0020627:	e8 99 b4 00 00       	call   c002bac5 <putchar>
c002062c:	83 c4 10             	add    $0x10,%esp

  return argv;
c002062f:	b8 a0 88 03 c0       	mov    $0xc00388a0,%eax
}
c0020634:	c9                   	leave  
c0020635:	c3                   	ret    

c0020636 <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c0020636:	55                   	push   %ebp
c0020637:	89 e5                	mov    %esp,%ebp
c0020639:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c002063c:	e9 b6 01 00 00       	jmp    c00207f7 <parse_options+0x1c1>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020641:	8b 45 08             	mov    0x8(%ebp),%eax
c0020644:	8b 00                	mov    (%eax),%eax
c0020646:	83 ec 04             	sub    $0x4,%esp
c0020649:	8d 55 ec             	lea    -0x14(%ebp),%edx
c002064c:	52                   	push   %edx
c002064d:	68 a0 f5 02 c0       	push   $0xc002f5a0
c0020652:	50                   	push   %eax
c0020653:	e8 22 84 00 00       	call   c0028a7a <strtok_r>
c0020658:	83 c4 10             	add    $0x10,%esp
c002065b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c002065e:	83 ec 04             	sub    $0x4,%esp
c0020661:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0020664:	50                   	push   %eax
c0020665:	68 a2 f5 02 c0       	push   $0xc002f5a2
c002066a:	6a 00                	push   $0x0
c002066c:	e8 09 84 00 00       	call   c0028a7a <strtok_r>
c0020671:	83 c4 10             	add    $0x10,%esp
c0020674:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c0020677:	83 ec 08             	sub    $0x8,%esp
c002067a:	68 a3 f5 02 c0       	push   $0xc002f5a3
c002067f:	ff 75 f4             	pushl  -0xc(%ebp)
c0020682:	e8 24 81 00 00       	call   c00287ab <strcmp>
c0020687:	83 c4 10             	add    $0x10,%esp
c002068a:	85 c0                	test   %eax,%eax
c002068c:	75 0a                	jne    c0020698 <parse_options+0x62>
        usage ();
c002068e:	e8 c8 02 00 00       	call   c002095b <usage>
c0020693:	e9 5b 01 00 00       	jmp    c00207f3 <parse_options+0x1bd>
      else if (!strcmp (name, "-q"))
c0020698:	83 ec 08             	sub    $0x8,%esp
c002069b:	68 a6 f5 02 c0       	push   $0xc002f5a6
c00206a0:	ff 75 f4             	pushl  -0xc(%ebp)
c00206a3:	e8 03 81 00 00       	call   c00287ab <strcmp>
c00206a8:	83 c4 10             	add    $0x10,%esp
c00206ab:	85 c0                	test   %eax,%eax
c00206ad:	75 12                	jne    c00206c1 <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c00206af:	83 ec 0c             	sub    $0xc,%esp
c00206b2:	6a 01                	push   $0x1
c00206b4:	e8 6d 67 00 00       	call   c0026e26 <shutdown_configure>
c00206b9:	83 c4 10             	add    $0x10,%esp
c00206bc:	e9 32 01 00 00       	jmp    c00207f3 <parse_options+0x1bd>
      else if (!strcmp (name, "-r"))
c00206c1:	83 ec 08             	sub    $0x8,%esp
c00206c4:	68 a9 f5 02 c0       	push   $0xc002f5a9
c00206c9:	ff 75 f4             	pushl  -0xc(%ebp)
c00206cc:	e8 da 80 00 00       	call   c00287ab <strcmp>
c00206d1:	83 c4 10             	add    $0x10,%esp
c00206d4:	85 c0                	test   %eax,%eax
c00206d6:	75 12                	jne    c00206ea <parse_options+0xb4>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206d8:	83 ec 0c             	sub    $0xc,%esp
c00206db:	6a 02                	push   $0x2
c00206dd:	e8 44 67 00 00       	call   c0026e26 <shutdown_configure>
c00206e2:	83 c4 10             	add    $0x10,%esp
c00206e5:	e9 09 01 00 00       	jmp    c00207f3 <parse_options+0x1bd>
#ifdef FILESYS
      else if (!strcmp (name, "-f"))
c00206ea:	83 ec 08             	sub    $0x8,%esp
c00206ed:	68 ac f5 02 c0       	push   $0xc002f5ac
c00206f2:	ff 75 f4             	pushl  -0xc(%ebp)
c00206f5:	e8 b1 80 00 00       	call   c00287ab <strcmp>
c00206fa:	83 c4 10             	add    $0x10,%esp
c00206fd:	85 c0                	test   %eax,%eax
c00206ff:	75 0c                	jne    c002070d <parse_options+0xd7>
        format_filesys = true;
c0020701:	c6 05 80 88 03 c0 01 	movb   $0x1,0xc0038880
c0020708:	e9 e6 00 00 00       	jmp    c00207f3 <parse_options+0x1bd>
      else if (!strcmp (name, "-filesys"))
c002070d:	83 ec 08             	sub    $0x8,%esp
c0020710:	68 af f5 02 c0       	push   $0xc002f5af
c0020715:	ff 75 f4             	pushl  -0xc(%ebp)
c0020718:	e8 8e 80 00 00       	call   c00287ab <strcmp>
c002071d:	83 c4 10             	add    $0x10,%esp
c0020720:	85 c0                	test   %eax,%eax
c0020722:	75 0d                	jne    c0020731 <parse_options+0xfb>
        filesys_bdev_name = value;
c0020724:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020727:	a3 84 88 03 c0       	mov    %eax,0xc0038884
c002072c:	e9 c2 00 00 00       	jmp    c00207f3 <parse_options+0x1bd>
      else if (!strcmp (name, "-scratch"))
c0020731:	83 ec 08             	sub    $0x8,%esp
c0020734:	68 b8 f5 02 c0       	push   $0xc002f5b8
c0020739:	ff 75 f4             	pushl  -0xc(%ebp)
c002073c:	e8 6a 80 00 00       	call   c00287ab <strcmp>
c0020741:	83 c4 10             	add    $0x10,%esp
c0020744:	85 c0                	test   %eax,%eax
c0020746:	75 0d                	jne    c0020755 <parse_options+0x11f>
        scratch_bdev_name = value;
c0020748:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002074b:	a3 88 88 03 c0       	mov    %eax,0xc0038888
c0020750:	e9 9e 00 00 00       	jmp    c00207f3 <parse_options+0x1bd>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c0020755:	83 ec 08             	sub    $0x8,%esp
c0020758:	68 c1 f5 02 c0       	push   $0xc002f5c1
c002075d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020760:	e8 46 80 00 00       	call   c00287ab <strcmp>
c0020765:	83 c4 10             	add    $0x10,%esp
c0020768:	85 c0                	test   %eax,%eax
c002076a:	75 1c                	jne    c0020788 <parse_options+0x152>
        random_init (atoi (value));
c002076c:	83 ec 0c             	sub    $0xc,%esp
c002076f:	ff 75 f0             	pushl  -0x10(%ebp)
c0020772:	e8 37 7a 00 00       	call   c00281ae <atoi>
c0020777:	83 c4 10             	add    $0x10,%esp
c002077a:	83 ec 0c             	sub    $0xc,%esp
c002077d:	50                   	push   %eax
c002077e:	e8 ce 69 00 00       	call   c0027151 <random_init>
c0020783:	83 c4 10             	add    $0x10,%esp
c0020786:	eb 6b                	jmp    c00207f3 <parse_options+0x1bd>
      else if (!strcmp (name, "-mlfqs"))
c0020788:	83 ec 08             	sub    $0x8,%esp
c002078b:	68 c5 f5 02 c0       	push   $0xc002f5c5
c0020790:	ff 75 f4             	pushl  -0xc(%ebp)
c0020793:	e8 13 80 00 00       	call   c00287ab <strcmp>
c0020798:	83 c4 10             	add    $0x10,%esp
c002079b:	85 c0                	test   %eax,%eax
c002079d:	75 09                	jne    c00207a8 <parse_options+0x172>
        thread_mlfqs = true;
c002079f:	c6 05 50 a6 03 c0 01 	movb   $0x1,0xc003a650
c00207a6:	eb 4b                	jmp    c00207f3 <parse_options+0x1bd>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
c00207a8:	83 ec 08             	sub    $0x8,%esp
c00207ab:	68 cc f5 02 c0       	push   $0xc002f5cc
c00207b0:	ff 75 f4             	pushl  -0xc(%ebp)
c00207b3:	e8 f3 7f 00 00       	call   c00287ab <strcmp>
c00207b8:	83 c4 10             	add    $0x10,%esp
c00207bb:	85 c0                	test   %eax,%eax
c00207bd:	75 15                	jne    c00207d4 <parse_options+0x19e>
        user_page_limit = atoi (value);
c00207bf:	83 ec 0c             	sub    $0xc,%esp
c00207c2:	ff 75 f0             	pushl  -0x10(%ebp)
c00207c5:	e8 e4 79 00 00       	call   c00281ae <atoi>
c00207ca:	83 c4 10             	add    $0x10,%esp
c00207cd:	a3 e0 7f 03 c0       	mov    %eax,0xc0037fe0
c00207d2:	eb 1f                	jmp    c00207f3 <parse_options+0x1bd>
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c00207d4:	83 ec 0c             	sub    $0xc,%esp
c00207d7:	ff 75 f4             	pushl  -0xc(%ebp)
c00207da:	68 d0 f5 02 c0       	push   $0xc002f5d0
c00207df:	68 04 fb 02 c0       	push   $0xc002fb04
c00207e4:	68 0c 01 00 00       	push   $0x10c
c00207e9:	68 6c f5 02 c0       	push   $0xc002f56c
c00207ee:	e8 7b 8f 00 00       	call   c002976e <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c00207f3:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c00207f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00207fa:	8b 00                	mov    (%eax),%eax
c00207fc:	85 c0                	test   %eax,%eax
c00207fe:	74 0f                	je     c002080f <parse_options+0x1d9>
c0020800:	8b 45 08             	mov    0x8(%ebp),%eax
c0020803:	8b 00                	mov    (%eax),%eax
c0020805:	8a 00                	mov    (%eax),%al
c0020807:	3c 2d                	cmp    $0x2d,%al
c0020809:	0f 84 32 fe ff ff    	je     c0020641 <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c002080f:	e8 5f 63 00 00       	call   c0026b73 <rtc_get_time>
c0020814:	83 ec 0c             	sub    $0xc,%esp
c0020817:	50                   	push   %eax
c0020818:	e8 34 69 00 00       	call   c0027151 <random_init>
c002081d:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c0020820:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020823:	c9                   	leave  
c0020824:	c3                   	ret    

c0020825 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020825:	55                   	push   %ebp
c0020826:	89 e5                	mov    %esp,%ebp
c0020828:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c002082b:	8b 45 08             	mov    0x8(%ebp),%eax
c002082e:	8b 40 04             	mov    0x4(%eax),%eax
c0020831:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020834:	83 ec 08             	sub    $0x8,%esp
c0020837:	ff 75 f4             	pushl  -0xc(%ebp)
c002083a:	68 f6 f5 02 c0       	push   $0xc002f5f6
c002083f:	e8 6b 6b 00 00       	call   c00273af <printf>
c0020844:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
c0020847:	83 ec 0c             	sub    $0xc,%esp
c002084a:	ff 75 f4             	pushl  -0xc(%ebp)
c002084d:	e8 5f b3 00 00       	call   c002bbb1 <process_execute>
c0020852:	83 c4 10             	add    $0x10,%esp
c0020855:	83 ec 0c             	sub    $0xc,%esp
c0020858:	50                   	push   %eax
c0020859:	e8 73 b4 00 00       	call   c002bcd1 <process_wait>
c002085e:	83 c4 10             	add    $0x10,%esp
#else
  run_test (task);
#endif
  printf ("Execution of '%s' complete.\n", task);
c0020861:	83 ec 08             	sub    $0x8,%esp
c0020864:	ff 75 f4             	pushl  -0xc(%ebp)
c0020867:	68 07 f6 02 c0       	push   $0xc002f607
c002086c:	e8 3e 6b 00 00       	call   c00273af <printf>
c0020871:	83 c4 10             	add    $0x10,%esp
}
c0020874:	90                   	nop
c0020875:	c9                   	leave  
c0020876:	c3                   	ret    

c0020877 <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c0020877:	55                   	push   %ebp
c0020878:	89 e5                	mov    %esp,%ebp
c002087a:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c002087d:	e9 c9 00 00 00       	jmp    c002094b <run_actions+0xd4>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c0020882:	c7 45 f4 40 fb 02 c0 	movl   $0xc002fb40,-0xc(%ebp)
        if (a->name == NULL)
c0020889:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002088c:	8b 00                	mov    (%eax),%eax
c002088e:	85 c0                	test   %eax,%eax
c0020890:	75 22                	jne    c00208b4 <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c0020892:	8b 45 08             	mov    0x8(%ebp),%eax
c0020895:	8b 00                	mov    (%eax),%eax
c0020897:	83 ec 0c             	sub    $0xc,%esp
c002089a:	50                   	push   %eax
c002089b:	68 24 f6 02 c0       	push   $0xc002f624
c00208a0:	68 94 fb 02 c0       	push   $0xc002fb94
c00208a5:	68 4e 01 00 00       	push   $0x14e
c00208aa:	68 6c f5 02 c0       	push   $0xc002f56c
c00208af:	e8 ba 8e 00 00       	call   c002976e <debug_panic>
        else if (!strcmp (*argv, a->name))
c00208b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00208b7:	8b 10                	mov    (%eax),%edx
c00208b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00208bc:	8b 00                	mov    (%eax),%eax
c00208be:	83 ec 08             	sub    $0x8,%esp
c00208c1:	52                   	push   %edx
c00208c2:	50                   	push   %eax
c00208c3:	e8 e3 7e 00 00       	call   c00287ab <strcmp>
c00208c8:	83 c4 10             	add    $0x10,%esp
c00208cb:	85 c0                	test   %eax,%eax
c00208cd:	74 06                	je     c00208d5 <run_actions+0x5e>
      for (a = actions; ; a++)
c00208cf:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
        if (a->name == NULL)
c00208d3:	eb b4                	jmp    c0020889 <run_actions+0x12>
          break;
c00208d5:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c00208d6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c00208dd:	eb 44                	jmp    c0020923 <run_actions+0xac>
        if (argv[i] == NULL)
c00208df:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00208e2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c00208e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00208ec:	01 d0                	add    %edx,%eax
c00208ee:	8b 00                	mov    (%eax),%eax
c00208f0:	85 c0                	test   %eax,%eax
c00208f2:	75 2c                	jne    c0020920 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c00208f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00208f7:	8b 40 04             	mov    0x4(%eax),%eax
c00208fa:	8d 50 ff             	lea    -0x1(%eax),%edx
c00208fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0020900:	8b 00                	mov    (%eax),%eax
c0020902:	83 ec 08             	sub    $0x8,%esp
c0020905:	52                   	push   %edx
c0020906:	50                   	push   %eax
c0020907:	68 4c f6 02 c0       	push   $0xc002f64c
c002090c:	68 94 fb 02 c0       	push   $0xc002fb94
c0020911:	68 55 01 00 00       	push   $0x155
c0020916:	68 6c f5 02 c0       	push   $0xc002f56c
c002091b:	e8 4e 8e 00 00       	call   c002976e <debug_panic>
      for (i = 1; i < a->argc; i++)
c0020920:	ff 45 f0             	incl   -0x10(%ebp)
c0020923:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020926:	8b 40 04             	mov    0x4(%eax),%eax
c0020929:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002092c:	7f b1                	jg     c00208df <run_actions+0x68>

      /* Invoke action and advance. */
      a->function (argv);
c002092e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020931:	8b 40 08             	mov    0x8(%eax),%eax
c0020934:	83 ec 0c             	sub    $0xc,%esp
c0020937:	ff 75 08             	pushl  0x8(%ebp)
c002093a:	ff d0                	call   *%eax
c002093c:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c002093f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020942:	8b 40 04             	mov    0x4(%eax),%eax
c0020945:	c1 e0 02             	shl    $0x2,%eax
c0020948:	01 45 08             	add    %eax,0x8(%ebp)
  while (*argv != NULL)
c002094b:	8b 45 08             	mov    0x8(%ebp),%eax
c002094e:	8b 00                	mov    (%eax),%eax
c0020950:	85 c0                	test   %eax,%eax
c0020952:	0f 85 2a ff ff ff    	jne    c0020882 <run_actions+0xb>
    }
  
}
c0020958:	90                   	nop
c0020959:	c9                   	leave  
c002095a:	c3                   	ret    

c002095b <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c002095b:	55                   	push   %ebp
c002095c:	89 e5                	mov    %esp,%ebp
c002095e:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020961:	83 ec 0c             	sub    $0xc,%esp
c0020964:	68 70 f6 02 c0       	push   $0xc002f670
c0020969:	e8 d2 b0 00 00       	call   c002ba40 <puts>
c002096e:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020971:	e8 44 65 00 00       	call   c0026eba <shutdown_power_off>

c0020976 <locate_block_devices>:

#ifdef FILESYS
/* Figure out what block devices to cast in the various Pintos roles. */
static void
locate_block_devices (void)
{
c0020976:	55                   	push   %ebp
c0020977:	89 e5                	mov    %esp,%ebp
c0020979:	83 ec 08             	sub    $0x8,%esp
  locate_block_device (BLOCK_FILESYS, filesys_bdev_name);
c002097c:	a1 84 88 03 c0       	mov    0xc0038884,%eax
c0020981:	83 ec 08             	sub    $0x8,%esp
c0020984:	50                   	push   %eax
c0020985:	6a 01                	push   $0x1
c0020987:	e8 19 00 00 00       	call   c00209a5 <locate_block_device>
c002098c:	83 c4 10             	add    $0x10,%esp
  locate_block_device (BLOCK_SCRATCH, scratch_bdev_name);
c002098f:	a1 88 88 03 c0       	mov    0xc0038888,%eax
c0020994:	83 ec 08             	sub    $0x8,%esp
c0020997:	50                   	push   %eax
c0020998:	6a 02                	push   $0x2
c002099a:	e8 06 00 00 00       	call   c00209a5 <locate_block_device>
c002099f:	83 c4 10             	add    $0x10,%esp
#ifdef VM
  locate_block_device (BLOCK_SWAP, swap_bdev_name);
#endif
}
c00209a2:	90                   	nop
c00209a3:	c9                   	leave  
c00209a4:	c3                   	ret    

c00209a5 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device (enum block_type role, const char *name)
{
c00209a5:	55                   	push   %ebp
c00209a6:	89 e5                	mov    %esp,%ebp
c00209a8:	53                   	push   %ebx
c00209a9:	83 ec 14             	sub    $0x14,%esp
  struct block *block = NULL;
c00209ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (name != NULL)
c00209b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00209b7:	74 36                	je     c00209ef <locate_block_device+0x4a>
    {
      block = block_get_by_name (name);
c00209b9:	83 ec 0c             	sub    $0xc,%esp
c00209bc:	ff 75 0c             	pushl  0xc(%ebp)
c00209bf:	e8 6c 46 00 00       	call   c0025030 <block_get_by_name>
c00209c4:	83 c4 10             	add    $0x10,%esp
c00209c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (block == NULL)
c00209ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00209ce:	75 56                	jne    c0020a26 <locate_block_device+0x81>
        PANIC ("No such block device \"%s\"", name);
c00209d0:	83 ec 0c             	sub    $0xc,%esp
c00209d3:	ff 75 0c             	pushl  0xc(%ebp)
c00209d6:	68 98 fa 02 c0       	push   $0xc002fa98
c00209db:	68 a0 fb 02 c0       	push   $0xc002fba0
c00209e0:	68 a2 01 00 00       	push   $0x1a2
c00209e5:	68 6c f5 02 c0       	push   $0xc002f56c
c00209ea:	e8 7f 8d 00 00       	call   c002976e <debug_panic>
    }
  else
    {
      for (block = block_first (); block != NULL; block = block_next (block))
c00209ef:	e8 f5 45 00 00       	call   c0024fe9 <block_first>
c00209f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00209f7:	eb 24                	jmp    c0020a1d <locate_block_device+0x78>
        if (block_type (block) == role)
c00209f9:	83 ec 0c             	sub    $0xc,%esp
c00209fc:	ff 75 f4             	pushl  -0xc(%ebp)
c00209ff:	e8 c9 47 00 00       	call   c00251cd <block_type>
c0020a04:	83 c4 10             	add    $0x10,%esp
c0020a07:	3b 45 08             	cmp    0x8(%ebp),%eax
c0020a0a:	74 19                	je     c0020a25 <locate_block_device+0x80>
      for (block = block_first (); block != NULL; block = block_next (block))
c0020a0c:	83 ec 0c             	sub    $0xc,%esp
c0020a0f:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a12:	e8 f6 45 00 00       	call   c002500d <block_next>
c0020a17:	83 c4 10             	add    $0x10,%esp
c0020a1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020a1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020a21:	75 d6                	jne    c00209f9 <locate_block_device+0x54>
c0020a23:	eb 01                	jmp    c0020a26 <locate_block_device+0x81>
          break;
c0020a25:	90                   	nop
    }

  if (block != NULL)
c0020a26:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020a2a:	74 41                	je     c0020a6d <locate_block_device+0xc8>
    {
      printf ("%s: using %s\n", block_type_name (role), block_name (block));
c0020a2c:	83 ec 0c             	sub    $0xc,%esp
c0020a2f:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a32:	e8 8b 47 00 00       	call   c00251c2 <block_name>
c0020a37:	83 c4 10             	add    $0x10,%esp
c0020a3a:	89 c3                	mov    %eax,%ebx
c0020a3c:	83 ec 0c             	sub    $0xc,%esp
c0020a3f:	ff 75 08             	pushl  0x8(%ebp)
c0020a42:	e8 fc 44 00 00       	call   c0024f43 <block_type_name>
c0020a47:	83 c4 10             	add    $0x10,%esp
c0020a4a:	83 ec 04             	sub    $0x4,%esp
c0020a4d:	53                   	push   %ebx
c0020a4e:	50                   	push   %eax
c0020a4f:	68 b2 fa 02 c0       	push   $0xc002fab2
c0020a54:	e8 56 69 00 00       	call   c00273af <printf>
c0020a59:	83 c4 10             	add    $0x10,%esp
      block_set_role (role, block);
c0020a5c:	83 ec 08             	sub    $0x8,%esp
c0020a5f:	ff 75 f4             	pushl  -0xc(%ebp)
c0020a62:	ff 75 08             	pushl  0x8(%ebp)
c0020a65:	e8 45 45 00 00       	call   c0024faf <block_set_role>
c0020a6a:	83 c4 10             	add    $0x10,%esp
    }
}
c0020a6d:	90                   	nop
c0020a6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020a71:	c9                   	leave  
c0020a72:	c3                   	ret    

c0020a73 <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c0020a73:	55                   	push   %ebp
c0020a74:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c0020a76:	8b 45 08             	mov    0x8(%ebp),%eax
c0020a79:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c0020a7e:	5d                   	pop    %ebp
c0020a7f:	c3                   	ret    

c0020a80 <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c0020a80:	55                   	push   %ebp
c0020a81:	89 e5                	mov    %esp,%ebp
c0020a83:	53                   	push   %ebx
c0020a84:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0020a87:	e8 c2 0a 00 00       	call   c002154e <intr_get_level>
c0020a8c:	85 c0                	test   %eax,%eax
c0020a8e:	74 1e                	je     c0020aae <thread_init+0x2e>
c0020a90:	83 ec 0c             	sub    $0xc,%esp
c0020a93:	68 b4 fb 02 c0       	push   $0xc002fbb4
c0020a98:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020a9d:	68 74 fd 02 c0       	push   $0xc002fd74
c0020aa2:	6a 5a                	push   $0x5a
c0020aa4:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020aa9:	e8 c0 8c 00 00       	call   c002976e <debug_panic>

  lock_init (&tid_lock);
c0020aae:	83 ec 0c             	sub    $0xc,%esp
c0020ab1:	68 d0 89 03 c0       	push   $0xc00389d0
c0020ab6:	e8 bf 21 00 00       	call   c0022c7a <lock_init>
c0020abb:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c0020abe:	83 ec 0c             	sub    $0xc,%esp
c0020ac1:	68 a8 89 03 c0       	push   $0xc00389a8
c0020ac6:	e8 14 8f 00 00       	call   c00299df <list_init>
c0020acb:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c0020ace:	83 ec 0c             	sub    $0xc,%esp
c0020ad1:	68 b8 89 03 c0       	push   $0xc00389b8
c0020ad6:	e8 04 8f 00 00       	call   c00299df <list_init>
c0020adb:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020ade:	e8 46 06 00 00       	call   c0021129 <running_thread>
c0020ae3:	a3 cc 89 03 c0       	mov    %eax,0xc00389cc
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020ae8:	a1 cc 89 03 c0       	mov    0xc00389cc,%eax
c0020aed:	83 ec 04             	sub    $0x4,%esp
c0020af0:	6a 1f                	push   $0x1f
c0020af2:	68 00 fc 02 c0       	push   $0xc002fc00
c0020af7:	50                   	push   %eax
c0020af8:	e8 6b 06 00 00       	call   c0021168 <init_thread>
c0020afd:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020b00:	a1 cc 89 03 c0       	mov    0xc00389cc,%eax
c0020b05:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020b0c:	8b 1d cc 89 03 c0    	mov    0xc00389cc,%ebx
c0020b12:	e8 b4 09 00 00       	call   c00214cb <allocate_tid>
c0020b17:	89 03                	mov    %eax,(%ebx)
}
c0020b19:	90                   	nop
c0020b1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020b1d:	c9                   	leave  
c0020b1e:	c3                   	ret    

c0020b1f <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c0020b1f:	55                   	push   %ebp
c0020b20:	89 e5                	mov    %esp,%ebp
c0020b22:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c0020b25:	83 ec 08             	sub    $0x8,%esp
c0020b28:	6a 00                	push   $0x0
c0020b2a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020b2d:	50                   	push   %eax
c0020b2e:	e8 8f 1e 00 00       	call   c00229c2 <sema_init>
c0020b33:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c0020b36:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020b39:	50                   	push   %eax
c0020b3a:	68 b2 10 02 c0       	push   $0xc00210b2
c0020b3f:	6a 00                	push   $0x0
c0020b41:	68 05 fc 02 c0       	push   $0xc002fc05
c0020b46:	e8 fc 00 00 00       	call   c0020c47 <thread_create>
c0020b4b:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c0020b4e:	e8 32 0a 00 00       	call   c0021585 <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c0020b53:	83 ec 0c             	sub    $0xc,%esp
c0020b56:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020b59:	50                   	push   %eax
c0020b5a:	e8 aa 1e 00 00       	call   c0022a09 <sema_down>
c0020b5f:	83 c4 10             	add    $0x10,%esp
}
c0020b62:	90                   	nop
c0020b63:	c9                   	leave  
c0020b64:	c3                   	ret    

c0020b65 <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c0020b65:	55                   	push   %ebp
c0020b66:	89 e5                	mov    %esp,%ebp
c0020b68:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c0020b6b:	e8 f0 02 00 00       	call   c0020e60 <thread_current>
c0020b70:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c0020b73:	a1 c8 89 03 c0       	mov    0xc00389c8,%eax
c0020b78:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020b7b:	75 1e                	jne    c0020b9b <thread_tick+0x36>
    idle_ticks++;
c0020b7d:	a1 e8 89 03 c0       	mov    0xc00389e8,%eax
c0020b82:	8b 15 ec 89 03 c0    	mov    0xc00389ec,%edx
c0020b88:	83 c0 01             	add    $0x1,%eax
c0020b8b:	83 d2 00             	adc    $0x0,%edx
c0020b8e:	a3 e8 89 03 c0       	mov    %eax,0xc00389e8
c0020b93:	89 15 ec 89 03 c0    	mov    %edx,0xc00389ec
c0020b99:	eb 44                	jmp    c0020bdf <thread_tick+0x7a>
#ifdef USERPROG
  else if (t->pagedir != NULL)
c0020b9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b9e:	8b 40 50             	mov    0x50(%eax),%eax
c0020ba1:	85 c0                	test   %eax,%eax
c0020ba3:	74 1e                	je     c0020bc3 <thread_tick+0x5e>
    user_ticks++;
c0020ba5:	a1 f8 89 03 c0       	mov    0xc00389f8,%eax
c0020baa:	8b 15 fc 89 03 c0    	mov    0xc00389fc,%edx
c0020bb0:	83 c0 01             	add    $0x1,%eax
c0020bb3:	83 d2 00             	adc    $0x0,%edx
c0020bb6:	a3 f8 89 03 c0       	mov    %eax,0xc00389f8
c0020bbb:	89 15 fc 89 03 c0    	mov    %edx,0xc00389fc
c0020bc1:	eb 1c                	jmp    c0020bdf <thread_tick+0x7a>
#endif
  else
    kernel_ticks++;
c0020bc3:	a1 f0 89 03 c0       	mov    0xc00389f0,%eax
c0020bc8:	8b 15 f4 89 03 c0    	mov    0xc00389f4,%edx
c0020bce:	83 c0 01             	add    $0x1,%eax
c0020bd1:	83 d2 00             	adc    $0x0,%edx
c0020bd4:	a3 f0 89 03 c0       	mov    %eax,0xc00389f0
c0020bd9:	89 15 f4 89 03 c0    	mov    %edx,0xc00389f4

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c0020bdf:	a1 00 8a 03 c0       	mov    0xc0038a00,%eax
c0020be4:	40                   	inc    %eax
c0020be5:	a3 00 8a 03 c0       	mov    %eax,0xc0038a00
c0020bea:	a1 00 8a 03 c0       	mov    0xc0038a00,%eax
c0020bef:	83 f8 03             	cmp    $0x3,%eax
c0020bf2:	76 05                	jbe    c0020bf9 <thread_tick+0x94>
    intr_yield_on_return ();
c0020bf4:	e8 a1 0c 00 00       	call   c002189a <intr_yield_on_return>
}
c0020bf9:	90                   	nop
c0020bfa:	c9                   	leave  
c0020bfb:	c3                   	ret    

c0020bfc <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020bfc:	55                   	push   %ebp
c0020bfd:	89 e5                	mov    %esp,%ebp
c0020bff:	57                   	push   %edi
c0020c00:	56                   	push   %esi
c0020c01:	53                   	push   %ebx
c0020c02:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020c05:	8b 35 f8 89 03 c0    	mov    0xc00389f8,%esi
c0020c0b:	8b 3d fc 89 03 c0    	mov    0xc00389fc,%edi
c0020c11:	8b 0d f0 89 03 c0    	mov    0xc00389f0,%ecx
c0020c17:	8b 1d f4 89 03 c0    	mov    0xc00389f4,%ebx
c0020c1d:	a1 e8 89 03 c0       	mov    0xc00389e8,%eax
c0020c22:	8b 15 ec 89 03 c0    	mov    0xc00389ec,%edx
c0020c28:	83 ec 04             	sub    $0x4,%esp
c0020c2b:	57                   	push   %edi
c0020c2c:	56                   	push   %esi
c0020c2d:	53                   	push   %ebx
c0020c2e:	51                   	push   %ecx
c0020c2f:	52                   	push   %edx
c0020c30:	50                   	push   %eax
c0020c31:	68 0c fc 02 c0       	push   $0xc002fc0c
c0020c36:	e8 74 67 00 00       	call   c00273af <printf>
c0020c3b:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020c3e:	90                   	nop
c0020c3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020c42:	5b                   	pop    %ebx
c0020c43:	5e                   	pop    %esi
c0020c44:	5f                   	pop    %edi
c0020c45:	5d                   	pop    %ebp
c0020c46:	c3                   	ret    

c0020c47 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020c47:	55                   	push   %ebp
c0020c48:	89 e5                	mov    %esp,%ebp
c0020c4a:	83 ec 28             	sub    $0x28,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020c4d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020c51:	75 21                	jne    c0020c74 <thread_create+0x2d>
c0020c53:	83 ec 0c             	sub    $0xc,%esp
c0020c56:	68 49 fc 02 c0       	push   $0xc002fc49
c0020c5b:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020c60:	68 80 fd 02 c0       	push   $0xc002fd80
c0020c65:	68 af 00 00 00       	push   $0xaf
c0020c6a:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020c6f:	e8 fa 8a 00 00       	call   c002976e <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020c74:	83 ec 0c             	sub    $0xc,%esp
c0020c77:	6a 02                	push   $0x2
c0020c79:	e8 cd 26 00 00       	call   c002334b <palloc_get_page>
c0020c7e:	83 c4 10             	add    $0x10,%esp
c0020c81:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020c84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020c88:	75 0a                	jne    c0020c94 <thread_create+0x4d>
    return TID_ERROR;
c0020c8a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020c8f:	e9 aa 00 00 00       	jmp    c0020d3e <thread_create+0xf7>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020c94:	83 ec 04             	sub    $0x4,%esp
c0020c97:	ff 75 0c             	pushl  0xc(%ebp)
c0020c9a:	ff 75 08             	pushl  0x8(%ebp)
c0020c9d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ca0:	e8 c3 04 00 00       	call   c0021168 <init_thread>
c0020ca5:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c0020ca8:	e8 1e 08 00 00       	call   c00214cb <allocate_tid>
c0020cad:	89 c2                	mov    %eax,%edx
c0020caf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020cb2:	89 10                	mov    %edx,(%eax)
c0020cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020cb7:	8b 00                	mov    (%eax),%eax
c0020cb9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020cbc:	83 ec 08             	sub    $0x8,%esp
c0020cbf:	6a 0c                	push   $0xc
c0020cc1:	ff 75 f4             	pushl  -0xc(%ebp)
c0020cc4:	e8 d5 05 00 00       	call   c002129e <alloc_frame>
c0020cc9:	83 c4 10             	add    $0x10,%esp
c0020ccc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020ccf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020cd2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020cd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020cdb:	8b 55 10             	mov    0x10(%ebp),%edx
c0020cde:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020ce1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020ce4:	8b 55 14             	mov    0x14(%ebp),%edx
c0020ce7:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020cea:	83 ec 08             	sub    $0x8,%esp
c0020ced:	6a 04                	push   $0x4
c0020cef:	ff 75 f4             	pushl  -0xc(%ebp)
c0020cf2:	e8 a7 05 00 00       	call   c002129e <alloc_frame>
c0020cf7:	83 c4 10             	add    $0x10,%esp
c0020cfa:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020cfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020d00:	c7 00 e4 10 02 c0    	movl   $0xc00210e4,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020d06:	83 ec 08             	sub    $0x8,%esp
c0020d09:	6a 1c                	push   $0x1c
c0020d0b:	ff 75 f4             	pushl  -0xc(%ebp)
c0020d0e:	e8 8b 05 00 00       	call   c002129e <alloc_frame>
c0020d13:	83 c4 10             	add    $0x10,%esp
c0020d16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020d19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020d1c:	c7 40 10 24 15 02 c0 	movl   $0xc0021524,0x10(%eax)
  sf->ebp = 0;
c0020d23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020d26:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020d2d:	83 ec 0c             	sub    $0xc,%esp
c0020d30:	ff 75 f4             	pushl  -0xc(%ebp)
c0020d33:	e8 79 00 00 00       	call   c0020db1 <thread_unblock>
c0020d38:	83 c4 10             	add    $0x10,%esp

  return tid;
c0020d3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020d3e:	c9                   	leave  
c0020d3f:	c3                   	ret    

c0020d40 <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020d40:	55                   	push   %ebp
c0020d41:	89 e5                	mov    %esp,%ebp
c0020d43:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020d46:	e8 45 0b 00 00       	call   c0021890 <intr_context>
c0020d4b:	83 f0 01             	xor    $0x1,%eax
c0020d4e:	84 c0                	test   %al,%al
c0020d50:	75 21                	jne    c0020d73 <thread_block+0x33>
c0020d52:	83 ec 0c             	sub    $0xc,%esp
c0020d55:	68 5a fc 02 c0       	push   $0xc002fc5a
c0020d5a:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020d5f:	68 90 fd 02 c0       	push   $0xc002fd90
c0020d64:	68 d8 00 00 00       	push   $0xd8
c0020d69:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020d6e:	e8 fb 89 00 00       	call   c002976e <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020d73:	e8 d6 07 00 00       	call   c002154e <intr_get_level>
c0020d78:	85 c0                	test   %eax,%eax
c0020d7a:	74 21                	je     c0020d9d <thread_block+0x5d>
c0020d7c:	83 ec 0c             	sub    $0xc,%esp
c0020d7f:	68 b4 fb 02 c0       	push   $0xc002fbb4
c0020d84:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020d89:	68 90 fd 02 c0       	push   $0xc002fd90
c0020d8e:	68 d9 00 00 00       	push   $0xd9
c0020d93:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020d98:	e8 d1 89 00 00       	call   c002976e <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020d9d:	e8 be 00 00 00       	call   c0020e60 <thread_current>
c0020da2:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020da9:	e8 4b 06 00 00       	call   c00213f9 <schedule>
}
c0020dae:	90                   	nop
c0020daf:	c9                   	leave  
c0020db0:	c3                   	ret    

c0020db1 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020db1:	55                   	push   %ebp
c0020db2:	89 e5                	mov    %esp,%ebp
c0020db4:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020db7:	83 ec 0c             	sub    $0xc,%esp
c0020dba:	ff 75 08             	pushl  0x8(%ebp)
c0020dbd:	e8 7f 03 00 00       	call   c0021141 <is_thread>
c0020dc2:	83 c4 10             	add    $0x10,%esp
c0020dc5:	84 c0                	test   %al,%al
c0020dc7:	75 21                	jne    c0020dea <thread_unblock+0x39>
c0020dc9:	83 ec 0c             	sub    $0xc,%esp
c0020dcc:	68 6b fc 02 c0       	push   $0xc002fc6b
c0020dd1:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020dd6:	68 a0 fd 02 c0       	push   $0xc002fda0
c0020ddb:	68 ec 00 00 00       	push   $0xec
c0020de0:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020de5:	e8 84 89 00 00       	call   c002976e <debug_panic>

  old_level = intr_disable ();
c0020dea:	e8 d4 07 00 00       	call   c00215c3 <intr_disable>
c0020def:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020df2:	8b 45 08             	mov    0x8(%ebp),%eax
c0020df5:	8b 40 04             	mov    0x4(%eax),%eax
c0020df8:	83 f8 02             	cmp    $0x2,%eax
c0020dfb:	74 21                	je     c0020e1e <thread_unblock+0x6d>
c0020dfd:	83 ec 0c             	sub    $0xc,%esp
c0020e00:	68 79 fc 02 c0       	push   $0xc002fc79
c0020e05:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020e0a:	68 a0 fd 02 c0       	push   $0xc002fda0
c0020e0f:	68 ef 00 00 00       	push   $0xef
c0020e14:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020e19:	e8 50 89 00 00       	call   c002976e <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0020e1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e21:	83 c0 28             	add    $0x28,%eax
c0020e24:	83 ec 08             	sub    $0x8,%esp
c0020e27:	50                   	push   %eax
c0020e28:	68 a8 89 03 c0       	push   $0xc00389a8
c0020e2d:	e8 8d 8f 00 00       	call   c0029dbf <list_push_back>
c0020e32:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0020e35:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e38:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020e3f:	83 ec 0c             	sub    $0xc,%esp
c0020e42:	ff 75 f4             	pushl  -0xc(%ebp)
c0020e45:	e8 21 07 00 00       	call   c002156b <intr_set_level>
c0020e4a:	83 c4 10             	add    $0x10,%esp
}
c0020e4d:	90                   	nop
c0020e4e:	c9                   	leave  
c0020e4f:	c3                   	ret    

c0020e50 <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020e50:	55                   	push   %ebp
c0020e51:	89 e5                	mov    %esp,%ebp
c0020e53:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020e56:	e8 05 00 00 00       	call   c0020e60 <thread_current>
c0020e5b:	83 c0 08             	add    $0x8,%eax
}
c0020e5e:	c9                   	leave  
c0020e5f:	c3                   	ret    

c0020e60 <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020e60:	55                   	push   %ebp
c0020e61:	89 e5                	mov    %esp,%ebp
c0020e63:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020e66:	e8 be 02 00 00       	call   c0021129 <running_thread>
c0020e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020e6e:	83 ec 0c             	sub    $0xc,%esp
c0020e71:	ff 75 f4             	pushl  -0xc(%ebp)
c0020e74:	e8 c8 02 00 00       	call   c0021141 <is_thread>
c0020e79:	83 c4 10             	add    $0x10,%esp
c0020e7c:	84 c0                	test   %al,%al
c0020e7e:	75 21                	jne    c0020ea1 <thread_current+0x41>
c0020e80:	83 ec 0c             	sub    $0xc,%esp
c0020e83:	68 6b fc 02 c0       	push   $0xc002fc6b
c0020e88:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020e8d:	68 b0 fd 02 c0       	push   $0xc002fdb0
c0020e92:	68 09 01 00 00       	push   $0x109
c0020e97:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020e9c:	e8 cd 88 00 00       	call   c002976e <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ea4:	8b 40 04             	mov    0x4(%eax),%eax
c0020ea7:	85 c0                	test   %eax,%eax
c0020ea9:	74 21                	je     c0020ecc <thread_current+0x6c>
c0020eab:	83 ec 0c             	sub    $0xc,%esp
c0020eae:	68 95 fc 02 c0       	push   $0xc002fc95
c0020eb3:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020eb8:	68 b0 fd 02 c0       	push   $0xc002fdb0
c0020ebd:	68 0a 01 00 00       	push   $0x10a
c0020ec2:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020ec7:	e8 a2 88 00 00       	call   c002976e <debug_panic>

  return t;
c0020ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020ecf:	c9                   	leave  
c0020ed0:	c3                   	ret    

c0020ed1 <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020ed1:	55                   	push   %ebp
c0020ed2:	89 e5                	mov    %esp,%ebp
c0020ed4:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020ed7:	e8 84 ff ff ff       	call   c0020e60 <thread_current>
c0020edc:	8b 00                	mov    (%eax),%eax
}
c0020ede:	c9                   	leave  
c0020edf:	c3                   	ret    

c0020ee0 <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020ee0:	55                   	push   %ebp
c0020ee1:	89 e5                	mov    %esp,%ebp
c0020ee3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020ee6:	e8 a5 09 00 00       	call   c0021890 <intr_context>
c0020eeb:	83 f0 01             	xor    $0x1,%eax
c0020eee:	84 c0                	test   %al,%al
c0020ef0:	75 21                	jne    c0020f13 <thread_exit+0x33>
c0020ef2:	83 ec 0c             	sub    $0xc,%esp
c0020ef5:	68 5a fc 02 c0       	push   $0xc002fc5a
c0020efa:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020eff:	68 c0 fd 02 c0       	push   $0xc002fdc0
c0020f04:	68 1b 01 00 00       	push   $0x11b
c0020f09:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020f0e:	e8 5b 88 00 00       	call   c002976e <debug_panic>

#ifdef USERPROG
  process_exit ();
c0020f13:	e8 d6 ad 00 00       	call   c002bcee <process_exit>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020f18:	e8 a6 06 00 00       	call   c00215c3 <intr_disable>
  list_remove (&thread_current()->allelem);
c0020f1d:	e8 3e ff ff ff       	call   c0020e60 <thread_current>
c0020f22:	83 c0 20             	add    $0x20,%eax
c0020f25:	83 ec 0c             	sub    $0xc,%esp
c0020f28:	50                   	push   %eax
c0020f29:	e8 b7 8e 00 00       	call   c0029de5 <list_remove>
c0020f2e:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020f31:	e8 2a ff ff ff       	call   c0020e60 <thread_current>
c0020f36:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020f3d:	e8 b7 04 00 00       	call   c00213f9 <schedule>
  NOT_REACHED ();
c0020f42:	68 b4 fc 02 c0       	push   $0xc002fcb4
c0020f47:	68 c0 fd 02 c0       	push   $0xc002fdc0
c0020f4c:	68 28 01 00 00       	push   $0x128
c0020f51:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020f56:	e8 13 88 00 00       	call   c002976e <debug_panic>

c0020f5b <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020f5b:	55                   	push   %ebp
c0020f5c:	89 e5                	mov    %esp,%ebp
c0020f5e:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020f61:	e8 fa fe ff ff       	call   c0020e60 <thread_current>
c0020f66:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020f69:	e8 22 09 00 00       	call   c0021890 <intr_context>
c0020f6e:	83 f0 01             	xor    $0x1,%eax
c0020f71:	84 c0                	test   %al,%al
c0020f73:	75 21                	jne    c0020f96 <thread_yield+0x3b>
c0020f75:	83 ec 0c             	sub    $0xc,%esp
c0020f78:	68 5a fc 02 c0       	push   $0xc002fc5a
c0020f7d:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020f82:	68 cc fd 02 c0       	push   $0xc002fdcc
c0020f87:	68 33 01 00 00       	push   $0x133
c0020f8c:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0020f91:	e8 d8 87 00 00       	call   c002976e <debug_panic>

  old_level = intr_disable ();
c0020f96:	e8 28 06 00 00       	call   c00215c3 <intr_disable>
c0020f9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020f9e:	a1 c8 89 03 c0       	mov    0xc00389c8,%eax
c0020fa3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020fa6:	74 17                	je     c0020fbf <thread_yield+0x64>
    list_push_back (&ready_list, &cur->elem);
c0020fa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020fab:	83 c0 28             	add    $0x28,%eax
c0020fae:	83 ec 08             	sub    $0x8,%esp
c0020fb1:	50                   	push   %eax
c0020fb2:	68 a8 89 03 c0       	push   $0xc00389a8
c0020fb7:	e8 03 8e 00 00       	call   c0029dbf <list_push_back>
c0020fbc:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0020fbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020fc2:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020fc9:	e8 2b 04 00 00       	call   c00213f9 <schedule>
  intr_set_level (old_level);
c0020fce:	83 ec 0c             	sub    $0xc,%esp
c0020fd1:	ff 75 f0             	pushl  -0x10(%ebp)
c0020fd4:	e8 92 05 00 00       	call   c002156b <intr_set_level>
c0020fd9:	83 c4 10             	add    $0x10,%esp
}
c0020fdc:	90                   	nop
c0020fdd:	c9                   	leave  
c0020fde:	c3                   	ret    

c0020fdf <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020fdf:	55                   	push   %ebp
c0020fe0:	89 e5                	mov    %esp,%ebp
c0020fe2:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020fe5:	e8 64 05 00 00       	call   c002154e <intr_get_level>
c0020fea:	85 c0                	test   %eax,%eax
c0020fec:	74 21                	je     c002100f <thread_foreach+0x30>
c0020fee:	83 ec 0c             	sub    $0xc,%esp
c0020ff1:	68 b4 fb 02 c0       	push   $0xc002fbb4
c0020ff6:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0020ffb:	68 dc fd 02 c0       	push   $0xc002fddc
c0021000:	68 44 01 00 00       	push   $0x144
c0021005:	68 e9 fb 02 c0       	push   $0xc002fbe9
c002100a:	e8 5f 87 00 00       	call   c002976e <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c002100f:	83 ec 0c             	sub    $0xc,%esp
c0021012:	68 b8 89 03 c0       	push   $0xc00389b8
c0021017:	e8 18 8a 00 00       	call   c0029a34 <list_begin>
c002101c:	83 c4 10             	add    $0x10,%esp
c002101f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0021022:	eb 2e                	jmp    c0021052 <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0021024:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021027:	83 c0 04             	add    $0x4,%eax
c002102a:	83 e8 24             	sub    $0x24,%eax
c002102d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0021030:	83 ec 08             	sub    $0x8,%esp
c0021033:	ff 75 0c             	pushl  0xc(%ebp)
c0021036:	ff 75 f0             	pushl  -0x10(%ebp)
c0021039:	8b 45 08             	mov    0x8(%ebp),%eax
c002103c:	ff d0                	call   *%eax
c002103e:	83 c4 10             	add    $0x10,%esp
       e = list_next (e))
c0021041:	83 ec 0c             	sub    $0xc,%esp
c0021044:	ff 75 f4             	pushl  -0xc(%ebp)
c0021047:	e8 1a 8a 00 00       	call   c0029a66 <list_next>
c002104c:	83 c4 10             	add    $0x10,%esp
c002104f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0021052:	83 ec 0c             	sub    $0xc,%esp
c0021055:	68 b8 89 03 c0       	push   $0xc00389b8
c002105a:	e8 51 8a 00 00       	call   c0029ab0 <list_end>
c002105f:	83 c4 10             	add    $0x10,%esp
c0021062:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0021065:	75 bd                	jne    c0021024 <thread_foreach+0x45>
    }
}
c0021067:	90                   	nop
c0021068:	c9                   	leave  
c0021069:	c3                   	ret    

c002106a <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c002106a:	55                   	push   %ebp
c002106b:	89 e5                	mov    %esp,%ebp
c002106d:	83 ec 08             	sub    $0x8,%esp
  thread_current ()->priority = new_priority;
c0021070:	e8 eb fd ff ff       	call   c0020e60 <thread_current>
c0021075:	8b 55 08             	mov    0x8(%ebp),%edx
c0021078:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c002107b:	90                   	nop
c002107c:	c9                   	leave  
c002107d:	c3                   	ret    

c002107e <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c002107e:	55                   	push   %ebp
c002107f:	89 e5                	mov    %esp,%ebp
c0021081:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->priority;
c0021084:	e8 d7 fd ff ff       	call   c0020e60 <thread_current>
c0021089:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002108c:	c9                   	leave  
c002108d:	c3                   	ret    

c002108e <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c002108e:	55                   	push   %ebp
c002108f:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0021091:	90                   	nop
c0021092:	5d                   	pop    %ebp
c0021093:	c3                   	ret    

c0021094 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0021094:	55                   	push   %ebp
c0021095:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0021097:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002109c:	5d                   	pop    %ebp
c002109d:	c3                   	ret    

c002109e <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c002109e:	55                   	push   %ebp
c002109f:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c00210a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00210a6:	5d                   	pop    %ebp
c00210a7:	c3                   	ret    

c00210a8 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c00210a8:	55                   	push   %ebp
c00210a9:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c00210ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00210b0:	5d                   	pop    %ebp
c00210b1:	c3                   	ret    

c00210b2 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c00210b2:	55                   	push   %ebp
c00210b3:	89 e5                	mov    %esp,%ebp
c00210b5:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c00210b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00210bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c00210be:	e8 9d fd ff ff       	call   c0020e60 <thread_current>
c00210c3:	a3 c8 89 03 c0       	mov    %eax,0xc00389c8
  sema_up (idle_started);
c00210c8:	83 ec 0c             	sub    $0xc,%esp
c00210cb:	ff 75 f4             	pushl  -0xc(%ebp)
c00210ce:	e8 40 1a 00 00       	call   c0022b13 <sema_up>
c00210d3:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c00210d6:	e8 e8 04 00 00       	call   c00215c3 <intr_disable>
      thread_block ();
c00210db:	e8 60 fc ff ff       	call   c0020d40 <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c00210e0:	fb                   	sti    
c00210e1:	f4                   	hlt    
      intr_disable ();
c00210e2:	eb f2                	jmp    c00210d6 <idle+0x24>

c00210e4 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c00210e4:	55                   	push   %ebp
c00210e5:	89 e5                	mov    %esp,%ebp
c00210e7:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c00210ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00210ee:	75 21                	jne    c0021111 <kernel_thread+0x2d>
c00210f0:	83 ec 0c             	sub    $0xc,%esp
c00210f3:	68 49 fc 02 c0       	push   $0xc002fc49
c00210f8:	68 d2 fb 02 c0       	push   $0xc002fbd2
c00210fd:	68 ec fd 02 c0       	push   $0xc002fdec
c0021102:	68 a5 01 00 00       	push   $0x1a5
c0021107:	68 e9 fb 02 c0       	push   $0xc002fbe9
c002110c:	e8 5d 86 00 00       	call   c002976e <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c0021111:	e8 6f 04 00 00       	call   c0021585 <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021116:	83 ec 0c             	sub    $0xc,%esp
c0021119:	ff 75 0c             	pushl  0xc(%ebp)
c002111c:	8b 45 08             	mov    0x8(%ebp),%eax
c002111f:	ff d0                	call   *%eax
c0021121:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0021124:	e8 b7 fd ff ff       	call   c0020ee0 <thread_exit>

c0021129 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0021129:	55                   	push   %ebp
c002112a:	89 e5                	mov    %esp,%ebp
c002112c:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c002112f:	89 e0                	mov    %esp,%eax
c0021131:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c0021134:	ff 75 fc             	pushl  -0x4(%ebp)
c0021137:	e8 37 f9 ff ff       	call   c0020a73 <pg_round_down>
c002113c:	83 c4 04             	add    $0x4,%esp
}
c002113f:	c9                   	leave  
c0021140:	c3                   	ret    

c0021141 <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c0021141:	55                   	push   %ebp
c0021142:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0021144:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021148:	74 14                	je     c002115e <is_thread+0x1d>
c002114a:	8b 45 08             	mov    0x8(%ebp),%eax
c002114d:	8b 40 54             	mov    0x54(%eax),%eax
c0021150:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0021155:	75 07                	jne    c002115e <is_thread+0x1d>
c0021157:	b8 01 00 00 00       	mov    $0x1,%eax
c002115c:	eb 05                	jmp    c0021163 <is_thread+0x22>
c002115e:	b8 00 00 00 00       	mov    $0x0,%eax
c0021163:	83 e0 01             	and    $0x1,%eax
}
c0021166:	5d                   	pop    %ebp
c0021167:	c3                   	ret    

c0021168 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0021168:	55                   	push   %ebp
c0021169:	89 e5                	mov    %esp,%ebp
c002116b:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c002116e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021172:	75 21                	jne    c0021195 <init_thread+0x2d>
c0021174:	83 ec 0c             	sub    $0xc,%esp
c0021177:	68 d6 fc 02 c0       	push   $0xc002fcd6
c002117c:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0021181:	68 fc fd 02 c0       	push   $0xc002fdfc
c0021186:	68 c8 01 00 00       	push   $0x1c8
c002118b:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0021190:	e8 d9 85 00 00       	call   c002976e <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0021195:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021199:	78 06                	js     c00211a1 <init_thread+0x39>
c002119b:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c002119f:	7e 21                	jle    c00211c2 <init_thread+0x5a>
c00211a1:	83 ec 0c             	sub    $0xc,%esp
c00211a4:	68 e0 fc 02 c0       	push   $0xc002fce0
c00211a9:	68 d2 fb 02 c0       	push   $0xc002fbd2
c00211ae:	68 fc fd 02 c0       	push   $0xc002fdfc
c00211b3:	68 c9 01 00 00       	push   $0x1c9
c00211b8:	68 e9 fb 02 c0       	push   $0xc002fbe9
c00211bd:	e8 ac 85 00 00       	call   c002976e <debug_panic>
  ASSERT (name != NULL);
c00211c2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00211c6:	75 21                	jne    c00211e9 <init_thread+0x81>
c00211c8:	83 ec 0c             	sub    $0xc,%esp
c00211cb:	68 0b fd 02 c0       	push   $0xc002fd0b
c00211d0:	68 d2 fb 02 c0       	push   $0xc002fbd2
c00211d5:	68 fc fd 02 c0       	push   $0xc002fdfc
c00211da:	68 ca 01 00 00       	push   $0x1ca
c00211df:	68 e9 fb 02 c0       	push   $0xc002fbe9
c00211e4:	e8 85 85 00 00       	call   c002976e <debug_panic>

  memset (t, 0, sizeof *t);
c00211e9:	83 ec 04             	sub    $0x4,%esp
c00211ec:	6a 58                	push   $0x58
c00211ee:	6a 00                	push   $0x0
c00211f0:	ff 75 08             	pushl  0x8(%ebp)
c00211f3:	e8 90 79 00 00       	call   c0028b88 <memset>
c00211f8:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c00211fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00211fe:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c0021205:	8b 45 08             	mov    0x8(%ebp),%eax
c0021208:	83 c0 08             	add    $0x8,%eax
c002120b:	83 ec 04             	sub    $0x4,%esp
c002120e:	6a 10                	push   $0x10
c0021210:	ff 75 0c             	pushl  0xc(%ebp)
c0021213:	50                   	push   %eax
c0021214:	e8 42 7a 00 00       	call   c0028c5b <strlcpy>
c0021219:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c002121c:	8b 45 08             	mov    0x8(%ebp),%eax
c002121f:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0021225:	8b 45 08             	mov    0x8(%ebp),%eax
c0021228:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c002122b:	8b 45 08             	mov    0x8(%ebp),%eax
c002122e:	8b 55 10             	mov    0x10(%ebp),%edx
c0021231:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021234:	8b 45 08             	mov    0x8(%ebp),%eax
c0021237:	c7 40 54 4b bf 6a cd 	movl   $0xcd6abf4b,0x54(%eax)

  t->is_exited = false;
c002123e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021241:	c6 40 30 00          	movb   $0x0,0x30(%eax)
  t->parent = running_thread();
c0021245:	e8 df fe ff ff       	call   c0021129 <running_thread>
c002124a:	89 c2                	mov    %eax,%edx
c002124c:	8b 45 08             	mov    0x8(%ebp),%eax
c002124f:	89 50 34             	mov    %edx,0x34(%eax)
  list_init (&t->files);
c0021252:	8b 45 08             	mov    0x8(%ebp),%eax
c0021255:	83 c0 3c             	add    $0x3c,%eax
c0021258:	83 ec 0c             	sub    $0xc,%esp
c002125b:	50                   	push   %eax
c002125c:	e8 7e 87 00 00       	call   c00299df <list_init>
c0021261:	83 c4 10             	add    $0x10,%esp
  t->fd_count=2;
c0021264:	8b 45 08             	mov    0x8(%ebp),%eax
c0021267:	c7 40 4c 02 00 00 00 	movl   $0x2,0x4c(%eax)

  old_level = intr_disable ();
c002126e:	e8 50 03 00 00       	call   c00215c3 <intr_disable>
c0021273:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_push_back (&all_list, &t->allelem);
c0021276:	8b 45 08             	mov    0x8(%ebp),%eax
c0021279:	83 c0 20             	add    $0x20,%eax
c002127c:	83 ec 08             	sub    $0x8,%esp
c002127f:	50                   	push   %eax
c0021280:	68 b8 89 03 c0       	push   $0xc00389b8
c0021285:	e8 35 8b 00 00       	call   c0029dbf <list_push_back>
c002128a:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c002128d:	83 ec 0c             	sub    $0xc,%esp
c0021290:	ff 75 f4             	pushl  -0xc(%ebp)
c0021293:	e8 d3 02 00 00       	call   c002156b <intr_set_level>
c0021298:	83 c4 10             	add    $0x10,%esp
}
c002129b:	90                   	nop
c002129c:	c9                   	leave  
c002129d:	c3                   	ret    

c002129e <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c002129e:	55                   	push   %ebp
c002129f:	89 e5                	mov    %esp,%ebp
c00212a1:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c00212a4:	ff 75 08             	pushl  0x8(%ebp)
c00212a7:	e8 95 fe ff ff       	call   c0021141 <is_thread>
c00212ac:	83 c4 04             	add    $0x4,%esp
c00212af:	84 c0                	test   %al,%al
c00212b1:	75 21                	jne    c00212d4 <alloc_frame+0x36>
c00212b3:	83 ec 0c             	sub    $0xc,%esp
c00212b6:	68 6b fc 02 c0       	push   $0xc002fc6b
c00212bb:	68 d2 fb 02 c0       	push   $0xc002fbd2
c00212c0:	68 08 fe 02 c0       	push   $0xc002fe08
c00212c5:	68 e3 01 00 00       	push   $0x1e3
c00212ca:	68 e9 fb 02 c0       	push   $0xc002fbe9
c00212cf:	e8 9a 84 00 00       	call   c002976e <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00212d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00212d7:	83 e0 03             	and    $0x3,%eax
c00212da:	85 c0                	test   %eax,%eax
c00212dc:	74 21                	je     c00212ff <alloc_frame+0x61>
c00212de:	83 ec 0c             	sub    $0xc,%esp
c00212e1:	68 18 fd 02 c0       	push   $0xc002fd18
c00212e6:	68 d2 fb 02 c0       	push   $0xc002fbd2
c00212eb:	68 08 fe 02 c0       	push   $0xc002fe08
c00212f0:	68 e4 01 00 00       	push   $0x1e4
c00212f5:	68 e9 fb 02 c0       	push   $0xc002fbe9
c00212fa:	e8 6f 84 00 00       	call   c002976e <debug_panic>

  t->stack -= size;
c00212ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0021302:	8b 40 18             	mov    0x18(%eax),%eax
c0021305:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021308:	f7 da                	neg    %edx
c002130a:	01 c2                	add    %eax,%edx
c002130c:	8b 45 08             	mov    0x8(%ebp),%eax
c002130f:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c0021312:	8b 45 08             	mov    0x8(%ebp),%eax
c0021315:	8b 40 18             	mov    0x18(%eax),%eax
}
c0021318:	c9                   	leave  
c0021319:	c3                   	ret    

c002131a <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c002131a:	55                   	push   %ebp
c002131b:	89 e5                	mov    %esp,%ebp
c002131d:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c0021320:	83 ec 0c             	sub    $0xc,%esp
c0021323:	68 a8 89 03 c0       	push   $0xc00389a8
c0021328:	e8 39 8c 00 00       	call   c0029f66 <list_empty>
c002132d:	83 c4 10             	add    $0x10,%esp
c0021330:	84 c0                	test   %al,%al
c0021332:	74 07                	je     c002133b <next_thread_to_run+0x21>
    return idle_thread;
c0021334:	a1 c8 89 03 c0       	mov    0xc00389c8,%eax
c0021339:	eb 16                	jmp    c0021351 <next_thread_to_run+0x37>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c002133b:	83 ec 0c             	sub    $0xc,%esp
c002133e:	68 a8 89 03 c0       	push   $0xc00389a8
c0021343:	e8 f6 8a 00 00       	call   c0029e3e <list_pop_front>
c0021348:	83 c4 10             	add    $0x10,%esp
c002134b:	83 c0 04             	add    $0x4,%eax
c002134e:	83 e8 2c             	sub    $0x2c,%eax
}
c0021351:	c9                   	leave  
c0021352:	c3                   	ret    

c0021353 <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0021353:	55                   	push   %ebp
c0021354:	89 e5                	mov    %esp,%ebp
c0021356:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021359:	e8 cb fd ff ff       	call   c0021129 <running_thread>
c002135e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c0021361:	e8 e8 01 00 00       	call   c002154e <intr_get_level>
c0021366:	85 c0                	test   %eax,%eax
c0021368:	74 21                	je     c002138b <thread_schedule_tail+0x38>
c002136a:	83 ec 0c             	sub    $0xc,%esp
c002136d:	68 b4 fb 02 c0       	push   $0xc002fbb4
c0021372:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0021377:	68 14 fe 02 c0       	push   $0xc002fe14
c002137c:	68 0d 02 00 00       	push   $0x20d
c0021381:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0021386:	e8 e3 83 00 00       	call   c002976e <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c002138b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002138e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c0021395:	c7 05 00 8a 03 c0 00 	movl   $0x0,0xc0038a00
c002139c:	00 00 00 

#ifdef USERPROG
  /* Activate the new address space. */
  process_activate ();
c002139f:	e8 c1 a9 00 00       	call   c002bd65 <process_activate>
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c00213a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00213a8:	74 4c                	je     c00213f6 <thread_schedule_tail+0xa3>
c00213aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00213ad:	8b 40 04             	mov    0x4(%eax),%eax
c00213b0:	83 f8 03             	cmp    $0x3,%eax
c00213b3:	75 41                	jne    c00213f6 <thread_schedule_tail+0xa3>
c00213b5:	a1 cc 89 03 c0       	mov    0xc00389cc,%eax
c00213ba:	39 45 08             	cmp    %eax,0x8(%ebp)
c00213bd:	74 37                	je     c00213f6 <thread_schedule_tail+0xa3>
    {
      ASSERT (prev != cur);
c00213bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00213c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00213c5:	75 21                	jne    c00213e8 <thread_schedule_tail+0x95>
c00213c7:	83 ec 0c             	sub    $0xc,%esp
c00213ca:	68 36 fd 02 c0       	push   $0xc002fd36
c00213cf:	68 d2 fb 02 c0       	push   $0xc002fbd2
c00213d4:	68 14 fe 02 c0       	push   $0xc002fe14
c00213d9:	68 21 02 00 00       	push   $0x221
c00213de:	68 e9 fb 02 c0       	push   $0xc002fbe9
c00213e3:	e8 86 83 00 00       	call   c002976e <debug_panic>
      palloc_free_page (prev);
c00213e8:	83 ec 0c             	sub    $0xc,%esp
c00213eb:	ff 75 08             	pushl  0x8(%ebp)
c00213ee:	e8 b0 20 00 00       	call   c00234a3 <palloc_free_page>
c00213f3:	83 c4 10             	add    $0x10,%esp
    }
}
c00213f6:	90                   	nop
c00213f7:	c9                   	leave  
c00213f8:	c3                   	ret    

c00213f9 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c00213f9:	55                   	push   %ebp
c00213fa:	89 e5                	mov    %esp,%ebp
c00213fc:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c00213ff:	e8 25 fd ff ff       	call   c0021129 <running_thread>
c0021404:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c0021407:	e8 0e ff ff ff       	call   c002131a <next_thread_to_run>
c002140c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c002140f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0021416:	e8 33 01 00 00       	call   c002154e <intr_get_level>
c002141b:	85 c0                	test   %eax,%eax
c002141d:	74 21                	je     c0021440 <schedule+0x47>
c002141f:	83 ec 0c             	sub    $0xc,%esp
c0021422:	68 b4 fb 02 c0       	push   $0xc002fbb4
c0021427:	68 d2 fb 02 c0       	push   $0xc002fbd2
c002142c:	68 2c fe 02 c0       	push   $0xc002fe2c
c0021431:	68 34 02 00 00       	push   $0x234
c0021436:	68 e9 fb 02 c0       	push   $0xc002fbe9
c002143b:	e8 2e 83 00 00       	call   c002976e <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021440:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021443:	8b 40 04             	mov    0x4(%eax),%eax
c0021446:	85 c0                	test   %eax,%eax
c0021448:	75 21                	jne    c002146b <schedule+0x72>
c002144a:	83 ec 0c             	sub    $0xc,%esp
c002144d:	68 42 fd 02 c0       	push   $0xc002fd42
c0021452:	68 d2 fb 02 c0       	push   $0xc002fbd2
c0021457:	68 2c fe 02 c0       	push   $0xc002fe2c
c002145c:	68 35 02 00 00       	push   $0x235
c0021461:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0021466:	e8 03 83 00 00       	call   c002976e <debug_panic>
  ASSERT (is_thread (next));
c002146b:	83 ec 0c             	sub    $0xc,%esp
c002146e:	ff 75 ec             	pushl  -0x14(%ebp)
c0021471:	e8 cb fc ff ff       	call   c0021141 <is_thread>
c0021476:	83 c4 10             	add    $0x10,%esp
c0021479:	84 c0                	test   %al,%al
c002147b:	75 21                	jne    c002149e <schedule+0xa5>
c002147d:	83 ec 0c             	sub    $0xc,%esp
c0021480:	68 60 fd 02 c0       	push   $0xc002fd60
c0021485:	68 d2 fb 02 c0       	push   $0xc002fbd2
c002148a:	68 2c fe 02 c0       	push   $0xc002fe2c
c002148f:	68 36 02 00 00       	push   $0x236
c0021494:	68 e9 fb 02 c0       	push   $0xc002fbe9
c0021499:	e8 d0 82 00 00       	call   c002976e <debug_panic>

  if (cur != next)
c002149e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00214a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00214a4:	74 14                	je     c00214ba <schedule+0xc1>
    prev = switch_threads (cur, next);
c00214a6:	83 ec 08             	sub    $0x8,%esp
c00214a9:	ff 75 ec             	pushl  -0x14(%ebp)
c00214ac:	ff 75 f0             	pushl  -0x10(%ebp)
c00214af:	e8 53 00 00 00       	call   c0021507 <switch_threads>
c00214b4:	83 c4 10             	add    $0x10,%esp
c00214b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c00214ba:	83 ec 0c             	sub    $0xc,%esp
c00214bd:	ff 75 f4             	pushl  -0xc(%ebp)
c00214c0:	e8 8e fe ff ff       	call   c0021353 <thread_schedule_tail>
c00214c5:	83 c4 10             	add    $0x10,%esp
}
c00214c8:	90                   	nop
c00214c9:	c9                   	leave  
c00214ca:	c3                   	ret    

c00214cb <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c00214cb:	55                   	push   %ebp
c00214cc:	89 e5                	mov    %esp,%ebp
c00214ce:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c00214d1:	83 ec 0c             	sub    $0xc,%esp
c00214d4:	68 d0 89 03 c0       	push   $0xc00389d0
c00214d9:	e8 e9 17 00 00       	call   c0022cc7 <lock_acquire>
c00214de:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c00214e1:	a1 e8 7f 03 c0       	mov    0xc0037fe8,%eax
c00214e6:	8d 50 01             	lea    0x1(%eax),%edx
c00214e9:	89 15 e8 7f 03 c0    	mov    %edx,0xc0037fe8
c00214ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c00214f2:	83 ec 0c             	sub    $0xc,%esp
c00214f5:	68 d0 89 03 c0       	push   $0xc00389d0
c00214fa:	e8 08 19 00 00       	call   c0022e07 <lock_release>
c00214ff:	83 c4 10             	add    $0x10,%esp

  return tid;
c0021502:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021505:	c9                   	leave  
c0021506:	c3                   	ret    

c0021507 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021507:	53                   	push   %ebx
	pushl %ebp
c0021508:	55                   	push   %ebp
	pushl %esi
c0021509:	56                   	push   %esi
	pushl %edi
c002150a:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c002150b:	8b 15 e4 7f 03 c0    	mov    0xc0037fe4,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021511:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021515:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021518:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c002151c:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c002151f:	5f                   	pop    %edi
	popl %esi
c0021520:	5e                   	pop    %esi
	popl %ebp
c0021521:	5d                   	pop    %ebp
	popl %ebx
c0021522:	5b                   	pop    %ebx
        ret
c0021523:	c3                   	ret    

c0021524 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021524:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021527:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021528:	e8 26 fe ff ff       	call   c0021353 <thread_schedule_tail>
	addl $4, %esp
c002152d:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021530:	c3                   	ret    

c0021531 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0021531:	55                   	push   %ebp
c0021532:	89 e5                	mov    %esp,%ebp
c0021534:	83 ec 08             	sub    $0x8,%esp
c0021537:	8b 45 08             	mov    0x8(%ebp),%eax
c002153a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002153d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0021541:	88 55 f8             	mov    %dl,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021544:	8a 45 f8             	mov    -0x8(%ebp),%al
c0021547:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002154a:	ee                   	out    %al,(%dx)
}
c002154b:	90                   	nop
c002154c:	c9                   	leave  
c002154d:	c3                   	ret    

c002154e <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c002154e:	55                   	push   %ebp
c002154f:	89 e5                	mov    %esp,%ebp
c0021551:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021554:	9c                   	pushf  
c0021555:	58                   	pop    %eax
c0021556:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021559:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002155c:	25 00 02 00 00       	and    $0x200,%eax
c0021561:	85 c0                	test   %eax,%eax
c0021563:	0f 95 c0             	setne  %al
c0021566:	0f b6 c0             	movzbl %al,%eax
}
c0021569:	c9                   	leave  
c002156a:	c3                   	ret    

c002156b <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c002156b:	55                   	push   %ebp
c002156c:	89 e5                	mov    %esp,%ebp
c002156e:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c0021571:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0021575:	75 07                	jne    c002157e <intr_set_level+0x13>
c0021577:	e8 09 00 00 00       	call   c0021585 <intr_enable>
c002157c:	eb 05                	jmp    c0021583 <intr_set_level+0x18>
c002157e:	e8 40 00 00 00       	call   c00215c3 <intr_disable>
}
c0021583:	c9                   	leave  
c0021584:	c3                   	ret    

c0021585 <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c0021585:	55                   	push   %ebp
c0021586:	89 e5                	mov    %esp,%ebp
c0021588:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c002158b:	e8 be ff ff ff       	call   c002154e <intr_get_level>
c0021590:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c0021593:	e8 f8 02 00 00       	call   c0021890 <intr_context>
c0021598:	83 f0 01             	xor    $0x1,%eax
c002159b:	84 c0                	test   %al,%al
c002159d:	75 1e                	jne    c00215bd <intr_enable+0x38>
c002159f:	83 ec 0c             	sub    $0xc,%esp
c00215a2:	68 38 fe 02 c0       	push   $0xc002fe38
c00215a7:	68 49 fe 02 c0       	push   $0xc002fe49
c00215ac:	68 48 02 03 c0       	push   $0xc0030248
c00215b1:	6a 5b                	push   $0x5b
c00215b3:	68 60 fe 02 c0       	push   $0xc002fe60
c00215b8:	e8 b1 81 00 00       	call   c002976e <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c00215bd:	fb                   	sti    

  return old_level;
c00215be:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00215c1:	c9                   	leave  
c00215c2:	c3                   	ret    

c00215c3 <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c00215c3:	55                   	push   %ebp
c00215c4:	89 e5                	mov    %esp,%ebp
c00215c6:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c00215c9:	e8 80 ff ff ff       	call   c002154e <intr_get_level>
c00215ce:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c00215d1:	fa                   	cli    

  return old_level;
c00215d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00215d5:	c9                   	leave  
c00215d6:	c3                   	ret    

c00215d7 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00215d7:	55                   	push   %ebp
c00215d8:	89 e5                	mov    %esp,%ebp
c00215da:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c00215dd:	e8 f2 02 00 00       	call   c00218d4 <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00215e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00215e9:	eb 2c                	jmp    c0021617 <intr_init+0x40>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00215eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00215ee:	8b 04 85 ec 7f 03 c0 	mov    -0x3ffc8014(,%eax,4),%eax
c00215f5:	83 ec 08             	sub    $0x8,%esp
c00215f8:	6a 00                	push   $0x0
c00215fa:	50                   	push   %eax
c00215fb:	e8 ce 04 00 00       	call   c0021ace <make_intr_gate>
c0021600:	83 c4 10             	add    $0x10,%esp
c0021603:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0021606:	89 04 cd 20 8a 03 c0 	mov    %eax,-0x3ffc75e0(,%ecx,8)
c002160d:	89 14 cd 24 8a 03 c0 	mov    %edx,-0x3ffc75dc(,%ecx,8)
  for (i = 0; i < INTR_CNT; i++)
c0021614:	ff 45 f4             	incl   -0xc(%ebp)
c0021617:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c002161e:	7e cb                	jle    c00215eb <intr_init+0x14>

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c0021620:	83 ec 08             	sub    $0x8,%esp
c0021623:	68 20 8a 03 c0       	push   $0xc0038a20
c0021628:	68 ff 07 00 00       	push   $0x7ff
c002162d:	e8 d2 04 00 00       	call   c0021b04 <make_idtr_operand>
c0021632:	83 c4 10             	add    $0x10,%esp
c0021635:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021638:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c002163b:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c002163f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0021646:	eb 11                	jmp    c0021659 <intr_init+0x82>
    intr_names[i] = "unknown";
c0021648:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002164b:	c7 04 85 20 96 03 c0 	movl   $0xc002fe7a,-0x3ffc69e0(,%eax,4)
c0021652:	7a fe 02 c0 
  for (i = 0; i < INTR_CNT; i++)
c0021656:	ff 45 f4             	incl   -0xc(%ebp)
c0021659:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021660:	7e e6                	jle    c0021648 <intr_init+0x71>
  intr_names[0] = "#DE Divide Error";
c0021662:	c7 05 20 96 03 c0 82 	movl   $0xc002fe82,0xc0039620
c0021669:	fe 02 c0 
  intr_names[1] = "#DB Debug Exception";
c002166c:	c7 05 24 96 03 c0 93 	movl   $0xc002fe93,0xc0039624
c0021673:	fe 02 c0 
  intr_names[2] = "NMI Interrupt";
c0021676:	c7 05 28 96 03 c0 a7 	movl   $0xc002fea7,0xc0039628
c002167d:	fe 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c0021680:	c7 05 2c 96 03 c0 b5 	movl   $0xc002feb5,0xc003962c
c0021687:	fe 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c002168a:	c7 05 30 96 03 c0 ce 	movl   $0xc002fece,0xc0039630
c0021691:	fe 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c0021694:	c7 05 34 96 03 c0 e8 	movl   $0xc002fee8,0xc0039634
c002169b:	fe 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c002169e:	c7 05 38 96 03 c0 0b 	movl   $0xc002ff0b,0xc0039638
c00216a5:	ff 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c00216a8:	c7 05 3c 96 03 c0 28 	movl   $0xc002ff28,0xc003963c
c00216af:	ff 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c00216b2:	c7 05 40 96 03 c0 4b 	movl   $0xc002ff4b,0xc0039640
c00216b9:	ff 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c00216bc:	c7 05 44 96 03 c0 66 	movl   $0xc002ff66,0xc0039644
c00216c3:	ff 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c00216c6:	c7 05 48 96 03 c0 82 	movl   $0xc002ff82,0xc0039648
c00216cd:	ff 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c00216d0:	c7 05 4c 96 03 c0 9c 	movl   $0xc002ff9c,0xc003964c
c00216d7:	ff 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c00216da:	c7 05 50 96 03 c0 b4 	movl   $0xc002ffb4,0xc0039650
c00216e1:	ff 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c00216e4:	c7 05 54 96 03 c0 d0 	movl   $0xc002ffd0,0xc0039654
c00216eb:	ff 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c00216ee:	c7 05 58 96 03 c0 f1 	movl   $0xc002fff1,0xc0039658
c00216f5:	ff 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c00216f8:	c7 05 60 96 03 c0 0c 	movl   $0xc003000c,0xc0039660
c00216ff:	00 03 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021702:	c7 05 64 96 03 c0 2d 	movl   $0xc003002d,0xc0039664
c0021709:	00 03 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c002170c:	c7 05 68 96 03 c0 4b 	movl   $0xc003004b,0xc0039668
c0021713:	00 03 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0021716:	c7 05 6c 96 03 c0 68 	movl   $0xc0030068,0xc003966c
c002171d:	00 03 c0 
}
c0021720:	90                   	nop
c0021721:	c9                   	leave  
c0021722:	c3                   	ret    

c0021723 <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c0021723:	55                   	push   %ebp
c0021724:	89 e5                	mov    %esp,%ebp
c0021726:	53                   	push   %ebx
c0021727:	83 ec 14             	sub    $0x14,%esp
c002172a:	8b 45 08             	mov    0x8(%ebp),%eax
c002172d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c0021730:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021734:	8b 04 85 20 92 03 c0 	mov    -0x3ffc6de0(,%eax,4),%eax
c002173b:	85 c0                	test   %eax,%eax
c002173d:	74 21                	je     c0021760 <register_handler+0x3d>
c002173f:	83 ec 0c             	sub    $0xc,%esp
c0021742:	68 8a 00 03 c0       	push   $0xc003008a
c0021747:	68 49 fe 02 c0       	push   $0xc002fe49
c002174c:	68 54 02 03 c0       	push   $0xc0030254
c0021751:	68 a8 00 00 00       	push   $0xa8
c0021756:	68 60 fe 02 c0       	push   $0xc002fe60
c002175b:	e8 0e 80 00 00       	call   c002976e <debug_panic>
  if (level == INTR_ON)
c0021760:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c0021764:	75 2e                	jne    c0021794 <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c0021766:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002176a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002176e:	8b 04 85 ec 7f 03 c0 	mov    -0x3ffc8014(,%eax,4),%eax
c0021775:	83 ec 08             	sub    $0x8,%esp
c0021778:	ff 75 0c             	pushl  0xc(%ebp)
c002177b:	50                   	push   %eax
c002177c:	e8 68 03 00 00       	call   c0021ae9 <make_trap_gate>
c0021781:	83 c4 10             	add    $0x10,%esp
c0021784:	89 04 dd 20 8a 03 c0 	mov    %eax,-0x3ffc75e0(,%ebx,8)
c002178b:	89 14 dd 24 8a 03 c0 	mov    %edx,-0x3ffc75dc(,%ebx,8)
c0021792:	eb 2c                	jmp    c00217c0 <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c0021794:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021798:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002179c:	8b 04 85 ec 7f 03 c0 	mov    -0x3ffc8014(,%eax,4),%eax
c00217a3:	83 ec 08             	sub    $0x8,%esp
c00217a6:	ff 75 0c             	pushl  0xc(%ebp)
c00217a9:	50                   	push   %eax
c00217aa:	e8 1f 03 00 00       	call   c0021ace <make_intr_gate>
c00217af:	83 c4 10             	add    $0x10,%esp
c00217b2:	89 04 dd 20 8a 03 c0 	mov    %eax,-0x3ffc75e0(,%ebx,8)
c00217b9:	89 14 dd 24 8a 03 c0 	mov    %edx,-0x3ffc75dc(,%ebx,8)
  intr_handlers[vec_no] = handler;
c00217c0:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00217c4:	8b 55 14             	mov    0x14(%ebp),%edx
c00217c7:	89 14 85 20 92 03 c0 	mov    %edx,-0x3ffc6de0(,%eax,4)
  intr_names[vec_no] = name;
c00217ce:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00217d2:	8b 55 18             	mov    0x18(%ebp),%edx
c00217d5:	89 14 85 20 96 03 c0 	mov    %edx,-0x3ffc69e0(,%eax,4)
}
c00217dc:	90                   	nop
c00217dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00217e0:	c9                   	leave  
c00217e1:	c3                   	ret    

c00217e2 <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c00217e2:	55                   	push   %ebp
c00217e3:	89 e5                	mov    %esp,%ebp
c00217e5:	83 ec 18             	sub    $0x18,%esp
c00217e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00217eb:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c00217ee:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c00217f2:	76 06                	jbe    c00217fa <intr_register_ext+0x18>
c00217f4:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c00217f8:	76 21                	jbe    c002181b <intr_register_ext+0x39>
c00217fa:	83 ec 0c             	sub    $0xc,%esp
c00217fd:	68 a8 00 03 c0       	push   $0xc00300a8
c0021802:	68 49 fe 02 c0       	push   $0xc002fe49
c0021807:	68 68 02 03 c0       	push   $0xc0030268
c002180c:	68 b8 00 00 00       	push   $0xb8
c0021811:	68 60 fe 02 c0       	push   $0xc002fe60
c0021816:	e8 53 7f 00 00       	call   c002976e <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c002181b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002181f:	83 ec 0c             	sub    $0xc,%esp
c0021822:	ff 75 10             	pushl  0x10(%ebp)
c0021825:	ff 75 0c             	pushl  0xc(%ebp)
c0021828:	6a 00                	push   $0x0
c002182a:	6a 00                	push   $0x0
c002182c:	50                   	push   %eax
c002182d:	e8 f1 fe ff ff       	call   c0021723 <register_handler>
c0021832:	83 c4 20             	add    $0x20,%esp
}
c0021835:	90                   	nop
c0021836:	c9                   	leave  
c0021837:	c3                   	ret    

c0021838 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021838:	55                   	push   %ebp
c0021839:	89 e5                	mov    %esp,%ebp
c002183b:	83 ec 18             	sub    $0x18,%esp
c002183e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021841:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c0021844:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021848:	76 27                	jbe    c0021871 <intr_register_int+0x39>
c002184a:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c002184e:	77 21                	ja     c0021871 <intr_register_int+0x39>
c0021850:	83 ec 0c             	sub    $0xc,%esp
c0021853:	68 cc 00 03 c0       	push   $0xc00300cc
c0021858:	68 49 fe 02 c0       	push   $0xc002fe49
c002185d:	68 7c 02 03 c0       	push   $0xc003027c
c0021862:	68 cd 00 00 00       	push   $0xcd
c0021867:	68 60 fe 02 c0       	push   $0xc002fe60
c002186c:	e8 fd 7e 00 00       	call   c002976e <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c0021871:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021875:	83 ec 0c             	sub    $0xc,%esp
c0021878:	ff 75 18             	pushl  0x18(%ebp)
c002187b:	ff 75 14             	pushl  0x14(%ebp)
c002187e:	ff 75 10             	pushl  0x10(%ebp)
c0021881:	ff 75 0c             	pushl  0xc(%ebp)
c0021884:	50                   	push   %eax
c0021885:	e8 99 fe ff ff       	call   c0021723 <register_handler>
c002188a:	83 c4 20             	add    $0x20,%esp
}
c002188d:	90                   	nop
c002188e:	c9                   	leave  
c002188f:	c3                   	ret    

c0021890 <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c0021890:	55                   	push   %ebp
c0021891:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c0021893:	a0 20 9e 03 c0       	mov    0xc0039e20,%al
}
c0021898:	5d                   	pop    %ebp
c0021899:	c3                   	ret    

c002189a <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c002189a:	55                   	push   %ebp
c002189b:	89 e5                	mov    %esp,%ebp
c002189d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c00218a0:	e8 eb ff ff ff       	call   c0021890 <intr_context>
c00218a5:	84 c0                	test   %al,%al
c00218a7:	75 21                	jne    c00218ca <intr_yield_on_return+0x30>
c00218a9:	83 ec 0c             	sub    $0xc,%esp
c00218ac:	68 eb 00 03 c0       	push   $0xc00300eb
c00218b1:	68 49 fe 02 c0       	push   $0xc002fe49
c00218b6:	68 90 02 03 c0       	push   $0xc0030290
c00218bb:	68 e0 00 00 00       	push   $0xe0
c00218c0:	68 60 fe 02 c0       	push   $0xc002fe60
c00218c5:	e8 a4 7e 00 00       	call   c002976e <debug_panic>
  yield_on_return = true;
c00218ca:	c6 05 21 9e 03 c0 01 	movb   $0x1,0xc0039e21
}
c00218d1:	90                   	nop
c00218d2:	c9                   	leave  
c00218d3:	c3                   	ret    

c00218d4 <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c00218d4:	55                   	push   %ebp
c00218d5:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c00218d7:	68 ff 00 00 00       	push   $0xff
c00218dc:	6a 21                	push   $0x21
c00218de:	e8 4e fc ff ff       	call   c0021531 <outb>
c00218e3:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c00218e6:	68 ff 00 00 00       	push   $0xff
c00218eb:	68 a1 00 00 00       	push   $0xa1
c00218f0:	e8 3c fc ff ff       	call   c0021531 <outb>
c00218f5:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c00218f8:	6a 11                	push   $0x11
c00218fa:	6a 20                	push   $0x20
c00218fc:	e8 30 fc ff ff       	call   c0021531 <outb>
c0021901:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c0021904:	6a 20                	push   $0x20
c0021906:	6a 21                	push   $0x21
c0021908:	e8 24 fc ff ff       	call   c0021531 <outb>
c002190d:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c0021910:	6a 04                	push   $0x4
c0021912:	6a 21                	push   $0x21
c0021914:	e8 18 fc ff ff       	call   c0021531 <outb>
c0021919:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c002191c:	6a 01                	push   $0x1
c002191e:	6a 21                	push   $0x21
c0021920:	e8 0c fc ff ff       	call   c0021531 <outb>
c0021925:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021928:	6a 11                	push   $0x11
c002192a:	68 a0 00 00 00       	push   $0xa0
c002192f:	e8 fd fb ff ff       	call   c0021531 <outb>
c0021934:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021937:	6a 28                	push   $0x28
c0021939:	68 a1 00 00 00       	push   $0xa1
c002193e:	e8 ee fb ff ff       	call   c0021531 <outb>
c0021943:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c0021946:	6a 02                	push   $0x2
c0021948:	68 a1 00 00 00       	push   $0xa1
c002194d:	e8 df fb ff ff       	call   c0021531 <outb>
c0021952:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021955:	6a 01                	push   $0x1
c0021957:	68 a1 00 00 00       	push   $0xa1
c002195c:	e8 d0 fb ff ff       	call   c0021531 <outb>
c0021961:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c0021964:	6a 00                	push   $0x0
c0021966:	6a 21                	push   $0x21
c0021968:	e8 c4 fb ff ff       	call   c0021531 <outb>
c002196d:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c0021970:	6a 00                	push   $0x0
c0021972:	68 a1 00 00 00       	push   $0xa1
c0021977:	e8 b5 fb ff ff       	call   c0021531 <outb>
c002197c:	83 c4 08             	add    $0x8,%esp
}
c002197f:	90                   	nop
c0021980:	c9                   	leave  
c0021981:	c3                   	ret    

c0021982 <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c0021982:	55                   	push   %ebp
c0021983:	89 e5                	mov    %esp,%ebp
c0021985:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021988:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c002198c:	7e 06                	jle    c0021994 <pic_end_of_interrupt+0x12>
c002198e:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0021992:	7e 21                	jle    c00219b5 <pic_end_of_interrupt+0x33>
c0021994:	83 ec 0c             	sub    $0xc,%esp
c0021997:	68 fb 00 03 c0       	push   $0xc00300fb
c002199c:	68 49 fe 02 c0       	push   $0xc002fe49
c00219a1:	68 a8 02 03 c0       	push   $0xc00302a8
c00219a6:	68 0b 01 00 00       	push   $0x10b
c00219ab:	68 60 fe 02 c0       	push   $0xc002fe60
c00219b0:	e8 b9 7d 00 00       	call   c002976e <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c00219b5:	83 ec 08             	sub    $0x8,%esp
c00219b8:	6a 20                	push   $0x20
c00219ba:	6a 20                	push   $0x20
c00219bc:	e8 70 fb ff ff       	call   c0021531 <outb>
c00219c1:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c00219c4:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c00219c8:	7e 12                	jle    c00219dc <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c00219ca:	83 ec 08             	sub    $0x8,%esp
c00219cd:	6a 20                	push   $0x20
c00219cf:	68 a0 00 00 00       	push   $0xa0
c00219d4:	e8 58 fb ff ff       	call   c0021531 <outb>
c00219d9:	83 c4 10             	add    $0x10,%esp
}
c00219dc:	90                   	nop
c00219dd:	c9                   	leave  
c00219de:	c3                   	ret    

c00219df <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00219df:	55                   	push   %ebp
c00219e0:	89 e5                	mov    %esp,%ebp
c00219e2:	57                   	push   %edi
c00219e3:	56                   	push   %esi
c00219e4:	53                   	push   %ebx
c00219e5:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00219e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00219ec:	75 21                	jne    c0021a0f <make_gate+0x30>
c00219ee:	83 ec 0c             	sub    $0xc,%esp
c00219f1:	68 15 01 03 c0       	push   $0xc0030115
c00219f6:	68 49 fe 02 c0       	push   $0xc002fe49
c00219fb:	68 c0 02 03 c0       	push   $0xc00302c0
c0021a00:	68 2a 01 00 00       	push   $0x12a
c0021a05:	68 60 fe 02 c0       	push   $0xc002fe60
c0021a0a:	e8 5f 7d 00 00       	call   c002976e <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021a0f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0021a13:	78 06                	js     c0021a1b <make_gate+0x3c>
c0021a15:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0021a19:	7e 21                	jle    c0021a3c <make_gate+0x5d>
c0021a1b:	83 ec 0c             	sub    $0xc,%esp
c0021a1e:	68 26 01 03 c0       	push   $0xc0030126
c0021a23:	68 49 fe 02 c0       	push   $0xc002fe49
c0021a28:	68 c0 02 03 c0       	push   $0xc00302c0
c0021a2d:	68 2b 01 00 00       	push   $0x12b
c0021a32:	68 60 fe 02 c0       	push   $0xc002fe60
c0021a37:	e8 32 7d 00 00       	call   c002976e <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021a3c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021a40:	78 06                	js     c0021a48 <make_gate+0x69>
c0021a42:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c0021a46:	7e 21                	jle    c0021a69 <make_gate+0x8a>
c0021a48:	83 ec 0c             	sub    $0xc,%esp
c0021a4b:	68 3b 01 03 c0       	push   $0xc003013b
c0021a50:	68 49 fe 02 c0       	push   $0xc002fe49
c0021a55:	68 c0 02 03 c0       	push   $0xc00302c0
c0021a5a:	68 2c 01 00 00       	push   $0x12c
c0021a5f:	68 60 fe 02 c0       	push   $0xc002fe60
c0021a64:	e8 05 7d 00 00       	call   c002976e <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021a69:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a6c:	0f b7 c0             	movzwl %ax,%eax
c0021a6f:	0d 00 00 08 00       	or     $0x80000,%eax
c0021a74:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021a77:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a7a:	25 00 00 ff ff       	and    $0xffff0000,%eax
c0021a7f:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c0021a81:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021a84:	c1 e0 0d             	shl    $0xd,%eax
c0021a87:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021a89:	8b 45 10             	mov    0x10(%ebp),%eax
c0021a8c:	c1 e0 08             	shl    $0x8,%eax
c0021a8f:	09 d0                	or     %edx,%eax
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021a91:	80 cc 80             	or     $0x80,%ah
c0021a94:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c0021a97:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0021a9a:	bf 00 00 00 00       	mov    $0x0,%edi
c0021a9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0021aa2:	ba 00 00 00 00       	mov    $0x0,%edx
c0021aa7:	89 c2                	mov    %eax,%edx
c0021aa9:	b8 00 00 00 00       	mov    $0x0,%eax
c0021aae:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0021ab1:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0021ab4:	89 f0                	mov    %esi,%eax
c0021ab6:	0b 45 d0             	or     -0x30(%ebp),%eax
c0021ab9:	89 c1                	mov    %eax,%ecx
c0021abb:	89 f8                	mov    %edi,%eax
c0021abd:	0b 45 d4             	or     -0x2c(%ebp),%eax
c0021ac0:	89 c3                	mov    %eax,%ebx
c0021ac2:	89 c8                	mov    %ecx,%eax
c0021ac4:	89 da                	mov    %ebx,%edx
}
c0021ac6:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0021ac9:	5b                   	pop    %ebx
c0021aca:	5e                   	pop    %esi
c0021acb:	5f                   	pop    %edi
c0021acc:	5d                   	pop    %ebp
c0021acd:	c3                   	ret    

c0021ace <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c0021ace:	55                   	push   %ebp
c0021acf:	89 e5                	mov    %esp,%ebp
c0021ad1:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c0021ad4:	83 ec 04             	sub    $0x4,%esp
c0021ad7:	6a 0e                	push   $0xe
c0021ad9:	ff 75 0c             	pushl  0xc(%ebp)
c0021adc:	ff 75 08             	pushl  0x8(%ebp)
c0021adf:	e8 fb fe ff ff       	call   c00219df <make_gate>
c0021ae4:	83 c4 10             	add    $0x10,%esp
}
c0021ae7:	c9                   	leave  
c0021ae8:	c3                   	ret    

c0021ae9 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c0021ae9:	55                   	push   %ebp
c0021aea:	89 e5                	mov    %esp,%ebp
c0021aec:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c0021aef:	83 ec 04             	sub    $0x4,%esp
c0021af2:	6a 0f                	push   $0xf
c0021af4:	ff 75 0c             	pushl  0xc(%ebp)
c0021af7:	ff 75 08             	pushl  0x8(%ebp)
c0021afa:	e8 e0 fe ff ff       	call   c00219df <make_gate>
c0021aff:	83 c4 10             	add    $0x10,%esp
}
c0021b02:	c9                   	leave  
c0021b03:	c3                   	ret    

c0021b04 <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c0021b04:	55                   	push   %ebp
c0021b05:	89 e5                	mov    %esp,%ebp
c0021b07:	57                   	push   %edi
c0021b08:	56                   	push   %esi
c0021b09:	53                   	push   %ebx
c0021b0a:	83 ec 14             	sub    $0x14,%esp
c0021b0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b10:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021b14:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0021b18:	89 c6                	mov    %eax,%esi
c0021b1a:	bf 00 00 00 00       	mov    $0x0,%edi
c0021b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021b22:	ba 00 00 00 00       	mov    $0x0,%edx
c0021b27:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021b2b:	c1 e0 10             	shl    $0x10,%eax
c0021b2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0021b31:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0021b34:	89 f0                	mov    %esi,%eax
c0021b36:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021b39:	89 c1                	mov    %eax,%ecx
c0021b3b:	89 f8                	mov    %edi,%eax
c0021b3d:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0021b40:	89 c3                	mov    %eax,%ebx
c0021b42:	89 c8                	mov    %ecx,%eax
c0021b44:	89 da                	mov    %ebx,%edx
}
c0021b46:	83 c4 14             	add    $0x14,%esp
c0021b49:	5b                   	pop    %ebx
c0021b4a:	5e                   	pop    %esi
c0021b4b:	5f                   	pop    %edi
c0021b4c:	5d                   	pop    %ebp
c0021b4d:	c3                   	ret    

c0021b4e <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021b4e:	55                   	push   %ebp
c0021b4f:	89 e5                	mov    %esp,%ebp
c0021b51:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021b54:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b57:	8b 40 30             	mov    0x30(%eax),%eax
c0021b5a:	83 f8 1f             	cmp    $0x1f,%eax
c0021b5d:	76 12                	jbe    c0021b71 <intr_handler+0x23>
c0021b5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b62:	8b 40 30             	mov    0x30(%eax),%eax
c0021b65:	83 f8 2f             	cmp    $0x2f,%eax
c0021b68:	77 07                	ja     c0021b71 <intr_handler+0x23>
c0021b6a:	b8 01 00 00 00       	mov    $0x1,%eax
c0021b6f:	eb 05                	jmp    c0021b76 <intr_handler+0x28>
c0021b71:	b8 00 00 00 00       	mov    $0x0,%eax
c0021b76:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021b79:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021b7d:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021b81:	74 65                	je     c0021be8 <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021b83:	e8 c6 f9 ff ff       	call   c002154e <intr_get_level>
c0021b88:	85 c0                	test   %eax,%eax
c0021b8a:	74 21                	je     c0021bad <intr_handler+0x5f>
c0021b8c:	83 ec 0c             	sub    $0xc,%esp
c0021b8f:	68 53 01 03 c0       	push   $0xc0030153
c0021b94:	68 49 fe 02 c0       	push   $0xc002fe49
c0021b99:	68 cc 02 03 c0       	push   $0xc00302cc
c0021b9e:	68 65 01 00 00       	push   $0x165
c0021ba3:	68 60 fe 02 c0       	push   $0xc002fe60
c0021ba8:	e8 c1 7b 00 00       	call   c002976e <debug_panic>
      ASSERT (!intr_context ());
c0021bad:	e8 de fc ff ff       	call   c0021890 <intr_context>
c0021bb2:	83 f0 01             	xor    $0x1,%eax
c0021bb5:	84 c0                	test   %al,%al
c0021bb7:	75 21                	jne    c0021bda <intr_handler+0x8c>
c0021bb9:	83 ec 0c             	sub    $0xc,%esp
c0021bbc:	68 38 fe 02 c0       	push   $0xc002fe38
c0021bc1:	68 49 fe 02 c0       	push   $0xc002fe49
c0021bc6:	68 cc 02 03 c0       	push   $0xc00302cc
c0021bcb:	68 66 01 00 00       	push   $0x166
c0021bd0:	68 60 fe 02 c0       	push   $0xc002fe60
c0021bd5:	e8 94 7b 00 00       	call   c002976e <debug_panic>

      in_external_intr = true;
c0021bda:	c6 05 20 9e 03 c0 01 	movb   $0x1,0xc0039e20
      yield_on_return = false;
c0021be1:	c6 05 21 9e 03 c0 00 	movb   $0x0,0xc0039e21
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021be8:	8b 45 08             	mov    0x8(%ebp),%eax
c0021beb:	8b 40 30             	mov    0x30(%eax),%eax
c0021bee:	8b 04 85 20 92 03 c0 	mov    -0x3ffc6de0(,%eax,4),%eax
c0021bf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c0021bf8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0021bfc:	74 10                	je     c0021c0e <intr_handler+0xc0>
    handler (frame);
c0021bfe:	83 ec 0c             	sub    $0xc,%esp
c0021c01:	ff 75 08             	pushl  0x8(%ebp)
c0021c04:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021c07:	ff d0                	call   *%eax
c0021c09:	83 c4 10             	add    $0x10,%esp
c0021c0c:	eb 24                	jmp    c0021c32 <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021c0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c11:	8b 40 30             	mov    0x30(%eax),%eax
c0021c14:	83 f8 27             	cmp    $0x27,%eax
c0021c17:	74 19                	je     c0021c32 <intr_handler+0xe4>
c0021c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c1c:	8b 40 30             	mov    0x30(%eax),%eax
c0021c1f:	83 f8 2f             	cmp    $0x2f,%eax
c0021c22:	74 0e                	je     c0021c32 <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c0021c24:	83 ec 0c             	sub    $0xc,%esp
c0021c27:	ff 75 08             	pushl  0x8(%ebp)
c0021c2a:	e8 87 00 00 00       	call   c0021cb6 <unexpected_interrupt>
c0021c2f:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021c32:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021c36:	74 7b                	je     c0021cb3 <intr_handler+0x165>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021c38:	e8 11 f9 ff ff       	call   c002154e <intr_get_level>
c0021c3d:	85 c0                	test   %eax,%eax
c0021c3f:	74 21                	je     c0021c62 <intr_handler+0x114>
c0021c41:	83 ec 0c             	sub    $0xc,%esp
c0021c44:	68 53 01 03 c0       	push   $0xc0030153
c0021c49:	68 49 fe 02 c0       	push   $0xc002fe49
c0021c4e:	68 cc 02 03 c0       	push   $0xc00302cc
c0021c53:	68 7c 01 00 00       	push   $0x17c
c0021c58:	68 60 fe 02 c0       	push   $0xc002fe60
c0021c5d:	e8 0c 7b 00 00       	call   c002976e <debug_panic>
      ASSERT (intr_context ());
c0021c62:	e8 29 fc ff ff       	call   c0021890 <intr_context>
c0021c67:	84 c0                	test   %al,%al
c0021c69:	75 21                	jne    c0021c8c <intr_handler+0x13e>
c0021c6b:	83 ec 0c             	sub    $0xc,%esp
c0021c6e:	68 eb 00 03 c0       	push   $0xc00300eb
c0021c73:	68 49 fe 02 c0       	push   $0xc002fe49
c0021c78:	68 cc 02 03 c0       	push   $0xc00302cc
c0021c7d:	68 7d 01 00 00       	push   $0x17d
c0021c82:	68 60 fe 02 c0       	push   $0xc002fe60
c0021c87:	e8 e2 7a 00 00       	call   c002976e <debug_panic>

      in_external_intr = false;
c0021c8c:	c6 05 20 9e 03 c0 00 	movb   $0x0,0xc0039e20
      pic_end_of_interrupt (frame->vec_no); 
c0021c93:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c96:	8b 40 30             	mov    0x30(%eax),%eax
c0021c99:	83 ec 0c             	sub    $0xc,%esp
c0021c9c:	50                   	push   %eax
c0021c9d:	e8 e0 fc ff ff       	call   c0021982 <pic_end_of_interrupt>
c0021ca2:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0021ca5:	a0 21 9e 03 c0       	mov    0xc0039e21,%al
c0021caa:	84 c0                	test   %al,%al
c0021cac:	74 05                	je     c0021cb3 <intr_handler+0x165>
        thread_yield (); 
c0021cae:	e8 a8 f2 ff ff       	call   c0020f5b <thread_yield>
    }
}
c0021cb3:	90                   	nop
c0021cb4:	c9                   	leave  
c0021cb5:	c3                   	ret    

c0021cb6 <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0021cb6:	55                   	push   %ebp
c0021cb7:	89 e5                	mov    %esp,%ebp
c0021cb9:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021cbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cbf:	8b 40 30             	mov    0x30(%eax),%eax
c0021cc2:	8b 14 85 20 9a 03 c0 	mov    -0x3ffc65e0(,%eax,4),%edx
c0021cc9:	42                   	inc    %edx
c0021cca:	89 14 85 20 9a 03 c0 	mov    %edx,-0x3ffc65e0(,%eax,4)
c0021cd1:	8b 04 85 20 9a 03 c0 	mov    -0x3ffc65e0(,%eax,4),%eax
c0021cd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021cdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021cde:	48                   	dec    %eax
c0021cdf:	23 45 f4             	and    -0xc(%ebp),%eax
c0021ce2:	85 c0                	test   %eax,%eax
c0021ce4:	75 25                	jne    c0021d0b <unexpected_interrupt+0x55>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0021ce6:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ce9:	8b 40 30             	mov    0x30(%eax),%eax
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021cec:	8b 14 85 20 96 03 c0 	mov    -0x3ffc69e0(,%eax,4),%edx
c0021cf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cf6:	8b 40 30             	mov    0x30(%eax),%eax
c0021cf9:	83 ec 04             	sub    $0x4,%esp
c0021cfc:	52                   	push   %edx
c0021cfd:	50                   	push   %eax
c0021cfe:	68 74 01 03 c0       	push   $0xc0030174
c0021d03:	e8 a7 56 00 00       	call   c00273af <printf>
c0021d08:	83 c4 10             	add    $0x10,%esp
}
c0021d0b:	90                   	nop
c0021d0c:	c9                   	leave  
c0021d0d:	c3                   	ret    

c0021d0e <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021d0e:	55                   	push   %ebp
c0021d0f:	89 e5                	mov    %esp,%ebp
c0021d11:	53                   	push   %ebx
c0021d12:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021d15:	0f 20 d0             	mov    %cr2,%eax
c0021d18:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021d1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d1e:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021d21:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d24:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021d27:	8b 14 85 20 96 03 c0 	mov    -0x3ffc69e0(,%eax,4),%edx
c0021d2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d31:	8b 40 30             	mov    0x30(%eax),%eax
c0021d34:	51                   	push   %ecx
c0021d35:	52                   	push   %edx
c0021d36:	50                   	push   %eax
c0021d37:	68 98 01 03 c0       	push   $0xc0030198
c0021d3c:	e8 6e 56 00 00       	call   c00273af <printf>
c0021d41:	83 c4 10             	add    $0x10,%esp
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021d44:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d47:	8b 40 34             	mov    0x34(%eax),%eax
c0021d4a:	83 ec 04             	sub    $0x4,%esp
c0021d4d:	50                   	push   %eax
c0021d4e:	ff 75 f4             	pushl  -0xc(%ebp)
c0021d51:	68 b8 01 03 c0       	push   $0xc00301b8
c0021d56:	e8 54 56 00 00       	call   c00273af <printf>
c0021d5b:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021d5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d61:	8b 58 14             	mov    0x14(%eax),%ebx
c0021d64:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d67:	8b 48 18             	mov    0x18(%eax),%ecx
c0021d6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d6d:	8b 50 10             	mov    0x10(%eax),%edx
c0021d70:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d73:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021d76:	83 ec 0c             	sub    $0xc,%esp
c0021d79:	53                   	push   %ebx
c0021d7a:	51                   	push   %ecx
c0021d7b:	52                   	push   %edx
c0021d7c:	50                   	push   %eax
c0021d7d:	68 d0 01 03 c0       	push   $0xc00301d0
c0021d82:	e8 28 56 00 00       	call   c00273af <printf>
c0021d87:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021d8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d8d:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0021d90:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d93:	8b 40 48             	mov    0x48(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021d96:	89 c3                	mov    %eax,%ebx
c0021d98:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d9b:	8b 10                	mov    (%eax),%edx
c0021d9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021da0:	8b 40 04             	mov    0x4(%eax),%eax
c0021da3:	83 ec 0c             	sub    $0xc,%esp
c0021da6:	51                   	push   %ecx
c0021da7:	53                   	push   %ebx
c0021da8:	52                   	push   %edx
c0021da9:	50                   	push   %eax
c0021daa:	68 f8 01 03 c0       	push   $0xc00301f8
c0021daf:	e8 fb 55 00 00       	call   c00273af <printf>
c0021db4:	83 c4 20             	add    $0x20,%esp
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0021db7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021dba:	8b 40 4c             	mov    0x4c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021dbd:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0021dc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0021dc3:	8b 40 28             	mov    0x28(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021dc6:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0021dc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0021dcc:	8b 40 2c             	mov    0x2c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021dcf:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c0021dd2:	8b 45 08             	mov    0x8(%ebp),%eax
c0021dd5:	8b 40 40             	mov    0x40(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021dd8:	0f b7 c0             	movzwl %ax,%eax
c0021ddb:	83 ec 0c             	sub    $0xc,%esp
c0021dde:	53                   	push   %ebx
c0021ddf:	51                   	push   %ecx
c0021de0:	52                   	push   %edx
c0021de1:	50                   	push   %eax
c0021de2:	68 20 02 03 c0       	push   $0xc0030220
c0021de7:	e8 c3 55 00 00       	call   c00273af <printf>
c0021dec:	83 c4 20             	add    $0x20,%esp
}
c0021def:	90                   	nop
c0021df0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021df3:	c9                   	leave  
c0021df4:	c3                   	ret    

c0021df5 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0021df5:	55                   	push   %ebp
c0021df6:	89 e5                	mov    %esp,%ebp
c0021df8:	83 ec 04             	sub    $0x4,%esp
c0021dfb:	8b 45 08             	mov    0x8(%ebp),%eax
c0021dfe:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c0021e01:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0021e05:	8b 04 85 20 96 03 c0 	mov    -0x3ffc69e0(,%eax,4),%eax
}
c0021e0c:	c9                   	leave  
c0021e0d:	c3                   	ret    

c0021e0e <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021e0e:	1e                   	push   %ds
	pushl %es
c0021e0f:	06                   	push   %es
	pushl %fs
c0021e10:	0f a0                	push   %fs
	pushl %gs
c0021e12:	0f a8                	push   %gs
	pushal
c0021e14:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021e15:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021e16:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021e1b:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021e1d:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021e1f:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021e23:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021e24:	e8 25 fd ff ff       	call   c0021b4e <intr_handler>
	addl $4, %esp
c0021e29:	83 c4 04             	add    $0x4,%esp

c0021e2c <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021e2c:	61                   	popa   
	popl %gs
c0021e2d:	0f a9                	pop    %gs
	popl %fs
c0021e2f:	0f a1                	pop    %fs
	popl %es
c0021e31:	07                   	pop    %es
	popl %ds
c0021e32:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021e33:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021e36:	cf                   	iret   

c0021e37 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021e37:	55                   	push   %ebp
c0021e38:	6a 00                	push   $0x0
c0021e3a:	6a 00                	push   $0x0
c0021e3c:	eb d0                	jmp    c0021e0e <intr_entry>

c0021e3e <intr01_stub>:
c0021e3e:	55                   	push   %ebp
c0021e3f:	6a 00                	push   $0x0
c0021e41:	6a 01                	push   $0x1
c0021e43:	eb c9                	jmp    c0021e0e <intr_entry>

c0021e45 <intr02_stub>:
c0021e45:	55                   	push   %ebp
c0021e46:	6a 00                	push   $0x0
c0021e48:	6a 02                	push   $0x2
c0021e4a:	eb c2                	jmp    c0021e0e <intr_entry>

c0021e4c <intr03_stub>:
c0021e4c:	55                   	push   %ebp
c0021e4d:	6a 00                	push   $0x0
c0021e4f:	6a 03                	push   $0x3
c0021e51:	eb bb                	jmp    c0021e0e <intr_entry>

c0021e53 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021e53:	55                   	push   %ebp
c0021e54:	6a 00                	push   $0x0
c0021e56:	6a 04                	push   $0x4
c0021e58:	eb b4                	jmp    c0021e0e <intr_entry>

c0021e5a <intr05_stub>:
c0021e5a:	55                   	push   %ebp
c0021e5b:	6a 00                	push   $0x0
c0021e5d:	6a 05                	push   $0x5
c0021e5f:	eb ad                	jmp    c0021e0e <intr_entry>

c0021e61 <intr06_stub>:
c0021e61:	55                   	push   %ebp
c0021e62:	6a 00                	push   $0x0
c0021e64:	6a 06                	push   $0x6
c0021e66:	eb a6                	jmp    c0021e0e <intr_entry>

c0021e68 <intr07_stub>:
c0021e68:	55                   	push   %ebp
c0021e69:	6a 00                	push   $0x0
c0021e6b:	6a 07                	push   $0x7
c0021e6d:	eb 9f                	jmp    c0021e0e <intr_entry>

c0021e6f <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021e6f:	ff 34 24             	pushl  (%esp)
c0021e72:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e76:	6a 08                	push   $0x8
c0021e78:	eb 94                	jmp    c0021e0e <intr_entry>

c0021e7a <intr09_stub>:
c0021e7a:	55                   	push   %ebp
c0021e7b:	6a 00                	push   $0x0
c0021e7d:	6a 09                	push   $0x9
c0021e7f:	eb 8d                	jmp    c0021e0e <intr_entry>

c0021e81 <intr0a_stub>:
c0021e81:	ff 34 24             	pushl  (%esp)
c0021e84:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e88:	6a 0a                	push   $0xa
c0021e8a:	eb 82                	jmp    c0021e0e <intr_entry>

c0021e8c <intr0b_stub>:
c0021e8c:	ff 34 24             	pushl  (%esp)
c0021e8f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e93:	6a 0b                	push   $0xb
c0021e95:	e9 74 ff ff ff       	jmp    c0021e0e <intr_entry>

c0021e9a <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021e9a:	55                   	push   %ebp
c0021e9b:	6a 00                	push   $0x0
c0021e9d:	6a 0c                	push   $0xc
c0021e9f:	e9 6a ff ff ff       	jmp    c0021e0e <intr_entry>

c0021ea4 <intr0d_stub>:
c0021ea4:	ff 34 24             	pushl  (%esp)
c0021ea7:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021eab:	6a 0d                	push   $0xd
c0021ead:	e9 5c ff ff ff       	jmp    c0021e0e <intr_entry>

c0021eb2 <intr0e_stub>:
c0021eb2:	ff 34 24             	pushl  (%esp)
c0021eb5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021eb9:	6a 0e                	push   $0xe
c0021ebb:	e9 4e ff ff ff       	jmp    c0021e0e <intr_entry>

c0021ec0 <intr0f_stub>:
c0021ec0:	55                   	push   %ebp
c0021ec1:	6a 00                	push   $0x0
c0021ec3:	6a 0f                	push   $0xf
c0021ec5:	e9 44 ff ff ff       	jmp    c0021e0e <intr_entry>

c0021eca <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021eca:	55                   	push   %ebp
c0021ecb:	6a 00                	push   $0x0
c0021ecd:	6a 10                	push   $0x10
c0021ecf:	e9 3a ff ff ff       	jmp    c0021e0e <intr_entry>

c0021ed4 <intr11_stub>:
c0021ed4:	ff 34 24             	pushl  (%esp)
c0021ed7:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021edb:	6a 11                	push   $0x11
c0021edd:	e9 2c ff ff ff       	jmp    c0021e0e <intr_entry>

c0021ee2 <intr12_stub>:
c0021ee2:	55                   	push   %ebp
c0021ee3:	6a 00                	push   $0x0
c0021ee5:	6a 12                	push   $0x12
c0021ee7:	e9 22 ff ff ff       	jmp    c0021e0e <intr_entry>

c0021eec <intr13_stub>:
c0021eec:	55                   	push   %ebp
c0021eed:	6a 00                	push   $0x0
c0021eef:	6a 13                	push   $0x13
c0021ef1:	e9 18 ff ff ff       	jmp    c0021e0e <intr_entry>

c0021ef6 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021ef6:	55                   	push   %ebp
c0021ef7:	6a 00                	push   $0x0
c0021ef9:	6a 14                	push   $0x14
c0021efb:	e9 0e ff ff ff       	jmp    c0021e0e <intr_entry>

c0021f00 <intr15_stub>:
c0021f00:	55                   	push   %ebp
c0021f01:	6a 00                	push   $0x0
c0021f03:	6a 15                	push   $0x15
c0021f05:	e9 04 ff ff ff       	jmp    c0021e0e <intr_entry>

c0021f0a <intr16_stub>:
c0021f0a:	55                   	push   %ebp
c0021f0b:	6a 00                	push   $0x0
c0021f0d:	6a 16                	push   $0x16
c0021f0f:	e9 fa fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f14 <intr17_stub>:
c0021f14:	55                   	push   %ebp
c0021f15:	6a 00                	push   $0x0
c0021f17:	6a 17                	push   $0x17
c0021f19:	e9 f0 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f1e <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021f1e:	ff 34 24             	pushl  (%esp)
c0021f21:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f25:	6a 18                	push   $0x18
c0021f27:	e9 e2 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f2c <intr19_stub>:
c0021f2c:	55                   	push   %ebp
c0021f2d:	6a 00                	push   $0x0
c0021f2f:	6a 19                	push   $0x19
c0021f31:	e9 d8 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f36 <intr1a_stub>:
c0021f36:	ff 34 24             	pushl  (%esp)
c0021f39:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f3d:	6a 1a                	push   $0x1a
c0021f3f:	e9 ca fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f44 <intr1b_stub>:
c0021f44:	ff 34 24             	pushl  (%esp)
c0021f47:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f4b:	6a 1b                	push   $0x1b
c0021f4d:	e9 bc fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f52 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021f52:	55                   	push   %ebp
c0021f53:	6a 00                	push   $0x0
c0021f55:	6a 1c                	push   $0x1c
c0021f57:	e9 b2 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f5c <intr1d_stub>:
c0021f5c:	ff 34 24             	pushl  (%esp)
c0021f5f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f63:	6a 1d                	push   $0x1d
c0021f65:	e9 a4 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f6a <intr1e_stub>:
c0021f6a:	ff 34 24             	pushl  (%esp)
c0021f6d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021f71:	6a 1e                	push   $0x1e
c0021f73:	e9 96 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f78 <intr1f_stub>:
c0021f78:	55                   	push   %ebp
c0021f79:	6a 00                	push   $0x0
c0021f7b:	6a 1f                	push   $0x1f
c0021f7d:	e9 8c fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f82 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021f82:	55                   	push   %ebp
c0021f83:	6a 00                	push   $0x0
c0021f85:	6a 20                	push   $0x20
c0021f87:	e9 82 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f8c <intr21_stub>:
c0021f8c:	55                   	push   %ebp
c0021f8d:	6a 00                	push   $0x0
c0021f8f:	6a 21                	push   $0x21
c0021f91:	e9 78 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021f96 <intr22_stub>:
c0021f96:	55                   	push   %ebp
c0021f97:	6a 00                	push   $0x0
c0021f99:	6a 22                	push   $0x22
c0021f9b:	e9 6e fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fa0 <intr23_stub>:
c0021fa0:	55                   	push   %ebp
c0021fa1:	6a 00                	push   $0x0
c0021fa3:	6a 23                	push   $0x23
c0021fa5:	e9 64 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021faa <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021faa:	55                   	push   %ebp
c0021fab:	6a 00                	push   $0x0
c0021fad:	6a 24                	push   $0x24
c0021faf:	e9 5a fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fb4 <intr25_stub>:
c0021fb4:	55                   	push   %ebp
c0021fb5:	6a 00                	push   $0x0
c0021fb7:	6a 25                	push   $0x25
c0021fb9:	e9 50 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fbe <intr26_stub>:
c0021fbe:	55                   	push   %ebp
c0021fbf:	6a 00                	push   $0x0
c0021fc1:	6a 26                	push   $0x26
c0021fc3:	e9 46 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fc8 <intr27_stub>:
c0021fc8:	55                   	push   %ebp
c0021fc9:	6a 00                	push   $0x0
c0021fcb:	6a 27                	push   $0x27
c0021fcd:	e9 3c fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fd2 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021fd2:	55                   	push   %ebp
c0021fd3:	6a 00                	push   $0x0
c0021fd5:	6a 28                	push   $0x28
c0021fd7:	e9 32 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fdc <intr29_stub>:
c0021fdc:	55                   	push   %ebp
c0021fdd:	6a 00                	push   $0x0
c0021fdf:	6a 29                	push   $0x29
c0021fe1:	e9 28 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021fe6 <intr2a_stub>:
c0021fe6:	55                   	push   %ebp
c0021fe7:	6a 00                	push   $0x0
c0021fe9:	6a 2a                	push   $0x2a
c0021feb:	e9 1e fe ff ff       	jmp    c0021e0e <intr_entry>

c0021ff0 <intr2b_stub>:
c0021ff0:	55                   	push   %ebp
c0021ff1:	6a 00                	push   $0x0
c0021ff3:	6a 2b                	push   $0x2b
c0021ff5:	e9 14 fe ff ff       	jmp    c0021e0e <intr_entry>

c0021ffa <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021ffa:	55                   	push   %ebp
c0021ffb:	6a 00                	push   $0x0
c0021ffd:	6a 2c                	push   $0x2c
c0021fff:	e9 0a fe ff ff       	jmp    c0021e0e <intr_entry>

c0022004 <intr2d_stub>:
c0022004:	55                   	push   %ebp
c0022005:	6a 00                	push   $0x0
c0022007:	6a 2d                	push   $0x2d
c0022009:	e9 00 fe ff ff       	jmp    c0021e0e <intr_entry>

c002200e <intr2e_stub>:
c002200e:	55                   	push   %ebp
c002200f:	6a 00                	push   $0x0
c0022011:	6a 2e                	push   $0x2e
c0022013:	e9 f6 fd ff ff       	jmp    c0021e0e <intr_entry>

c0022018 <intr2f_stub>:
c0022018:	55                   	push   %ebp
c0022019:	6a 00                	push   $0x0
c002201b:	6a 2f                	push   $0x2f
c002201d:	e9 ec fd ff ff       	jmp    c0021e0e <intr_entry>

c0022022 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0022022:	55                   	push   %ebp
c0022023:	6a 00                	push   $0x0
c0022025:	6a 30                	push   $0x30
c0022027:	e9 e2 fd ff ff       	jmp    c0021e0e <intr_entry>

c002202c <intr31_stub>:
c002202c:	55                   	push   %ebp
c002202d:	6a 00                	push   $0x0
c002202f:	6a 31                	push   $0x31
c0022031:	e9 d8 fd ff ff       	jmp    c0021e0e <intr_entry>

c0022036 <intr32_stub>:
c0022036:	55                   	push   %ebp
c0022037:	6a 00                	push   $0x0
c0022039:	6a 32                	push   $0x32
c002203b:	e9 ce fd ff ff       	jmp    c0021e0e <intr_entry>

c0022040 <intr33_stub>:
c0022040:	55                   	push   %ebp
c0022041:	6a 00                	push   $0x0
c0022043:	6a 33                	push   $0x33
c0022045:	e9 c4 fd ff ff       	jmp    c0021e0e <intr_entry>

c002204a <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c002204a:	55                   	push   %ebp
c002204b:	6a 00                	push   $0x0
c002204d:	6a 34                	push   $0x34
c002204f:	e9 ba fd ff ff       	jmp    c0021e0e <intr_entry>

c0022054 <intr35_stub>:
c0022054:	55                   	push   %ebp
c0022055:	6a 00                	push   $0x0
c0022057:	6a 35                	push   $0x35
c0022059:	e9 b0 fd ff ff       	jmp    c0021e0e <intr_entry>

c002205e <intr36_stub>:
c002205e:	55                   	push   %ebp
c002205f:	6a 00                	push   $0x0
c0022061:	6a 36                	push   $0x36
c0022063:	e9 a6 fd ff ff       	jmp    c0021e0e <intr_entry>

c0022068 <intr37_stub>:
c0022068:	55                   	push   %ebp
c0022069:	6a 00                	push   $0x0
c002206b:	6a 37                	push   $0x37
c002206d:	e9 9c fd ff ff       	jmp    c0021e0e <intr_entry>

c0022072 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0022072:	55                   	push   %ebp
c0022073:	6a 00                	push   $0x0
c0022075:	6a 38                	push   $0x38
c0022077:	e9 92 fd ff ff       	jmp    c0021e0e <intr_entry>

c002207c <intr39_stub>:
c002207c:	55                   	push   %ebp
c002207d:	6a 00                	push   $0x0
c002207f:	6a 39                	push   $0x39
c0022081:	e9 88 fd ff ff       	jmp    c0021e0e <intr_entry>

c0022086 <intr3a_stub>:
c0022086:	55                   	push   %ebp
c0022087:	6a 00                	push   $0x0
c0022089:	6a 3a                	push   $0x3a
c002208b:	e9 7e fd ff ff       	jmp    c0021e0e <intr_entry>

c0022090 <intr3b_stub>:
c0022090:	55                   	push   %ebp
c0022091:	6a 00                	push   $0x0
c0022093:	6a 3b                	push   $0x3b
c0022095:	e9 74 fd ff ff       	jmp    c0021e0e <intr_entry>

c002209a <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c002209a:	55                   	push   %ebp
c002209b:	6a 00                	push   $0x0
c002209d:	6a 3c                	push   $0x3c
c002209f:	e9 6a fd ff ff       	jmp    c0021e0e <intr_entry>

c00220a4 <intr3d_stub>:
c00220a4:	55                   	push   %ebp
c00220a5:	6a 00                	push   $0x0
c00220a7:	6a 3d                	push   $0x3d
c00220a9:	e9 60 fd ff ff       	jmp    c0021e0e <intr_entry>

c00220ae <intr3e_stub>:
c00220ae:	55                   	push   %ebp
c00220af:	6a 00                	push   $0x0
c00220b1:	6a 3e                	push   $0x3e
c00220b3:	e9 56 fd ff ff       	jmp    c0021e0e <intr_entry>

c00220b8 <intr3f_stub>:
c00220b8:	55                   	push   %ebp
c00220b9:	6a 00                	push   $0x0
c00220bb:	6a 3f                	push   $0x3f
c00220bd:	e9 4c fd ff ff       	jmp    c0021e0e <intr_entry>

c00220c2 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c00220c2:	55                   	push   %ebp
c00220c3:	6a 00                	push   $0x0
c00220c5:	6a 40                	push   $0x40
c00220c7:	e9 42 fd ff ff       	jmp    c0021e0e <intr_entry>

c00220cc <intr41_stub>:
c00220cc:	55                   	push   %ebp
c00220cd:	6a 00                	push   $0x0
c00220cf:	6a 41                	push   $0x41
c00220d1:	e9 38 fd ff ff       	jmp    c0021e0e <intr_entry>

c00220d6 <intr42_stub>:
c00220d6:	55                   	push   %ebp
c00220d7:	6a 00                	push   $0x0
c00220d9:	6a 42                	push   $0x42
c00220db:	e9 2e fd ff ff       	jmp    c0021e0e <intr_entry>

c00220e0 <intr43_stub>:
c00220e0:	55                   	push   %ebp
c00220e1:	6a 00                	push   $0x0
c00220e3:	6a 43                	push   $0x43
c00220e5:	e9 24 fd ff ff       	jmp    c0021e0e <intr_entry>

c00220ea <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c00220ea:	55                   	push   %ebp
c00220eb:	6a 00                	push   $0x0
c00220ed:	6a 44                	push   $0x44
c00220ef:	e9 1a fd ff ff       	jmp    c0021e0e <intr_entry>

c00220f4 <intr45_stub>:
c00220f4:	55                   	push   %ebp
c00220f5:	6a 00                	push   $0x0
c00220f7:	6a 45                	push   $0x45
c00220f9:	e9 10 fd ff ff       	jmp    c0021e0e <intr_entry>

c00220fe <intr46_stub>:
c00220fe:	55                   	push   %ebp
c00220ff:	6a 00                	push   $0x0
c0022101:	6a 46                	push   $0x46
c0022103:	e9 06 fd ff ff       	jmp    c0021e0e <intr_entry>

c0022108 <intr47_stub>:
c0022108:	55                   	push   %ebp
c0022109:	6a 00                	push   $0x0
c002210b:	6a 47                	push   $0x47
c002210d:	e9 fc fc ff ff       	jmp    c0021e0e <intr_entry>

c0022112 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0022112:	55                   	push   %ebp
c0022113:	6a 00                	push   $0x0
c0022115:	6a 48                	push   $0x48
c0022117:	e9 f2 fc ff ff       	jmp    c0021e0e <intr_entry>

c002211c <intr49_stub>:
c002211c:	55                   	push   %ebp
c002211d:	6a 00                	push   $0x0
c002211f:	6a 49                	push   $0x49
c0022121:	e9 e8 fc ff ff       	jmp    c0021e0e <intr_entry>

c0022126 <intr4a_stub>:
c0022126:	55                   	push   %ebp
c0022127:	6a 00                	push   $0x0
c0022129:	6a 4a                	push   $0x4a
c002212b:	e9 de fc ff ff       	jmp    c0021e0e <intr_entry>

c0022130 <intr4b_stub>:
c0022130:	55                   	push   %ebp
c0022131:	6a 00                	push   $0x0
c0022133:	6a 4b                	push   $0x4b
c0022135:	e9 d4 fc ff ff       	jmp    c0021e0e <intr_entry>

c002213a <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c002213a:	55                   	push   %ebp
c002213b:	6a 00                	push   $0x0
c002213d:	6a 4c                	push   $0x4c
c002213f:	e9 ca fc ff ff       	jmp    c0021e0e <intr_entry>

c0022144 <intr4d_stub>:
c0022144:	55                   	push   %ebp
c0022145:	6a 00                	push   $0x0
c0022147:	6a 4d                	push   $0x4d
c0022149:	e9 c0 fc ff ff       	jmp    c0021e0e <intr_entry>

c002214e <intr4e_stub>:
c002214e:	55                   	push   %ebp
c002214f:	6a 00                	push   $0x0
c0022151:	6a 4e                	push   $0x4e
c0022153:	e9 b6 fc ff ff       	jmp    c0021e0e <intr_entry>

c0022158 <intr4f_stub>:
c0022158:	55                   	push   %ebp
c0022159:	6a 00                	push   $0x0
c002215b:	6a 4f                	push   $0x4f
c002215d:	e9 ac fc ff ff       	jmp    c0021e0e <intr_entry>

c0022162 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022162:	55                   	push   %ebp
c0022163:	6a 00                	push   $0x0
c0022165:	6a 50                	push   $0x50
c0022167:	e9 a2 fc ff ff       	jmp    c0021e0e <intr_entry>

c002216c <intr51_stub>:
c002216c:	55                   	push   %ebp
c002216d:	6a 00                	push   $0x0
c002216f:	6a 51                	push   $0x51
c0022171:	e9 98 fc ff ff       	jmp    c0021e0e <intr_entry>

c0022176 <intr52_stub>:
c0022176:	55                   	push   %ebp
c0022177:	6a 00                	push   $0x0
c0022179:	6a 52                	push   $0x52
c002217b:	e9 8e fc ff ff       	jmp    c0021e0e <intr_entry>

c0022180 <intr53_stub>:
c0022180:	55                   	push   %ebp
c0022181:	6a 00                	push   $0x0
c0022183:	6a 53                	push   $0x53
c0022185:	e9 84 fc ff ff       	jmp    c0021e0e <intr_entry>

c002218a <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c002218a:	55                   	push   %ebp
c002218b:	6a 00                	push   $0x0
c002218d:	6a 54                	push   $0x54
c002218f:	e9 7a fc ff ff       	jmp    c0021e0e <intr_entry>

c0022194 <intr55_stub>:
c0022194:	55                   	push   %ebp
c0022195:	6a 00                	push   $0x0
c0022197:	6a 55                	push   $0x55
c0022199:	e9 70 fc ff ff       	jmp    c0021e0e <intr_entry>

c002219e <intr56_stub>:
c002219e:	55                   	push   %ebp
c002219f:	6a 00                	push   $0x0
c00221a1:	6a 56                	push   $0x56
c00221a3:	e9 66 fc ff ff       	jmp    c0021e0e <intr_entry>

c00221a8 <intr57_stub>:
c00221a8:	55                   	push   %ebp
c00221a9:	6a 00                	push   $0x0
c00221ab:	6a 57                	push   $0x57
c00221ad:	e9 5c fc ff ff       	jmp    c0021e0e <intr_entry>

c00221b2 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c00221b2:	55                   	push   %ebp
c00221b3:	6a 00                	push   $0x0
c00221b5:	6a 58                	push   $0x58
c00221b7:	e9 52 fc ff ff       	jmp    c0021e0e <intr_entry>

c00221bc <intr59_stub>:
c00221bc:	55                   	push   %ebp
c00221bd:	6a 00                	push   $0x0
c00221bf:	6a 59                	push   $0x59
c00221c1:	e9 48 fc ff ff       	jmp    c0021e0e <intr_entry>

c00221c6 <intr5a_stub>:
c00221c6:	55                   	push   %ebp
c00221c7:	6a 00                	push   $0x0
c00221c9:	6a 5a                	push   $0x5a
c00221cb:	e9 3e fc ff ff       	jmp    c0021e0e <intr_entry>

c00221d0 <intr5b_stub>:
c00221d0:	55                   	push   %ebp
c00221d1:	6a 00                	push   $0x0
c00221d3:	6a 5b                	push   $0x5b
c00221d5:	e9 34 fc ff ff       	jmp    c0021e0e <intr_entry>

c00221da <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c00221da:	55                   	push   %ebp
c00221db:	6a 00                	push   $0x0
c00221dd:	6a 5c                	push   $0x5c
c00221df:	e9 2a fc ff ff       	jmp    c0021e0e <intr_entry>

c00221e4 <intr5d_stub>:
c00221e4:	55                   	push   %ebp
c00221e5:	6a 00                	push   $0x0
c00221e7:	6a 5d                	push   $0x5d
c00221e9:	e9 20 fc ff ff       	jmp    c0021e0e <intr_entry>

c00221ee <intr5e_stub>:
c00221ee:	55                   	push   %ebp
c00221ef:	6a 00                	push   $0x0
c00221f1:	6a 5e                	push   $0x5e
c00221f3:	e9 16 fc ff ff       	jmp    c0021e0e <intr_entry>

c00221f8 <intr5f_stub>:
c00221f8:	55                   	push   %ebp
c00221f9:	6a 00                	push   $0x0
c00221fb:	6a 5f                	push   $0x5f
c00221fd:	e9 0c fc ff ff       	jmp    c0021e0e <intr_entry>

c0022202 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0022202:	55                   	push   %ebp
c0022203:	6a 00                	push   $0x0
c0022205:	6a 60                	push   $0x60
c0022207:	e9 02 fc ff ff       	jmp    c0021e0e <intr_entry>

c002220c <intr61_stub>:
c002220c:	55                   	push   %ebp
c002220d:	6a 00                	push   $0x0
c002220f:	6a 61                	push   $0x61
c0022211:	e9 f8 fb ff ff       	jmp    c0021e0e <intr_entry>

c0022216 <intr62_stub>:
c0022216:	55                   	push   %ebp
c0022217:	6a 00                	push   $0x0
c0022219:	6a 62                	push   $0x62
c002221b:	e9 ee fb ff ff       	jmp    c0021e0e <intr_entry>

c0022220 <intr63_stub>:
c0022220:	55                   	push   %ebp
c0022221:	6a 00                	push   $0x0
c0022223:	6a 63                	push   $0x63
c0022225:	e9 e4 fb ff ff       	jmp    c0021e0e <intr_entry>

c002222a <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c002222a:	55                   	push   %ebp
c002222b:	6a 00                	push   $0x0
c002222d:	6a 64                	push   $0x64
c002222f:	e9 da fb ff ff       	jmp    c0021e0e <intr_entry>

c0022234 <intr65_stub>:
c0022234:	55                   	push   %ebp
c0022235:	6a 00                	push   $0x0
c0022237:	6a 65                	push   $0x65
c0022239:	e9 d0 fb ff ff       	jmp    c0021e0e <intr_entry>

c002223e <intr66_stub>:
c002223e:	55                   	push   %ebp
c002223f:	6a 00                	push   $0x0
c0022241:	6a 66                	push   $0x66
c0022243:	e9 c6 fb ff ff       	jmp    c0021e0e <intr_entry>

c0022248 <intr67_stub>:
c0022248:	55                   	push   %ebp
c0022249:	6a 00                	push   $0x0
c002224b:	6a 67                	push   $0x67
c002224d:	e9 bc fb ff ff       	jmp    c0021e0e <intr_entry>

c0022252 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0022252:	55                   	push   %ebp
c0022253:	6a 00                	push   $0x0
c0022255:	6a 68                	push   $0x68
c0022257:	e9 b2 fb ff ff       	jmp    c0021e0e <intr_entry>

c002225c <intr69_stub>:
c002225c:	55                   	push   %ebp
c002225d:	6a 00                	push   $0x0
c002225f:	6a 69                	push   $0x69
c0022261:	e9 a8 fb ff ff       	jmp    c0021e0e <intr_entry>

c0022266 <intr6a_stub>:
c0022266:	55                   	push   %ebp
c0022267:	6a 00                	push   $0x0
c0022269:	6a 6a                	push   $0x6a
c002226b:	e9 9e fb ff ff       	jmp    c0021e0e <intr_entry>

c0022270 <intr6b_stub>:
c0022270:	55                   	push   %ebp
c0022271:	6a 00                	push   $0x0
c0022273:	6a 6b                	push   $0x6b
c0022275:	e9 94 fb ff ff       	jmp    c0021e0e <intr_entry>

c002227a <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c002227a:	55                   	push   %ebp
c002227b:	6a 00                	push   $0x0
c002227d:	6a 6c                	push   $0x6c
c002227f:	e9 8a fb ff ff       	jmp    c0021e0e <intr_entry>

c0022284 <intr6d_stub>:
c0022284:	55                   	push   %ebp
c0022285:	6a 00                	push   $0x0
c0022287:	6a 6d                	push   $0x6d
c0022289:	e9 80 fb ff ff       	jmp    c0021e0e <intr_entry>

c002228e <intr6e_stub>:
c002228e:	55                   	push   %ebp
c002228f:	6a 00                	push   $0x0
c0022291:	6a 6e                	push   $0x6e
c0022293:	e9 76 fb ff ff       	jmp    c0021e0e <intr_entry>

c0022298 <intr6f_stub>:
c0022298:	55                   	push   %ebp
c0022299:	6a 00                	push   $0x0
c002229b:	6a 6f                	push   $0x6f
c002229d:	e9 6c fb ff ff       	jmp    c0021e0e <intr_entry>

c00222a2 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c00222a2:	55                   	push   %ebp
c00222a3:	6a 00                	push   $0x0
c00222a5:	6a 70                	push   $0x70
c00222a7:	e9 62 fb ff ff       	jmp    c0021e0e <intr_entry>

c00222ac <intr71_stub>:
c00222ac:	55                   	push   %ebp
c00222ad:	6a 00                	push   $0x0
c00222af:	6a 71                	push   $0x71
c00222b1:	e9 58 fb ff ff       	jmp    c0021e0e <intr_entry>

c00222b6 <intr72_stub>:
c00222b6:	55                   	push   %ebp
c00222b7:	6a 00                	push   $0x0
c00222b9:	6a 72                	push   $0x72
c00222bb:	e9 4e fb ff ff       	jmp    c0021e0e <intr_entry>

c00222c0 <intr73_stub>:
c00222c0:	55                   	push   %ebp
c00222c1:	6a 00                	push   $0x0
c00222c3:	6a 73                	push   $0x73
c00222c5:	e9 44 fb ff ff       	jmp    c0021e0e <intr_entry>

c00222ca <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c00222ca:	55                   	push   %ebp
c00222cb:	6a 00                	push   $0x0
c00222cd:	6a 74                	push   $0x74
c00222cf:	e9 3a fb ff ff       	jmp    c0021e0e <intr_entry>

c00222d4 <intr75_stub>:
c00222d4:	55                   	push   %ebp
c00222d5:	6a 00                	push   $0x0
c00222d7:	6a 75                	push   $0x75
c00222d9:	e9 30 fb ff ff       	jmp    c0021e0e <intr_entry>

c00222de <intr76_stub>:
c00222de:	55                   	push   %ebp
c00222df:	6a 00                	push   $0x0
c00222e1:	6a 76                	push   $0x76
c00222e3:	e9 26 fb ff ff       	jmp    c0021e0e <intr_entry>

c00222e8 <intr77_stub>:
c00222e8:	55                   	push   %ebp
c00222e9:	6a 00                	push   $0x0
c00222eb:	6a 77                	push   $0x77
c00222ed:	e9 1c fb ff ff       	jmp    c0021e0e <intr_entry>

c00222f2 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00222f2:	55                   	push   %ebp
c00222f3:	6a 00                	push   $0x0
c00222f5:	6a 78                	push   $0x78
c00222f7:	e9 12 fb ff ff       	jmp    c0021e0e <intr_entry>

c00222fc <intr79_stub>:
c00222fc:	55                   	push   %ebp
c00222fd:	6a 00                	push   $0x0
c00222ff:	6a 79                	push   $0x79
c0022301:	e9 08 fb ff ff       	jmp    c0021e0e <intr_entry>

c0022306 <intr7a_stub>:
c0022306:	55                   	push   %ebp
c0022307:	6a 00                	push   $0x0
c0022309:	6a 7a                	push   $0x7a
c002230b:	e9 fe fa ff ff       	jmp    c0021e0e <intr_entry>

c0022310 <intr7b_stub>:
c0022310:	55                   	push   %ebp
c0022311:	6a 00                	push   $0x0
c0022313:	6a 7b                	push   $0x7b
c0022315:	e9 f4 fa ff ff       	jmp    c0021e0e <intr_entry>

c002231a <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c002231a:	55                   	push   %ebp
c002231b:	6a 00                	push   $0x0
c002231d:	6a 7c                	push   $0x7c
c002231f:	e9 ea fa ff ff       	jmp    c0021e0e <intr_entry>

c0022324 <intr7d_stub>:
c0022324:	55                   	push   %ebp
c0022325:	6a 00                	push   $0x0
c0022327:	6a 7d                	push   $0x7d
c0022329:	e9 e0 fa ff ff       	jmp    c0021e0e <intr_entry>

c002232e <intr7e_stub>:
c002232e:	55                   	push   %ebp
c002232f:	6a 00                	push   $0x0
c0022331:	6a 7e                	push   $0x7e
c0022333:	e9 d6 fa ff ff       	jmp    c0021e0e <intr_entry>

c0022338 <intr7f_stub>:
c0022338:	55                   	push   %ebp
c0022339:	6a 00                	push   $0x0
c002233b:	6a 7f                	push   $0x7f
c002233d:	e9 cc fa ff ff       	jmp    c0021e0e <intr_entry>

c0022342 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022342:	55                   	push   %ebp
c0022343:	6a 00                	push   $0x0
c0022345:	68 80 00 00 00       	push   $0x80
c002234a:	e9 bf fa ff ff       	jmp    c0021e0e <intr_entry>

c002234f <intr81_stub>:
c002234f:	55                   	push   %ebp
c0022350:	6a 00                	push   $0x0
c0022352:	68 81 00 00 00       	push   $0x81
c0022357:	e9 b2 fa ff ff       	jmp    c0021e0e <intr_entry>

c002235c <intr82_stub>:
c002235c:	55                   	push   %ebp
c002235d:	6a 00                	push   $0x0
c002235f:	68 82 00 00 00       	push   $0x82
c0022364:	e9 a5 fa ff ff       	jmp    c0021e0e <intr_entry>

c0022369 <intr83_stub>:
c0022369:	55                   	push   %ebp
c002236a:	6a 00                	push   $0x0
c002236c:	68 83 00 00 00       	push   $0x83
c0022371:	e9 98 fa ff ff       	jmp    c0021e0e <intr_entry>

c0022376 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022376:	55                   	push   %ebp
c0022377:	6a 00                	push   $0x0
c0022379:	68 84 00 00 00       	push   $0x84
c002237e:	e9 8b fa ff ff       	jmp    c0021e0e <intr_entry>

c0022383 <intr85_stub>:
c0022383:	55                   	push   %ebp
c0022384:	6a 00                	push   $0x0
c0022386:	68 85 00 00 00       	push   $0x85
c002238b:	e9 7e fa ff ff       	jmp    c0021e0e <intr_entry>

c0022390 <intr86_stub>:
c0022390:	55                   	push   %ebp
c0022391:	6a 00                	push   $0x0
c0022393:	68 86 00 00 00       	push   $0x86
c0022398:	e9 71 fa ff ff       	jmp    c0021e0e <intr_entry>

c002239d <intr87_stub>:
c002239d:	55                   	push   %ebp
c002239e:	6a 00                	push   $0x0
c00223a0:	68 87 00 00 00       	push   $0x87
c00223a5:	e9 64 fa ff ff       	jmp    c0021e0e <intr_entry>

c00223aa <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c00223aa:	55                   	push   %ebp
c00223ab:	6a 00                	push   $0x0
c00223ad:	68 88 00 00 00       	push   $0x88
c00223b2:	e9 57 fa ff ff       	jmp    c0021e0e <intr_entry>

c00223b7 <intr89_stub>:
c00223b7:	55                   	push   %ebp
c00223b8:	6a 00                	push   $0x0
c00223ba:	68 89 00 00 00       	push   $0x89
c00223bf:	e9 4a fa ff ff       	jmp    c0021e0e <intr_entry>

c00223c4 <intr8a_stub>:
c00223c4:	55                   	push   %ebp
c00223c5:	6a 00                	push   $0x0
c00223c7:	68 8a 00 00 00       	push   $0x8a
c00223cc:	e9 3d fa ff ff       	jmp    c0021e0e <intr_entry>

c00223d1 <intr8b_stub>:
c00223d1:	55                   	push   %ebp
c00223d2:	6a 00                	push   $0x0
c00223d4:	68 8b 00 00 00       	push   $0x8b
c00223d9:	e9 30 fa ff ff       	jmp    c0021e0e <intr_entry>

c00223de <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00223de:	55                   	push   %ebp
c00223df:	6a 00                	push   $0x0
c00223e1:	68 8c 00 00 00       	push   $0x8c
c00223e6:	e9 23 fa ff ff       	jmp    c0021e0e <intr_entry>

c00223eb <intr8d_stub>:
c00223eb:	55                   	push   %ebp
c00223ec:	6a 00                	push   $0x0
c00223ee:	68 8d 00 00 00       	push   $0x8d
c00223f3:	e9 16 fa ff ff       	jmp    c0021e0e <intr_entry>

c00223f8 <intr8e_stub>:
c00223f8:	55                   	push   %ebp
c00223f9:	6a 00                	push   $0x0
c00223fb:	68 8e 00 00 00       	push   $0x8e
c0022400:	e9 09 fa ff ff       	jmp    c0021e0e <intr_entry>

c0022405 <intr8f_stub>:
c0022405:	55                   	push   %ebp
c0022406:	6a 00                	push   $0x0
c0022408:	68 8f 00 00 00       	push   $0x8f
c002240d:	e9 fc f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022412 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c0022412:	55                   	push   %ebp
c0022413:	6a 00                	push   $0x0
c0022415:	68 90 00 00 00       	push   $0x90
c002241a:	e9 ef f9 ff ff       	jmp    c0021e0e <intr_entry>

c002241f <intr91_stub>:
c002241f:	55                   	push   %ebp
c0022420:	6a 00                	push   $0x0
c0022422:	68 91 00 00 00       	push   $0x91
c0022427:	e9 e2 f9 ff ff       	jmp    c0021e0e <intr_entry>

c002242c <intr92_stub>:
c002242c:	55                   	push   %ebp
c002242d:	6a 00                	push   $0x0
c002242f:	68 92 00 00 00       	push   $0x92
c0022434:	e9 d5 f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022439 <intr93_stub>:
c0022439:	55                   	push   %ebp
c002243a:	6a 00                	push   $0x0
c002243c:	68 93 00 00 00       	push   $0x93
c0022441:	e9 c8 f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022446 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022446:	55                   	push   %ebp
c0022447:	6a 00                	push   $0x0
c0022449:	68 94 00 00 00       	push   $0x94
c002244e:	e9 bb f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022453 <intr95_stub>:
c0022453:	55                   	push   %ebp
c0022454:	6a 00                	push   $0x0
c0022456:	68 95 00 00 00       	push   $0x95
c002245b:	e9 ae f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022460 <intr96_stub>:
c0022460:	55                   	push   %ebp
c0022461:	6a 00                	push   $0x0
c0022463:	68 96 00 00 00       	push   $0x96
c0022468:	e9 a1 f9 ff ff       	jmp    c0021e0e <intr_entry>

c002246d <intr97_stub>:
c002246d:	55                   	push   %ebp
c002246e:	6a 00                	push   $0x0
c0022470:	68 97 00 00 00       	push   $0x97
c0022475:	e9 94 f9 ff ff       	jmp    c0021e0e <intr_entry>

c002247a <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c002247a:	55                   	push   %ebp
c002247b:	6a 00                	push   $0x0
c002247d:	68 98 00 00 00       	push   $0x98
c0022482:	e9 87 f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022487 <intr99_stub>:
c0022487:	55                   	push   %ebp
c0022488:	6a 00                	push   $0x0
c002248a:	68 99 00 00 00       	push   $0x99
c002248f:	e9 7a f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022494 <intr9a_stub>:
c0022494:	55                   	push   %ebp
c0022495:	6a 00                	push   $0x0
c0022497:	68 9a 00 00 00       	push   $0x9a
c002249c:	e9 6d f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224a1 <intr9b_stub>:
c00224a1:	55                   	push   %ebp
c00224a2:	6a 00                	push   $0x0
c00224a4:	68 9b 00 00 00       	push   $0x9b
c00224a9:	e9 60 f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224ae <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c00224ae:	55                   	push   %ebp
c00224af:	6a 00                	push   $0x0
c00224b1:	68 9c 00 00 00       	push   $0x9c
c00224b6:	e9 53 f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224bb <intr9d_stub>:
c00224bb:	55                   	push   %ebp
c00224bc:	6a 00                	push   $0x0
c00224be:	68 9d 00 00 00       	push   $0x9d
c00224c3:	e9 46 f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224c8 <intr9e_stub>:
c00224c8:	55                   	push   %ebp
c00224c9:	6a 00                	push   $0x0
c00224cb:	68 9e 00 00 00       	push   $0x9e
c00224d0:	e9 39 f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224d5 <intr9f_stub>:
c00224d5:	55                   	push   %ebp
c00224d6:	6a 00                	push   $0x0
c00224d8:	68 9f 00 00 00       	push   $0x9f
c00224dd:	e9 2c f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224e2 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00224e2:	55                   	push   %ebp
c00224e3:	6a 00                	push   $0x0
c00224e5:	68 a0 00 00 00       	push   $0xa0
c00224ea:	e9 1f f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224ef <intra1_stub>:
c00224ef:	55                   	push   %ebp
c00224f0:	6a 00                	push   $0x0
c00224f2:	68 a1 00 00 00       	push   $0xa1
c00224f7:	e9 12 f9 ff ff       	jmp    c0021e0e <intr_entry>

c00224fc <intra2_stub>:
c00224fc:	55                   	push   %ebp
c00224fd:	6a 00                	push   $0x0
c00224ff:	68 a2 00 00 00       	push   $0xa2
c0022504:	e9 05 f9 ff ff       	jmp    c0021e0e <intr_entry>

c0022509 <intra3_stub>:
c0022509:	55                   	push   %ebp
c002250a:	6a 00                	push   $0x0
c002250c:	68 a3 00 00 00       	push   $0xa3
c0022511:	e9 f8 f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022516 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022516:	55                   	push   %ebp
c0022517:	6a 00                	push   $0x0
c0022519:	68 a4 00 00 00       	push   $0xa4
c002251e:	e9 eb f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022523 <intra5_stub>:
c0022523:	55                   	push   %ebp
c0022524:	6a 00                	push   $0x0
c0022526:	68 a5 00 00 00       	push   $0xa5
c002252b:	e9 de f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022530 <intra6_stub>:
c0022530:	55                   	push   %ebp
c0022531:	6a 00                	push   $0x0
c0022533:	68 a6 00 00 00       	push   $0xa6
c0022538:	e9 d1 f8 ff ff       	jmp    c0021e0e <intr_entry>

c002253d <intra7_stub>:
c002253d:	55                   	push   %ebp
c002253e:	6a 00                	push   $0x0
c0022540:	68 a7 00 00 00       	push   $0xa7
c0022545:	e9 c4 f8 ff ff       	jmp    c0021e0e <intr_entry>

c002254a <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c002254a:	55                   	push   %ebp
c002254b:	6a 00                	push   $0x0
c002254d:	68 a8 00 00 00       	push   $0xa8
c0022552:	e9 b7 f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022557 <intra9_stub>:
c0022557:	55                   	push   %ebp
c0022558:	6a 00                	push   $0x0
c002255a:	68 a9 00 00 00       	push   $0xa9
c002255f:	e9 aa f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022564 <intraa_stub>:
c0022564:	55                   	push   %ebp
c0022565:	6a 00                	push   $0x0
c0022567:	68 aa 00 00 00       	push   $0xaa
c002256c:	e9 9d f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022571 <intrab_stub>:
c0022571:	55                   	push   %ebp
c0022572:	6a 00                	push   $0x0
c0022574:	68 ab 00 00 00       	push   $0xab
c0022579:	e9 90 f8 ff ff       	jmp    c0021e0e <intr_entry>

c002257e <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c002257e:	55                   	push   %ebp
c002257f:	6a 00                	push   $0x0
c0022581:	68 ac 00 00 00       	push   $0xac
c0022586:	e9 83 f8 ff ff       	jmp    c0021e0e <intr_entry>

c002258b <intrad_stub>:
c002258b:	55                   	push   %ebp
c002258c:	6a 00                	push   $0x0
c002258e:	68 ad 00 00 00       	push   $0xad
c0022593:	e9 76 f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022598 <intrae_stub>:
c0022598:	55                   	push   %ebp
c0022599:	6a 00                	push   $0x0
c002259b:	68 ae 00 00 00       	push   $0xae
c00225a0:	e9 69 f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225a5 <intraf_stub>:
c00225a5:	55                   	push   %ebp
c00225a6:	6a 00                	push   $0x0
c00225a8:	68 af 00 00 00       	push   $0xaf
c00225ad:	e9 5c f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225b2 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c00225b2:	55                   	push   %ebp
c00225b3:	6a 00                	push   $0x0
c00225b5:	68 b0 00 00 00       	push   $0xb0
c00225ba:	e9 4f f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225bf <intrb1_stub>:
c00225bf:	55                   	push   %ebp
c00225c0:	6a 00                	push   $0x0
c00225c2:	68 b1 00 00 00       	push   $0xb1
c00225c7:	e9 42 f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225cc <intrb2_stub>:
c00225cc:	55                   	push   %ebp
c00225cd:	6a 00                	push   $0x0
c00225cf:	68 b2 00 00 00       	push   $0xb2
c00225d4:	e9 35 f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225d9 <intrb3_stub>:
c00225d9:	55                   	push   %ebp
c00225da:	6a 00                	push   $0x0
c00225dc:	68 b3 00 00 00       	push   $0xb3
c00225e1:	e9 28 f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225e6 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00225e6:	55                   	push   %ebp
c00225e7:	6a 00                	push   $0x0
c00225e9:	68 b4 00 00 00       	push   $0xb4
c00225ee:	e9 1b f8 ff ff       	jmp    c0021e0e <intr_entry>

c00225f3 <intrb5_stub>:
c00225f3:	55                   	push   %ebp
c00225f4:	6a 00                	push   $0x0
c00225f6:	68 b5 00 00 00       	push   $0xb5
c00225fb:	e9 0e f8 ff ff       	jmp    c0021e0e <intr_entry>

c0022600 <intrb6_stub>:
c0022600:	55                   	push   %ebp
c0022601:	6a 00                	push   $0x0
c0022603:	68 b6 00 00 00       	push   $0xb6
c0022608:	e9 01 f8 ff ff       	jmp    c0021e0e <intr_entry>

c002260d <intrb7_stub>:
c002260d:	55                   	push   %ebp
c002260e:	6a 00                	push   $0x0
c0022610:	68 b7 00 00 00       	push   $0xb7
c0022615:	e9 f4 f7 ff ff       	jmp    c0021e0e <intr_entry>

c002261a <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c002261a:	55                   	push   %ebp
c002261b:	6a 00                	push   $0x0
c002261d:	68 b8 00 00 00       	push   $0xb8
c0022622:	e9 e7 f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022627 <intrb9_stub>:
c0022627:	55                   	push   %ebp
c0022628:	6a 00                	push   $0x0
c002262a:	68 b9 00 00 00       	push   $0xb9
c002262f:	e9 da f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022634 <intrba_stub>:
c0022634:	55                   	push   %ebp
c0022635:	6a 00                	push   $0x0
c0022637:	68 ba 00 00 00       	push   $0xba
c002263c:	e9 cd f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022641 <intrbb_stub>:
c0022641:	55                   	push   %ebp
c0022642:	6a 00                	push   $0x0
c0022644:	68 bb 00 00 00       	push   $0xbb
c0022649:	e9 c0 f7 ff ff       	jmp    c0021e0e <intr_entry>

c002264e <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c002264e:	55                   	push   %ebp
c002264f:	6a 00                	push   $0x0
c0022651:	68 bc 00 00 00       	push   $0xbc
c0022656:	e9 b3 f7 ff ff       	jmp    c0021e0e <intr_entry>

c002265b <intrbd_stub>:
c002265b:	55                   	push   %ebp
c002265c:	6a 00                	push   $0x0
c002265e:	68 bd 00 00 00       	push   $0xbd
c0022663:	e9 a6 f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022668 <intrbe_stub>:
c0022668:	55                   	push   %ebp
c0022669:	6a 00                	push   $0x0
c002266b:	68 be 00 00 00       	push   $0xbe
c0022670:	e9 99 f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022675 <intrbf_stub>:
c0022675:	55                   	push   %ebp
c0022676:	6a 00                	push   $0x0
c0022678:	68 bf 00 00 00       	push   $0xbf
c002267d:	e9 8c f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022682 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022682:	55                   	push   %ebp
c0022683:	6a 00                	push   $0x0
c0022685:	68 c0 00 00 00       	push   $0xc0
c002268a:	e9 7f f7 ff ff       	jmp    c0021e0e <intr_entry>

c002268f <intrc1_stub>:
c002268f:	55                   	push   %ebp
c0022690:	6a 00                	push   $0x0
c0022692:	68 c1 00 00 00       	push   $0xc1
c0022697:	e9 72 f7 ff ff       	jmp    c0021e0e <intr_entry>

c002269c <intrc2_stub>:
c002269c:	55                   	push   %ebp
c002269d:	6a 00                	push   $0x0
c002269f:	68 c2 00 00 00       	push   $0xc2
c00226a4:	e9 65 f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226a9 <intrc3_stub>:
c00226a9:	55                   	push   %ebp
c00226aa:	6a 00                	push   $0x0
c00226ac:	68 c3 00 00 00       	push   $0xc3
c00226b1:	e9 58 f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226b6 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c00226b6:	55                   	push   %ebp
c00226b7:	6a 00                	push   $0x0
c00226b9:	68 c4 00 00 00       	push   $0xc4
c00226be:	e9 4b f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226c3 <intrc5_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	68 c5 00 00 00       	push   $0xc5
c00226cb:	e9 3e f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226d0 <intrc6_stub>:
c00226d0:	55                   	push   %ebp
c00226d1:	6a 00                	push   $0x0
c00226d3:	68 c6 00 00 00       	push   $0xc6
c00226d8:	e9 31 f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226dd <intrc7_stub>:
c00226dd:	55                   	push   %ebp
c00226de:	6a 00                	push   $0x0
c00226e0:	68 c7 00 00 00       	push   $0xc7
c00226e5:	e9 24 f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226ea <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c00226ea:	55                   	push   %ebp
c00226eb:	6a 00                	push   $0x0
c00226ed:	68 c8 00 00 00       	push   $0xc8
c00226f2:	e9 17 f7 ff ff       	jmp    c0021e0e <intr_entry>

c00226f7 <intrc9_stub>:
c00226f7:	55                   	push   %ebp
c00226f8:	6a 00                	push   $0x0
c00226fa:	68 c9 00 00 00       	push   $0xc9
c00226ff:	e9 0a f7 ff ff       	jmp    c0021e0e <intr_entry>

c0022704 <intrca_stub>:
c0022704:	55                   	push   %ebp
c0022705:	6a 00                	push   $0x0
c0022707:	68 ca 00 00 00       	push   $0xca
c002270c:	e9 fd f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022711 <intrcb_stub>:
c0022711:	55                   	push   %ebp
c0022712:	6a 00                	push   $0x0
c0022714:	68 cb 00 00 00       	push   $0xcb
c0022719:	e9 f0 f6 ff ff       	jmp    c0021e0e <intr_entry>

c002271e <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c002271e:	55                   	push   %ebp
c002271f:	6a 00                	push   $0x0
c0022721:	68 cc 00 00 00       	push   $0xcc
c0022726:	e9 e3 f6 ff ff       	jmp    c0021e0e <intr_entry>

c002272b <intrcd_stub>:
c002272b:	55                   	push   %ebp
c002272c:	6a 00                	push   $0x0
c002272e:	68 cd 00 00 00       	push   $0xcd
c0022733:	e9 d6 f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022738 <intrce_stub>:
c0022738:	55                   	push   %ebp
c0022739:	6a 00                	push   $0x0
c002273b:	68 ce 00 00 00       	push   $0xce
c0022740:	e9 c9 f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022745 <intrcf_stub>:
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	68 cf 00 00 00       	push   $0xcf
c002274d:	e9 bc f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022752 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022752:	55                   	push   %ebp
c0022753:	6a 00                	push   $0x0
c0022755:	68 d0 00 00 00       	push   $0xd0
c002275a:	e9 af f6 ff ff       	jmp    c0021e0e <intr_entry>

c002275f <intrd1_stub>:
c002275f:	55                   	push   %ebp
c0022760:	6a 00                	push   $0x0
c0022762:	68 d1 00 00 00       	push   $0xd1
c0022767:	e9 a2 f6 ff ff       	jmp    c0021e0e <intr_entry>

c002276c <intrd2_stub>:
c002276c:	55                   	push   %ebp
c002276d:	6a 00                	push   $0x0
c002276f:	68 d2 00 00 00       	push   $0xd2
c0022774:	e9 95 f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022779 <intrd3_stub>:
c0022779:	55                   	push   %ebp
c002277a:	6a 00                	push   $0x0
c002277c:	68 d3 00 00 00       	push   $0xd3
c0022781:	e9 88 f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022786 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022786:	55                   	push   %ebp
c0022787:	6a 00                	push   $0x0
c0022789:	68 d4 00 00 00       	push   $0xd4
c002278e:	e9 7b f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022793 <intrd5_stub>:
c0022793:	55                   	push   %ebp
c0022794:	6a 00                	push   $0x0
c0022796:	68 d5 00 00 00       	push   $0xd5
c002279b:	e9 6e f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227a0 <intrd6_stub>:
c00227a0:	55                   	push   %ebp
c00227a1:	6a 00                	push   $0x0
c00227a3:	68 d6 00 00 00       	push   $0xd6
c00227a8:	e9 61 f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227ad <intrd7_stub>:
c00227ad:	55                   	push   %ebp
c00227ae:	6a 00                	push   $0x0
c00227b0:	68 d7 00 00 00       	push   $0xd7
c00227b5:	e9 54 f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227ba <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c00227ba:	55                   	push   %ebp
c00227bb:	6a 00                	push   $0x0
c00227bd:	68 d8 00 00 00       	push   $0xd8
c00227c2:	e9 47 f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227c7 <intrd9_stub>:
c00227c7:	55                   	push   %ebp
c00227c8:	6a 00                	push   $0x0
c00227ca:	68 d9 00 00 00       	push   $0xd9
c00227cf:	e9 3a f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227d4 <intrda_stub>:
c00227d4:	55                   	push   %ebp
c00227d5:	6a 00                	push   $0x0
c00227d7:	68 da 00 00 00       	push   $0xda
c00227dc:	e9 2d f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227e1 <intrdb_stub>:
c00227e1:	55                   	push   %ebp
c00227e2:	6a 00                	push   $0x0
c00227e4:	68 db 00 00 00       	push   $0xdb
c00227e9:	e9 20 f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227ee <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c00227ee:	55                   	push   %ebp
c00227ef:	6a 00                	push   $0x0
c00227f1:	68 dc 00 00 00       	push   $0xdc
c00227f6:	e9 13 f6 ff ff       	jmp    c0021e0e <intr_entry>

c00227fb <intrdd_stub>:
c00227fb:	55                   	push   %ebp
c00227fc:	6a 00                	push   $0x0
c00227fe:	68 dd 00 00 00       	push   $0xdd
c0022803:	e9 06 f6 ff ff       	jmp    c0021e0e <intr_entry>

c0022808 <intrde_stub>:
c0022808:	55                   	push   %ebp
c0022809:	6a 00                	push   $0x0
c002280b:	68 de 00 00 00       	push   $0xde
c0022810:	e9 f9 f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022815 <intrdf_stub>:
c0022815:	55                   	push   %ebp
c0022816:	6a 00                	push   $0x0
c0022818:	68 df 00 00 00       	push   $0xdf
c002281d:	e9 ec f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022822 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022822:	55                   	push   %ebp
c0022823:	6a 00                	push   $0x0
c0022825:	68 e0 00 00 00       	push   $0xe0
c002282a:	e9 df f5 ff ff       	jmp    c0021e0e <intr_entry>

c002282f <intre1_stub>:
c002282f:	55                   	push   %ebp
c0022830:	6a 00                	push   $0x0
c0022832:	68 e1 00 00 00       	push   $0xe1
c0022837:	e9 d2 f5 ff ff       	jmp    c0021e0e <intr_entry>

c002283c <intre2_stub>:
c002283c:	55                   	push   %ebp
c002283d:	6a 00                	push   $0x0
c002283f:	68 e2 00 00 00       	push   $0xe2
c0022844:	e9 c5 f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022849 <intre3_stub>:
c0022849:	55                   	push   %ebp
c002284a:	6a 00                	push   $0x0
c002284c:	68 e3 00 00 00       	push   $0xe3
c0022851:	e9 b8 f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022856 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022856:	55                   	push   %ebp
c0022857:	6a 00                	push   $0x0
c0022859:	68 e4 00 00 00       	push   $0xe4
c002285e:	e9 ab f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022863 <intre5_stub>:
c0022863:	55                   	push   %ebp
c0022864:	6a 00                	push   $0x0
c0022866:	68 e5 00 00 00       	push   $0xe5
c002286b:	e9 9e f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022870 <intre6_stub>:
c0022870:	55                   	push   %ebp
c0022871:	6a 00                	push   $0x0
c0022873:	68 e6 00 00 00       	push   $0xe6
c0022878:	e9 91 f5 ff ff       	jmp    c0021e0e <intr_entry>

c002287d <intre7_stub>:
c002287d:	55                   	push   %ebp
c002287e:	6a 00                	push   $0x0
c0022880:	68 e7 00 00 00       	push   $0xe7
c0022885:	e9 84 f5 ff ff       	jmp    c0021e0e <intr_entry>

c002288a <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c002288a:	55                   	push   %ebp
c002288b:	6a 00                	push   $0x0
c002288d:	68 e8 00 00 00       	push   $0xe8
c0022892:	e9 77 f5 ff ff       	jmp    c0021e0e <intr_entry>

c0022897 <intre9_stub>:
c0022897:	55                   	push   %ebp
c0022898:	6a 00                	push   $0x0
c002289a:	68 e9 00 00 00       	push   $0xe9
c002289f:	e9 6a f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228a4 <intrea_stub>:
c00228a4:	55                   	push   %ebp
c00228a5:	6a 00                	push   $0x0
c00228a7:	68 ea 00 00 00       	push   $0xea
c00228ac:	e9 5d f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228b1 <intreb_stub>:
c00228b1:	55                   	push   %ebp
c00228b2:	6a 00                	push   $0x0
c00228b4:	68 eb 00 00 00       	push   $0xeb
c00228b9:	e9 50 f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228be <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c00228be:	55                   	push   %ebp
c00228bf:	6a 00                	push   $0x0
c00228c1:	68 ec 00 00 00       	push   $0xec
c00228c6:	e9 43 f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228cb <intred_stub>:
c00228cb:	55                   	push   %ebp
c00228cc:	6a 00                	push   $0x0
c00228ce:	68 ed 00 00 00       	push   $0xed
c00228d3:	e9 36 f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228d8 <intree_stub>:
c00228d8:	55                   	push   %ebp
c00228d9:	6a 00                	push   $0x0
c00228db:	68 ee 00 00 00       	push   $0xee
c00228e0:	e9 29 f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228e5 <intref_stub>:
c00228e5:	55                   	push   %ebp
c00228e6:	6a 00                	push   $0x0
c00228e8:	68 ef 00 00 00       	push   $0xef
c00228ed:	e9 1c f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228f2 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c00228f2:	55                   	push   %ebp
c00228f3:	6a 00                	push   $0x0
c00228f5:	68 f0 00 00 00       	push   $0xf0
c00228fa:	e9 0f f5 ff ff       	jmp    c0021e0e <intr_entry>

c00228ff <intrf1_stub>:
c00228ff:	55                   	push   %ebp
c0022900:	6a 00                	push   $0x0
c0022902:	68 f1 00 00 00       	push   $0xf1
c0022907:	e9 02 f5 ff ff       	jmp    c0021e0e <intr_entry>

c002290c <intrf2_stub>:
c002290c:	55                   	push   %ebp
c002290d:	6a 00                	push   $0x0
c002290f:	68 f2 00 00 00       	push   $0xf2
c0022914:	e9 f5 f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022919 <intrf3_stub>:
c0022919:	55                   	push   %ebp
c002291a:	6a 00                	push   $0x0
c002291c:	68 f3 00 00 00       	push   $0xf3
c0022921:	e9 e8 f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022926 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022926:	55                   	push   %ebp
c0022927:	6a 00                	push   $0x0
c0022929:	68 f4 00 00 00       	push   $0xf4
c002292e:	e9 db f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022933 <intrf5_stub>:
c0022933:	55                   	push   %ebp
c0022934:	6a 00                	push   $0x0
c0022936:	68 f5 00 00 00       	push   $0xf5
c002293b:	e9 ce f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022940 <intrf6_stub>:
c0022940:	55                   	push   %ebp
c0022941:	6a 00                	push   $0x0
c0022943:	68 f6 00 00 00       	push   $0xf6
c0022948:	e9 c1 f4 ff ff       	jmp    c0021e0e <intr_entry>

c002294d <intrf7_stub>:
c002294d:	55                   	push   %ebp
c002294e:	6a 00                	push   $0x0
c0022950:	68 f7 00 00 00       	push   $0xf7
c0022955:	e9 b4 f4 ff ff       	jmp    c0021e0e <intr_entry>

c002295a <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c002295a:	55                   	push   %ebp
c002295b:	6a 00                	push   $0x0
c002295d:	68 f8 00 00 00       	push   $0xf8
c0022962:	e9 a7 f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022967 <intrf9_stub>:
c0022967:	55                   	push   %ebp
c0022968:	6a 00                	push   $0x0
c002296a:	68 f9 00 00 00       	push   $0xf9
c002296f:	e9 9a f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022974 <intrfa_stub>:
c0022974:	55                   	push   %ebp
c0022975:	6a 00                	push   $0x0
c0022977:	68 fa 00 00 00       	push   $0xfa
c002297c:	e9 8d f4 ff ff       	jmp    c0021e0e <intr_entry>

c0022981 <intrfb_stub>:
c0022981:	55                   	push   %ebp
c0022982:	6a 00                	push   $0x0
c0022984:	68 fb 00 00 00       	push   $0xfb
c0022989:	e9 80 f4 ff ff       	jmp    c0021e0e <intr_entry>

c002298e <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c002298e:	55                   	push   %ebp
c002298f:	6a 00                	push   $0x0
c0022991:	68 fc 00 00 00       	push   $0xfc
c0022996:	e9 73 f4 ff ff       	jmp    c0021e0e <intr_entry>

c002299b <intrfd_stub>:
c002299b:	55                   	push   %ebp
c002299c:	6a 00                	push   $0x0
c002299e:	68 fd 00 00 00       	push   $0xfd
c00229a3:	e9 66 f4 ff ff       	jmp    c0021e0e <intr_entry>

c00229a8 <intrfe_stub>:
c00229a8:	55                   	push   %ebp
c00229a9:	6a 00                	push   $0x0
c00229ab:	68 fe 00 00 00       	push   $0xfe
c00229b0:	e9 59 f4 ff ff       	jmp    c0021e0e <intr_entry>

c00229b5 <intrff_stub>:
c00229b5:	55                   	push   %ebp
c00229b6:	6a 00                	push   $0x0
c00229b8:	68 ff 00 00 00       	push   $0xff
c00229bd:	e9 4c f4 ff ff       	jmp    c0021e0e <intr_entry>

c00229c2 <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c00229c2:	55                   	push   %ebp
c00229c3:	89 e5                	mov    %esp,%ebp
c00229c5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c00229c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00229cc:	75 1e                	jne    c00229ec <sema_init+0x2a>
c00229ce:	83 ec 0c             	sub    $0xc,%esp
c00229d1:	68 dc 02 03 c0       	push   $0xc00302dc
c00229d6:	68 e9 02 03 c0       	push   $0xc00302e9
c00229db:	68 b0 03 03 c0       	push   $0xc00303b0
c00229e0:	6a 2f                	push   $0x2f
c00229e2:	68 00 03 03 c0       	push   $0xc0030300
c00229e7:	e8 82 6d 00 00       	call   c002976e <debug_panic>

  sema->value = value;
c00229ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00229ef:	8b 55 0c             	mov    0xc(%ebp),%edx
c00229f2:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c00229f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00229f7:	83 c0 04             	add    $0x4,%eax
c00229fa:	83 ec 0c             	sub    $0xc,%esp
c00229fd:	50                   	push   %eax
c00229fe:	e8 dc 6f 00 00       	call   c00299df <list_init>
c0022a03:	83 c4 10             	add    $0x10,%esp
}
c0022a06:	90                   	nop
c0022a07:	c9                   	leave  
c0022a08:	c3                   	ret    

c0022a09 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c0022a09:	55                   	push   %ebp
c0022a0a:	89 e5                	mov    %esp,%ebp
c0022a0c:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022a0f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a13:	75 1e                	jne    c0022a33 <sema_down+0x2a>
c0022a15:	83 ec 0c             	sub    $0xc,%esp
c0022a18:	68 dc 02 03 c0       	push   $0xc00302dc
c0022a1d:	68 e9 02 03 c0       	push   $0xc00302e9
c0022a22:	68 bc 03 03 c0       	push   $0xc00303bc
c0022a27:	6a 41                	push   $0x41
c0022a29:	68 00 03 03 c0       	push   $0xc0030300
c0022a2e:	e8 3b 6d 00 00       	call   c002976e <debug_panic>
  ASSERT (!intr_context ());
c0022a33:	e8 58 ee ff ff       	call   c0021890 <intr_context>
c0022a38:	83 f0 01             	xor    $0x1,%eax
c0022a3b:	84 c0                	test   %al,%al
c0022a3d:	75 1e                	jne    c0022a5d <sema_down+0x54>
c0022a3f:	83 ec 0c             	sub    $0xc,%esp
c0022a42:	68 16 03 03 c0       	push   $0xc0030316
c0022a47:	68 e9 02 03 c0       	push   $0xc00302e9
c0022a4c:	68 bc 03 03 c0       	push   $0xc00303bc
c0022a51:	6a 42                	push   $0x42
c0022a53:	68 00 03 03 c0       	push   $0xc0030300
c0022a58:	e8 11 6d 00 00       	call   c002976e <debug_panic>

  old_level = intr_disable ();
c0022a5d:	e8 61 eb ff ff       	call   c00215c3 <intr_disable>
c0022a62:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c0022a65:	eb 20                	jmp    c0022a87 <sema_down+0x7e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022a67:	e8 f4 e3 ff ff       	call   c0020e60 <thread_current>
c0022a6c:	8d 50 28             	lea    0x28(%eax),%edx
c0022a6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a72:	83 c0 04             	add    $0x4,%eax
c0022a75:	83 ec 08             	sub    $0x8,%esp
c0022a78:	52                   	push   %edx
c0022a79:	50                   	push   %eax
c0022a7a:	e8 40 73 00 00       	call   c0029dbf <list_push_back>
c0022a7f:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c0022a82:	e8 b9 e2 ff ff       	call   c0020d40 <thread_block>
  while (sema->value == 0) 
c0022a87:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a8a:	8b 00                	mov    (%eax),%eax
c0022a8c:	85 c0                	test   %eax,%eax
c0022a8e:	74 d7                	je     c0022a67 <sema_down+0x5e>
    }
  sema->value--;
c0022a90:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a93:	8b 00                	mov    (%eax),%eax
c0022a95:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022a98:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a9b:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022a9d:	83 ec 0c             	sub    $0xc,%esp
c0022aa0:	ff 75 f4             	pushl  -0xc(%ebp)
c0022aa3:	e8 c3 ea ff ff       	call   c002156b <intr_set_level>
c0022aa8:	83 c4 10             	add    $0x10,%esp
}
c0022aab:	90                   	nop
c0022aac:	c9                   	leave  
c0022aad:	c3                   	ret    

c0022aae <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022aae:	55                   	push   %ebp
c0022aaf:	89 e5                	mov    %esp,%ebp
c0022ab1:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c0022ab4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ab8:	75 1e                	jne    c0022ad8 <sema_try_down+0x2a>
c0022aba:	83 ec 0c             	sub    $0xc,%esp
c0022abd:	68 dc 02 03 c0       	push   $0xc00302dc
c0022ac2:	68 e9 02 03 c0       	push   $0xc00302e9
c0022ac7:	68 c8 03 03 c0       	push   $0xc00303c8
c0022acc:	6a 59                	push   $0x59
c0022ace:	68 00 03 03 c0       	push   $0xc0030300
c0022ad3:	e8 96 6c 00 00       	call   c002976e <debug_panic>

  old_level = intr_disable ();
c0022ad8:	e8 e6 ea ff ff       	call   c00215c3 <intr_disable>
c0022add:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c0022ae0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ae3:	8b 00                	mov    (%eax),%eax
c0022ae5:	85 c0                	test   %eax,%eax
c0022ae7:	74 13                	je     c0022afc <sema_try_down+0x4e>
    {
      sema->value--;
c0022ae9:	8b 45 08             	mov    0x8(%ebp),%eax
c0022aec:	8b 00                	mov    (%eax),%eax
c0022aee:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022af1:	8b 45 08             	mov    0x8(%ebp),%eax
c0022af4:	89 10                	mov    %edx,(%eax)
      success = true; 
c0022af6:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c0022afa:	eb 04                	jmp    c0022b00 <sema_try_down+0x52>
    }
  else
    success = false;
c0022afc:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c0022b00:	83 ec 0c             	sub    $0xc,%esp
c0022b03:	ff 75 f0             	pushl  -0x10(%ebp)
c0022b06:	e8 60 ea ff ff       	call   c002156b <intr_set_level>
c0022b0b:	83 c4 10             	add    $0x10,%esp

  return success;
c0022b0e:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0022b11:	c9                   	leave  
c0022b12:	c3                   	ret    

c0022b13 <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022b13:	55                   	push   %ebp
c0022b14:	89 e5                	mov    %esp,%ebp
c0022b16:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c0022b19:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022b1d:	75 1e                	jne    c0022b3d <sema_up+0x2a>
c0022b1f:	83 ec 0c             	sub    $0xc,%esp
c0022b22:	68 dc 02 03 c0       	push   $0xc00302dc
c0022b27:	68 e9 02 03 c0       	push   $0xc00302e9
c0022b2c:	68 d8 03 03 c0       	push   $0xc00303d8
c0022b31:	6a 71                	push   $0x71
c0022b33:	68 00 03 03 c0       	push   $0xc0030300
c0022b38:	e8 31 6c 00 00       	call   c002976e <debug_panic>

  old_level = intr_disable ();
c0022b3d:	e8 81 ea ff ff       	call   c00215c3 <intr_disable>
c0022b42:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) 
c0022b45:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b48:	83 c0 04             	add    $0x4,%eax
c0022b4b:	83 ec 0c             	sub    $0xc,%esp
c0022b4e:	50                   	push   %eax
c0022b4f:	e8 12 74 00 00       	call   c0029f66 <list_empty>
c0022b54:	83 c4 10             	add    $0x10,%esp
c0022b57:	83 f0 01             	xor    $0x1,%eax
c0022b5a:	84 c0                	test   %al,%al
c0022b5c:	74 24                	je     c0022b82 <sema_up+0x6f>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022b5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b61:	83 c0 04             	add    $0x4,%eax
c0022b64:	83 ec 0c             	sub    $0xc,%esp
c0022b67:	50                   	push   %eax
c0022b68:	e8 d1 72 00 00       	call   c0029e3e <list_pop_front>
c0022b6d:	83 c4 10             	add    $0x10,%esp
c0022b70:	83 c0 04             	add    $0x4,%eax
c0022b73:	83 e8 2c             	sub    $0x2c,%eax
c0022b76:	83 ec 0c             	sub    $0xc,%esp
c0022b79:	50                   	push   %eax
c0022b7a:	e8 32 e2 ff ff       	call   c0020db1 <thread_unblock>
c0022b7f:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  sema->value++;
c0022b82:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b85:	8b 00                	mov    (%eax),%eax
c0022b87:	8d 50 01             	lea    0x1(%eax),%edx
c0022b8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b8d:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022b8f:	83 ec 0c             	sub    $0xc,%esp
c0022b92:	ff 75 f4             	pushl  -0xc(%ebp)
c0022b95:	e8 d1 e9 ff ff       	call   c002156b <intr_set_level>
c0022b9a:	83 c4 10             	add    $0x10,%esp
}
c0022b9d:	90                   	nop
c0022b9e:	c9                   	leave  
c0022b9f:	c3                   	ret    

c0022ba0 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022ba0:	55                   	push   %ebp
c0022ba1:	89 e5                	mov    %esp,%ebp
c0022ba3:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c0022ba6:	83 ec 0c             	sub    $0xc,%esp
c0022ba9:	68 27 03 03 c0       	push   $0xc0030327
c0022bae:	e8 fc 47 00 00       	call   c00273af <printf>
c0022bb3:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c0022bb6:	83 ec 08             	sub    $0x8,%esp
c0022bb9:	6a 00                	push   $0x0
c0022bbb:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022bbe:	50                   	push   %eax
c0022bbf:	e8 fe fd ff ff       	call   c00229c2 <sema_init>
c0022bc4:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0022bc7:	83 ec 08             	sub    $0x8,%esp
c0022bca:	6a 00                	push   $0x0
c0022bcc:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022bcf:	83 c0 14             	add    $0x14,%eax
c0022bd2:	50                   	push   %eax
c0022bd3:	e8 ea fd ff ff       	call   c00229c2 <sema_init>
c0022bd8:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022bdb:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022bde:	50                   	push   %eax
c0022bdf:	68 39 2c 02 c0       	push   $0xc0022c39
c0022be4:	6a 1f                	push   $0x1f
c0022be6:	68 3d 03 03 c0       	push   $0xc003033d
c0022beb:	e8 57 e0 ff ff       	call   c0020c47 <thread_create>
c0022bf0:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022bf3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022bfa:	eb 24                	jmp    c0022c20 <sema_self_test+0x80>
    {
      sema_up (&sema[0]);
c0022bfc:	83 ec 0c             	sub    $0xc,%esp
c0022bff:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022c02:	50                   	push   %eax
c0022c03:	e8 0b ff ff ff       	call   c0022b13 <sema_up>
c0022c08:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0022c0b:	83 ec 0c             	sub    $0xc,%esp
c0022c0e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022c11:	83 c0 14             	add    $0x14,%eax
c0022c14:	50                   	push   %eax
c0022c15:	e8 ef fd ff ff       	call   c0022a09 <sema_down>
c0022c1a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022c1d:	ff 45 f4             	incl   -0xc(%ebp)
c0022c20:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022c24:	7e d6                	jle    c0022bfc <sema_self_test+0x5c>
    }
  printf ("done.\n");
c0022c26:	83 ec 0c             	sub    $0xc,%esp
c0022c29:	68 47 03 03 c0       	push   $0xc0030347
c0022c2e:	e8 0d 8e 00 00       	call   c002ba40 <puts>
c0022c33:	83 c4 10             	add    $0x10,%esp
}
c0022c36:	90                   	nop
c0022c37:	c9                   	leave  
c0022c38:	c3                   	ret    

c0022c39 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022c39:	55                   	push   %ebp
c0022c3a:	89 e5                	mov    %esp,%ebp
c0022c3c:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0022c3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c42:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0022c45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022c4c:	eb 23                	jmp    c0022c71 <sema_test_helper+0x38>
    {
      sema_down (&sema[0]);
c0022c4e:	83 ec 0c             	sub    $0xc,%esp
c0022c51:	ff 75 f0             	pushl  -0x10(%ebp)
c0022c54:	e8 b0 fd ff ff       	call   c0022a09 <sema_down>
c0022c59:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0022c5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022c5f:	83 c0 14             	add    $0x14,%eax
c0022c62:	83 ec 0c             	sub    $0xc,%esp
c0022c65:	50                   	push   %eax
c0022c66:	e8 a8 fe ff ff       	call   c0022b13 <sema_up>
c0022c6b:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022c6e:	ff 45 f4             	incl   -0xc(%ebp)
c0022c71:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022c75:	7e d7                	jle    c0022c4e <sema_test_helper+0x15>
    }
}
c0022c77:	90                   	nop
c0022c78:	c9                   	leave  
c0022c79:	c3                   	ret    

c0022c7a <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022c7a:	55                   	push   %ebp
c0022c7b:	89 e5                	mov    %esp,%ebp
c0022c7d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022c80:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c84:	75 21                	jne    c0022ca7 <lock_init+0x2d>
c0022c86:	83 ec 0c             	sub    $0xc,%esp
c0022c89:	68 4d 03 03 c0       	push   $0xc003034d
c0022c8e:	68 e9 02 03 c0       	push   $0xc00302e9
c0022c93:	68 e0 03 03 c0       	push   $0xc00303e0
c0022c98:	68 b2 00 00 00       	push   $0xb2
c0022c9d:	68 00 03 03 c0       	push   $0xc0030300
c0022ca2:	e8 c7 6a 00 00       	call   c002976e <debug_panic>

  lock->holder = NULL;
c0022ca7:	8b 45 08             	mov    0x8(%ebp),%eax
c0022caa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022cb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cb3:	83 c0 04             	add    $0x4,%eax
c0022cb6:	83 ec 08             	sub    $0x8,%esp
c0022cb9:	6a 01                	push   $0x1
c0022cbb:	50                   	push   %eax
c0022cbc:	e8 01 fd ff ff       	call   c00229c2 <sema_init>
c0022cc1:	83 c4 10             	add    $0x10,%esp
}
c0022cc4:	90                   	nop
c0022cc5:	c9                   	leave  
c0022cc6:	c3                   	ret    

c0022cc7 <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c0022cc7:	55                   	push   %ebp
c0022cc8:	89 e5                	mov    %esp,%ebp
c0022cca:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022ccd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022cd1:	75 21                	jne    c0022cf4 <lock_acquire+0x2d>
c0022cd3:	83 ec 0c             	sub    $0xc,%esp
c0022cd6:	68 4d 03 03 c0       	push   $0xc003034d
c0022cdb:	68 e9 02 03 c0       	push   $0xc00302e9
c0022ce0:	68 ec 03 03 c0       	push   $0xc00303ec
c0022ce5:	68 c3 00 00 00       	push   $0xc3
c0022cea:	68 00 03 03 c0       	push   $0xc0030300
c0022cef:	e8 7a 6a 00 00       	call   c002976e <debug_panic>
  ASSERT (!intr_context ());
c0022cf4:	e8 97 eb ff ff       	call   c0021890 <intr_context>
c0022cf9:	83 f0 01             	xor    $0x1,%eax
c0022cfc:	84 c0                	test   %al,%al
c0022cfe:	75 21                	jne    c0022d21 <lock_acquire+0x5a>
c0022d00:	83 ec 0c             	sub    $0xc,%esp
c0022d03:	68 16 03 03 c0       	push   $0xc0030316
c0022d08:	68 e9 02 03 c0       	push   $0xc00302e9
c0022d0d:	68 ec 03 03 c0       	push   $0xc00303ec
c0022d12:	68 c4 00 00 00       	push   $0xc4
c0022d17:	68 00 03 03 c0       	push   $0xc0030300
c0022d1c:	e8 4d 6a 00 00       	call   c002976e <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022d21:	83 ec 0c             	sub    $0xc,%esp
c0022d24:	ff 75 08             	pushl  0x8(%ebp)
c0022d27:	e8 59 01 00 00       	call   c0022e85 <lock_held_by_current_thread>
c0022d2c:	83 c4 10             	add    $0x10,%esp
c0022d2f:	83 f0 01             	xor    $0x1,%eax
c0022d32:	84 c0                	test   %al,%al
c0022d34:	75 21                	jne    c0022d57 <lock_acquire+0x90>
c0022d36:	83 ec 0c             	sub    $0xc,%esp
c0022d39:	68 5c 03 03 c0       	push   $0xc003035c
c0022d3e:	68 e9 02 03 c0       	push   $0xc00302e9
c0022d43:	68 ec 03 03 c0       	push   $0xc00303ec
c0022d48:	68 c5 00 00 00       	push   $0xc5
c0022d4d:	68 00 03 03 c0       	push   $0xc0030300
c0022d52:	e8 17 6a 00 00       	call   c002976e <debug_panic>

  sema_down (&lock->semaphore);
c0022d57:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d5a:	83 c0 04             	add    $0x4,%eax
c0022d5d:	83 ec 0c             	sub    $0xc,%esp
c0022d60:	50                   	push   %eax
c0022d61:	e8 a3 fc ff ff       	call   c0022a09 <sema_down>
c0022d66:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c0022d69:	e8 f2 e0 ff ff       	call   c0020e60 <thread_current>
c0022d6e:	89 c2                	mov    %eax,%edx
c0022d70:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d73:	89 10                	mov    %edx,(%eax)
}
c0022d75:	90                   	nop
c0022d76:	c9                   	leave  
c0022d77:	c3                   	ret    

c0022d78 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022d78:	55                   	push   %ebp
c0022d79:	89 e5                	mov    %esp,%ebp
c0022d7b:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0022d7e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022d82:	75 21                	jne    c0022da5 <lock_try_acquire+0x2d>
c0022d84:	83 ec 0c             	sub    $0xc,%esp
c0022d87:	68 4d 03 03 c0       	push   $0xc003034d
c0022d8c:	68 e9 02 03 c0       	push   $0xc00302e9
c0022d91:	68 fc 03 03 c0       	push   $0xc00303fc
c0022d96:	68 d6 00 00 00       	push   $0xd6
c0022d9b:	68 00 03 03 c0       	push   $0xc0030300
c0022da0:	e8 c9 69 00 00       	call   c002976e <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022da5:	83 ec 0c             	sub    $0xc,%esp
c0022da8:	ff 75 08             	pushl  0x8(%ebp)
c0022dab:	e8 d5 00 00 00       	call   c0022e85 <lock_held_by_current_thread>
c0022db0:	83 c4 10             	add    $0x10,%esp
c0022db3:	83 f0 01             	xor    $0x1,%eax
c0022db6:	84 c0                	test   %al,%al
c0022db8:	75 21                	jne    c0022ddb <lock_try_acquire+0x63>
c0022dba:	83 ec 0c             	sub    $0xc,%esp
c0022dbd:	68 5c 03 03 c0       	push   $0xc003035c
c0022dc2:	68 e9 02 03 c0       	push   $0xc00302e9
c0022dc7:	68 fc 03 03 c0       	push   $0xc00303fc
c0022dcc:	68 d7 00 00 00       	push   $0xd7
c0022dd1:	68 00 03 03 c0       	push   $0xc0030300
c0022dd6:	e8 93 69 00 00       	call   c002976e <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022ddb:	8b 45 08             	mov    0x8(%ebp),%eax
c0022dde:	83 c0 04             	add    $0x4,%eax
c0022de1:	83 ec 0c             	sub    $0xc,%esp
c0022de4:	50                   	push   %eax
c0022de5:	e8 c4 fc ff ff       	call   c0022aae <sema_try_down>
c0022dea:	83 c4 10             	add    $0x10,%esp
c0022ded:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c0022df0:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0022df4:	74 0c                	je     c0022e02 <lock_try_acquire+0x8a>
    lock->holder = thread_current ();
c0022df6:	e8 65 e0 ff ff       	call   c0020e60 <thread_current>
c0022dfb:	89 c2                	mov    %eax,%edx
c0022dfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e00:	89 10                	mov    %edx,(%eax)
  return success;
c0022e02:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0022e05:	c9                   	leave  
c0022e06:	c3                   	ret    

c0022e07 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022e07:	55                   	push   %ebp
c0022e08:	89 e5                	mov    %esp,%ebp
c0022e0a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022e0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e11:	75 21                	jne    c0022e34 <lock_release+0x2d>
c0022e13:	83 ec 0c             	sub    $0xc,%esp
c0022e16:	68 4d 03 03 c0       	push   $0xc003034d
c0022e1b:	68 e9 02 03 c0       	push   $0xc00302e9
c0022e20:	68 10 04 03 c0       	push   $0xc0030410
c0022e25:	68 e7 00 00 00       	push   $0xe7
c0022e2a:	68 00 03 03 c0       	push   $0xc0030300
c0022e2f:	e8 3a 69 00 00       	call   c002976e <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022e34:	83 ec 0c             	sub    $0xc,%esp
c0022e37:	ff 75 08             	pushl  0x8(%ebp)
c0022e3a:	e8 46 00 00 00       	call   c0022e85 <lock_held_by_current_thread>
c0022e3f:	83 c4 10             	add    $0x10,%esp
c0022e42:	84 c0                	test   %al,%al
c0022e44:	75 21                	jne    c0022e67 <lock_release+0x60>
c0022e46:	83 ec 0c             	sub    $0xc,%esp
c0022e49:	68 80 03 03 c0       	push   $0xc0030380
c0022e4e:	68 e9 02 03 c0       	push   $0xc00302e9
c0022e53:	68 10 04 03 c0       	push   $0xc0030410
c0022e58:	68 e8 00 00 00       	push   $0xe8
c0022e5d:	68 00 03 03 c0       	push   $0xc0030300
c0022e62:	e8 07 69 00 00       	call   c002976e <debug_panic>

  lock->holder = NULL;
c0022e67:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c0022e70:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e73:	83 c0 04             	add    $0x4,%eax
c0022e76:	83 ec 0c             	sub    $0xc,%esp
c0022e79:	50                   	push   %eax
c0022e7a:	e8 94 fc ff ff       	call   c0022b13 <sema_up>
c0022e7f:	83 c4 10             	add    $0x10,%esp
}
c0022e82:	90                   	nop
c0022e83:	c9                   	leave  
c0022e84:	c3                   	ret    

c0022e85 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022e85:	55                   	push   %ebp
c0022e86:	89 e5                	mov    %esp,%ebp
c0022e88:	53                   	push   %ebx
c0022e89:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c0022e8c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e90:	75 21                	jne    c0022eb3 <lock_held_by_current_thread+0x2e>
c0022e92:	83 ec 0c             	sub    $0xc,%esp
c0022e95:	68 4d 03 03 c0       	push   $0xc003034d
c0022e9a:	68 e9 02 03 c0       	push   $0xc00302e9
c0022e9f:	68 20 04 03 c0       	push   $0xc0030420
c0022ea4:	68 f4 00 00 00       	push   $0xf4
c0022ea9:	68 00 03 03 c0       	push   $0xc0030300
c0022eae:	e8 bb 68 00 00       	call   c002976e <debug_panic>

  return lock->holder == thread_current ();
c0022eb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0022eb6:	8b 18                	mov    (%eax),%ebx
c0022eb8:	e8 a3 df ff ff       	call   c0020e60 <thread_current>
c0022ebd:	39 c3                	cmp    %eax,%ebx
c0022ebf:	0f 94 c0             	sete   %al
}
c0022ec2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022ec5:	c9                   	leave  
c0022ec6:	c3                   	ret    

c0022ec7 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022ec7:	55                   	push   %ebp
c0022ec8:	89 e5                	mov    %esp,%ebp
c0022eca:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022ecd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ed1:	75 21                	jne    c0022ef4 <cond_init+0x2d>
c0022ed3:	83 ec 0c             	sub    $0xc,%esp
c0022ed6:	68 a3 03 03 c0       	push   $0xc00303a3
c0022edb:	68 e9 02 03 c0       	push   $0xc00302e9
c0022ee0:	68 3c 04 03 c0       	push   $0xc003043c
c0022ee5:	68 06 01 00 00       	push   $0x106
c0022eea:	68 00 03 03 c0       	push   $0xc0030300
c0022eef:	e8 7a 68 00 00       	call   c002976e <debug_panic>

  list_init (&cond->waiters);
c0022ef4:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ef7:	83 ec 0c             	sub    $0xc,%esp
c0022efa:	50                   	push   %eax
c0022efb:	e8 df 6a 00 00       	call   c00299df <list_init>
c0022f00:	83 c4 10             	add    $0x10,%esp
}
c0022f03:	90                   	nop
c0022f04:	c9                   	leave  
c0022f05:	c3                   	ret    

c0022f06 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022f06:	55                   	push   %ebp
c0022f07:	89 e5                	mov    %esp,%ebp
c0022f09:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022f0c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022f10:	75 21                	jne    c0022f33 <cond_wait+0x2d>
c0022f12:	83 ec 0c             	sub    $0xc,%esp
c0022f15:	68 a3 03 03 c0       	push   $0xc00303a3
c0022f1a:	68 e9 02 03 c0       	push   $0xc00302e9
c0022f1f:	68 48 04 03 c0       	push   $0xc0030448
c0022f24:	68 24 01 00 00       	push   $0x124
c0022f29:	68 00 03 03 c0       	push   $0xc0030300
c0022f2e:	e8 3b 68 00 00       	call   c002976e <debug_panic>
  ASSERT (lock != NULL);
c0022f33:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022f37:	75 21                	jne    c0022f5a <cond_wait+0x54>
c0022f39:	83 ec 0c             	sub    $0xc,%esp
c0022f3c:	68 4d 03 03 c0       	push   $0xc003034d
c0022f41:	68 e9 02 03 c0       	push   $0xc00302e9
c0022f46:	68 48 04 03 c0       	push   $0xc0030448
c0022f4b:	68 25 01 00 00       	push   $0x125
c0022f50:	68 00 03 03 c0       	push   $0xc0030300
c0022f55:	e8 14 68 00 00       	call   c002976e <debug_panic>
  ASSERT (!intr_context ());
c0022f5a:	e8 31 e9 ff ff       	call   c0021890 <intr_context>
c0022f5f:	83 f0 01             	xor    $0x1,%eax
c0022f62:	84 c0                	test   %al,%al
c0022f64:	75 21                	jne    c0022f87 <cond_wait+0x81>
c0022f66:	83 ec 0c             	sub    $0xc,%esp
c0022f69:	68 16 03 03 c0       	push   $0xc0030316
c0022f6e:	68 e9 02 03 c0       	push   $0xc00302e9
c0022f73:	68 48 04 03 c0       	push   $0xc0030448
c0022f78:	68 26 01 00 00       	push   $0x126
c0022f7d:	68 00 03 03 c0       	push   $0xc0030300
c0022f82:	e8 e7 67 00 00       	call   c002976e <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022f87:	83 ec 0c             	sub    $0xc,%esp
c0022f8a:	ff 75 0c             	pushl  0xc(%ebp)
c0022f8d:	e8 f3 fe ff ff       	call   c0022e85 <lock_held_by_current_thread>
c0022f92:	83 c4 10             	add    $0x10,%esp
c0022f95:	84 c0                	test   %al,%al
c0022f97:	75 21                	jne    c0022fba <cond_wait+0xb4>
c0022f99:	83 ec 0c             	sub    $0xc,%esp
c0022f9c:	68 80 03 03 c0       	push   $0xc0030380
c0022fa1:	68 e9 02 03 c0       	push   $0xc00302e9
c0022fa6:	68 48 04 03 c0       	push   $0xc0030448
c0022fab:	68 27 01 00 00       	push   $0x127
c0022fb0:	68 00 03 03 c0       	push   $0xc0030300
c0022fb5:	e8 b4 67 00 00       	call   c002976e <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0022fba:	83 ec 08             	sub    $0x8,%esp
c0022fbd:	6a 00                	push   $0x0
c0022fbf:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022fc2:	83 c0 08             	add    $0x8,%eax
c0022fc5:	50                   	push   %eax
c0022fc6:	e8 f7 f9 ff ff       	call   c00229c2 <sema_init>
c0022fcb:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c0022fce:	8b 45 08             	mov    0x8(%ebp),%eax
c0022fd1:	83 ec 08             	sub    $0x8,%esp
c0022fd4:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0022fd7:	52                   	push   %edx
c0022fd8:	50                   	push   %eax
c0022fd9:	e8 e1 6d 00 00       	call   c0029dbf <list_push_back>
c0022fde:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0022fe1:	83 ec 0c             	sub    $0xc,%esp
c0022fe4:	ff 75 0c             	pushl  0xc(%ebp)
c0022fe7:	e8 1b fe ff ff       	call   c0022e07 <lock_release>
c0022fec:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0022fef:	83 ec 0c             	sub    $0xc,%esp
c0022ff2:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022ff5:	83 c0 08             	add    $0x8,%eax
c0022ff8:	50                   	push   %eax
c0022ff9:	e8 0b fa ff ff       	call   c0022a09 <sema_down>
c0022ffe:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0023001:	83 ec 0c             	sub    $0xc,%esp
c0023004:	ff 75 0c             	pushl  0xc(%ebp)
c0023007:	e8 bb fc ff ff       	call   c0022cc7 <lock_acquire>
c002300c:	83 c4 10             	add    $0x10,%esp
}
c002300f:	90                   	nop
c0023010:	c9                   	leave  
c0023011:	c3                   	ret    

c0023012 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0023012:	55                   	push   %ebp
c0023013:	89 e5                	mov    %esp,%ebp
c0023015:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0023018:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002301c:	75 21                	jne    c002303f <cond_signal+0x2d>
c002301e:	83 ec 0c             	sub    $0xc,%esp
c0023021:	68 a3 03 03 c0       	push   $0xc00303a3
c0023026:	68 e9 02 03 c0       	push   $0xc00302e9
c002302b:	68 54 04 03 c0       	push   $0xc0030454
c0023030:	68 3a 01 00 00       	push   $0x13a
c0023035:	68 00 03 03 c0       	push   $0xc0030300
c002303a:	e8 2f 67 00 00       	call   c002976e <debug_panic>
  ASSERT (lock != NULL);
c002303f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023043:	75 21                	jne    c0023066 <cond_signal+0x54>
c0023045:	83 ec 0c             	sub    $0xc,%esp
c0023048:	68 4d 03 03 c0       	push   $0xc003034d
c002304d:	68 e9 02 03 c0       	push   $0xc00302e9
c0023052:	68 54 04 03 c0       	push   $0xc0030454
c0023057:	68 3b 01 00 00       	push   $0x13b
c002305c:	68 00 03 03 c0       	push   $0xc0030300
c0023061:	e8 08 67 00 00       	call   c002976e <debug_panic>
  ASSERT (!intr_context ());
c0023066:	e8 25 e8 ff ff       	call   c0021890 <intr_context>
c002306b:	83 f0 01             	xor    $0x1,%eax
c002306e:	84 c0                	test   %al,%al
c0023070:	75 21                	jne    c0023093 <cond_signal+0x81>
c0023072:	83 ec 0c             	sub    $0xc,%esp
c0023075:	68 16 03 03 c0       	push   $0xc0030316
c002307a:	68 e9 02 03 c0       	push   $0xc00302e9
c002307f:	68 54 04 03 c0       	push   $0xc0030454
c0023084:	68 3c 01 00 00       	push   $0x13c
c0023089:	68 00 03 03 c0       	push   $0xc0030300
c002308e:	e8 db 66 00 00       	call   c002976e <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023093:	83 ec 0c             	sub    $0xc,%esp
c0023096:	ff 75 0c             	pushl  0xc(%ebp)
c0023099:	e8 e7 fd ff ff       	call   c0022e85 <lock_held_by_current_thread>
c002309e:	83 c4 10             	add    $0x10,%esp
c00230a1:	84 c0                	test   %al,%al
c00230a3:	75 21                	jne    c00230c6 <cond_signal+0xb4>
c00230a5:	83 ec 0c             	sub    $0xc,%esp
c00230a8:	68 80 03 03 c0       	push   $0xc0030380
c00230ad:	68 e9 02 03 c0       	push   $0xc00302e9
c00230b2:	68 54 04 03 c0       	push   $0xc0030454
c00230b7:	68 3d 01 00 00       	push   $0x13d
c00230bc:	68 00 03 03 c0       	push   $0xc0030300
c00230c1:	e8 a8 66 00 00       	call   c002976e <debug_panic>

  if (!list_empty (&cond->waiters)) 
c00230c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00230c9:	83 ec 0c             	sub    $0xc,%esp
c00230cc:	50                   	push   %eax
c00230cd:	e8 94 6e 00 00       	call   c0029f66 <list_empty>
c00230d2:	83 c4 10             	add    $0x10,%esp
c00230d5:	83 f0 01             	xor    $0x1,%eax
c00230d8:	84 c0                	test   %al,%al
c00230da:	74 24                	je     c0023100 <cond_signal+0xee>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c00230dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00230df:	83 ec 0c             	sub    $0xc,%esp
c00230e2:	50                   	push   %eax
c00230e3:	e8 56 6d 00 00       	call   c0029e3e <list_pop_front>
c00230e8:	83 c4 10             	add    $0x10,%esp
c00230eb:	83 c0 04             	add    $0x4,%eax
c00230ee:	83 e8 04             	sub    $0x4,%eax
c00230f1:	83 c0 08             	add    $0x8,%eax
c00230f4:	83 ec 0c             	sub    $0xc,%esp
c00230f7:	50                   	push   %eax
c00230f8:	e8 16 fa ff ff       	call   c0022b13 <sema_up>
c00230fd:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c0023100:	90                   	nop
c0023101:	c9                   	leave  
c0023102:	c3                   	ret    

c0023103 <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0023103:	55                   	push   %ebp
c0023104:	89 e5                	mov    %esp,%ebp
c0023106:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0023109:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002310d:	75 21                	jne    c0023130 <cond_broadcast+0x2d>
c002310f:	83 ec 0c             	sub    $0xc,%esp
c0023112:	68 a3 03 03 c0       	push   $0xc00303a3
c0023117:	68 e9 02 03 c0       	push   $0xc00302e9
c002311c:	68 60 04 03 c0       	push   $0xc0030460
c0023121:	68 4d 01 00 00       	push   $0x14d
c0023126:	68 00 03 03 c0       	push   $0xc0030300
c002312b:	e8 3e 66 00 00       	call   c002976e <debug_panic>
  ASSERT (lock != NULL);
c0023130:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023134:	75 32                	jne    c0023168 <cond_broadcast+0x65>
c0023136:	83 ec 0c             	sub    $0xc,%esp
c0023139:	68 4d 03 03 c0       	push   $0xc003034d
c002313e:	68 e9 02 03 c0       	push   $0xc00302e9
c0023143:	68 60 04 03 c0       	push   $0xc0030460
c0023148:	68 4e 01 00 00       	push   $0x14e
c002314d:	68 00 03 03 c0       	push   $0xc0030300
c0023152:	e8 17 66 00 00       	call   c002976e <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0023157:	83 ec 08             	sub    $0x8,%esp
c002315a:	ff 75 0c             	pushl  0xc(%ebp)
c002315d:	ff 75 08             	pushl  0x8(%ebp)
c0023160:	e8 ad fe ff ff       	call   c0023012 <cond_signal>
c0023165:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c0023168:	8b 45 08             	mov    0x8(%ebp),%eax
c002316b:	83 ec 0c             	sub    $0xc,%esp
c002316e:	50                   	push   %eax
c002316f:	e8 f2 6d 00 00       	call   c0029f66 <list_empty>
c0023174:	83 c4 10             	add    $0x10,%esp
c0023177:	83 f0 01             	xor    $0x1,%eax
c002317a:	84 c0                	test   %al,%al
c002317c:	75 d9                	jne    c0023157 <cond_broadcast+0x54>
}
c002317e:	90                   	nop
c002317f:	c9                   	leave  
c0023180:	c3                   	ret    

c0023181 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c0023181:	55                   	push   %ebp
c0023182:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0023184:	8b 45 08             	mov    0x8(%ebp),%eax
c0023187:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002318c:	5d                   	pop    %ebp
c002318d:	c3                   	ret    

c002318e <pg_no>:
static inline uintptr_t pg_no (const void *va) {
c002318e:	55                   	push   %ebp
c002318f:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c0023191:	8b 45 08             	mov    0x8(%ebp),%eax
c0023194:	c1 e8 0c             	shr    $0xc,%eax
}
c0023197:	5d                   	pop    %ebp
c0023198:	c3                   	ret    

c0023199 <ptov>:
{
c0023199:	55                   	push   %ebp
c002319a:	89 e5                	mov    %esp,%ebp
c002319c:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c002319f:	8b 45 08             	mov    0x8(%ebp),%eax
c00231a2:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00231a7:	76 1e                	jbe    c00231c7 <ptov+0x2e>
c00231a9:	83 ec 0c             	sub    $0xc,%esp
c00231ac:	68 70 04 03 c0       	push   $0xc0030470
c00231b1:	68 8b 04 03 c0       	push   $0xc003048b
c00231b6:	68 a8 05 03 c0       	push   $0xc00305a8
c00231bb:	6a 4a                	push   $0x4a
c00231bd:	68 a2 04 03 c0       	push   $0xc00304a2
c00231c2:	e8 a7 65 00 00       	call   c002976e <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c00231c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00231ca:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00231cf:	c9                   	leave  
c00231d0:	c3                   	ret    

c00231d1 <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c00231d1:	55                   	push   %ebp
c00231d2:	89 e5                	mov    %esp,%ebp
c00231d4:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c00231d7:	83 ec 0c             	sub    $0xc,%esp
c00231da:	68 00 00 10 00       	push   $0x100000
c00231df:	e8 b5 ff ff ff       	call   c0023199 <ptov>
c00231e4:	83 c4 10             	add    $0x10,%esp
c00231e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c00231ea:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00231ef:	c1 e0 0c             	shl    $0xc,%eax
c00231f2:	83 ec 0c             	sub    $0xc,%esp
c00231f5:	50                   	push   %eax
c00231f6:	e8 9e ff ff ff       	call   c0023199 <ptov>
c00231fb:	83 c4 10             	add    $0x10,%esp
c00231fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023201:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023204:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023207:	29 c2                	sub    %eax,%edx
c0023209:	89 d0                	mov    %edx,%eax
c002320b:	85 c0                	test   %eax,%eax
c002320d:	79 05                	jns    c0023214 <palloc_init+0x43>
c002320f:	05 ff 0f 00 00       	add    $0xfff,%eax
c0023214:	c1 f8 0c             	sar    $0xc,%eax
c0023217:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c002321a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002321d:	d1 e8                	shr    %eax
c002321f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c0023222:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023225:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023228:	76 06                	jbe    c0023230 <palloc_init+0x5f>
    user_pages = user_page_limit;
c002322a:	8b 45 08             	mov    0x8(%ebp),%eax
c002322d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c0023230:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023233:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0023236:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023239:	68 b8 04 03 c0       	push   $0xc00304b8
c002323e:	ff 75 e4             	pushl  -0x1c(%ebp)
c0023241:	ff 75 f0             	pushl  -0x10(%ebp)
c0023244:	68 40 9e 03 c0       	push   $0xc0039e40
c0023249:	e8 6e 02 00 00       	call   c00234bc <init_pool>
c002324e:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c0023251:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023254:	c1 e0 0c             	shl    $0xc,%eax
c0023257:	89 c2                	mov    %eax,%edx
c0023259:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002325c:	01 d0                	add    %edx,%eax
c002325e:	68 c4 04 03 c0       	push   $0xc00304c4
c0023263:	ff 75 f4             	pushl  -0xc(%ebp)
c0023266:	50                   	push   %eax
c0023267:	68 60 9e 03 c0       	push   $0xc0039e60
c002326c:	e8 4b 02 00 00       	call   c00234bc <init_pool>
c0023271:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c0023274:	90                   	nop
c0023275:	c9                   	leave  
c0023276:	c3                   	ret    

c0023277 <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c0023277:	55                   	push   %ebp
c0023278:	89 e5                	mov    %esp,%ebp
c002327a:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c002327d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023280:	83 e0 04             	and    $0x4,%eax
c0023283:	85 c0                	test   %eax,%eax
c0023285:	74 07                	je     c002328e <palloc_get_multiple+0x17>
c0023287:	b8 60 9e 03 c0       	mov    $0xc0039e60,%eax
c002328c:	eb 05                	jmp    c0023293 <palloc_get_multiple+0x1c>
c002328e:	b8 40 9e 03 c0       	mov    $0xc0039e40,%eax
c0023293:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c0023296:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002329a:	75 0a                	jne    c00232a6 <palloc_get_multiple+0x2f>
    return NULL;
c002329c:	b8 00 00 00 00       	mov    $0x0,%eax
c00232a1:	e9 a3 00 00 00       	jmp    c0023349 <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c00232a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00232a9:	83 ec 0c             	sub    $0xc,%esp
c00232ac:	50                   	push   %eax
c00232ad:	e8 15 fa ff ff       	call   c0022cc7 <lock_acquire>
c00232b2:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c00232b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00232b8:	8b 40 18             	mov    0x18(%eax),%eax
c00232bb:	6a 00                	push   $0x0
c00232bd:	ff 75 0c             	pushl  0xc(%ebp)
c00232c0:	6a 00                	push   $0x0
c00232c2:	50                   	push   %eax
c00232c3:	e8 fa 7b 00 00       	call   c002aec2 <bitmap_scan_and_flip>
c00232c8:	83 c4 10             	add    $0x10,%esp
c00232cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c00232ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00232d1:	83 ec 0c             	sub    $0xc,%esp
c00232d4:	50                   	push   %eax
c00232d5:	e8 2d fb ff ff       	call   c0022e07 <lock_release>
c00232da:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c00232dd:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00232e1:	74 13                	je     c00232f6 <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c00232e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00232e6:	8b 40 1c             	mov    0x1c(%eax),%eax
c00232e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00232ec:	c1 e2 0c             	shl    $0xc,%edx
c00232ef:	01 d0                	add    %edx,%eax
c00232f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00232f4:	eb 07                	jmp    c00232fd <palloc_get_multiple+0x86>
  else
    pages = NULL;
c00232f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c00232fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023301:	74 23                	je     c0023326 <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c0023303:	8b 45 08             	mov    0x8(%ebp),%eax
c0023306:	83 e0 02             	and    $0x2,%eax
c0023309:	85 c0                	test   %eax,%eax
c002330b:	74 39                	je     c0023346 <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c002330d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023310:	c1 e0 0c             	shl    $0xc,%eax
c0023313:	83 ec 04             	sub    $0x4,%esp
c0023316:	50                   	push   %eax
c0023317:	6a 00                	push   $0x0
c0023319:	ff 75 f4             	pushl  -0xc(%ebp)
c002331c:	e8 67 58 00 00       	call   c0028b88 <memset>
c0023321:	83 c4 10             	add    $0x10,%esp
c0023324:	eb 20                	jmp    c0023346 <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c0023326:	8b 45 08             	mov    0x8(%ebp),%eax
c0023329:	83 e0 01             	and    $0x1,%eax
c002332c:	85 c0                	test   %eax,%eax
c002332e:	74 16                	je     c0023346 <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c0023330:	68 ce 04 03 c0       	push   $0xc00304ce
c0023335:	68 b0 05 03 c0       	push   $0xc00305b0
c002333a:	6a 61                	push   $0x61
c002333c:	68 e7 04 03 c0       	push   $0xc00304e7
c0023341:	e8 28 64 00 00       	call   c002976e <debug_panic>
    }

  return pages;
c0023346:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023349:	c9                   	leave  
c002334a:	c3                   	ret    

c002334b <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c002334b:	55                   	push   %ebp
c002334c:	89 e5                	mov    %esp,%ebp
c002334e:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c0023351:	83 ec 08             	sub    $0x8,%esp
c0023354:	6a 01                	push   $0x1
c0023356:	ff 75 08             	pushl  0x8(%ebp)
c0023359:	e8 19 ff ff ff       	call   c0023277 <palloc_get_multiple>
c002335e:	83 c4 10             	add    $0x10,%esp
}
c0023361:	c9                   	leave  
c0023362:	c3                   	ret    

c0023363 <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c0023363:	55                   	push   %ebp
c0023364:	89 e5                	mov    %esp,%ebp
c0023366:	53                   	push   %ebx
c0023367:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c002336a:	ff 75 08             	pushl  0x8(%ebp)
c002336d:	e8 0f fe ff ff       	call   c0023181 <pg_ofs>
c0023372:	83 c4 04             	add    $0x4,%esp
c0023375:	85 c0                	test   %eax,%eax
c0023377:	74 1e                	je     c0023397 <palloc_free_multiple+0x34>
c0023379:	83 ec 0c             	sub    $0xc,%esp
c002337c:	68 fe 04 03 c0       	push   $0xc00304fe
c0023381:	68 8b 04 03 c0       	push   $0xc003048b
c0023386:	68 c4 05 03 c0       	push   $0xc00305c4
c002338b:	6a 7b                	push   $0x7b
c002338d:	68 e7 04 03 c0       	push   $0xc00304e7
c0023392:	e8 d7 63 00 00       	call   c002976e <debug_panic>
  if (pages == NULL || page_cnt == 0)
c0023397:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002339b:	0f 84 fc 00 00 00    	je     c002349d <palloc_free_multiple+0x13a>
c00233a1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00233a5:	0f 84 f2 00 00 00    	je     c002349d <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c00233ab:	83 ec 08             	sub    $0x8,%esp
c00233ae:	ff 75 08             	pushl  0x8(%ebp)
c00233b1:	68 40 9e 03 c0       	push   $0xc0039e40
c00233b6:	e8 a8 01 00 00       	call   c0023563 <page_from_pool>
c00233bb:	83 c4 10             	add    $0x10,%esp
c00233be:	84 c0                	test   %al,%al
c00233c0:	74 09                	je     c00233cb <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c00233c2:	c7 45 f4 40 9e 03 c0 	movl   $0xc0039e40,-0xc(%ebp)
c00233c9:	eb 39                	jmp    c0023404 <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c00233cb:	83 ec 08             	sub    $0x8,%esp
c00233ce:	ff 75 08             	pushl  0x8(%ebp)
c00233d1:	68 60 9e 03 c0       	push   $0xc0039e60
c00233d6:	e8 88 01 00 00       	call   c0023563 <page_from_pool>
c00233db:	83 c4 10             	add    $0x10,%esp
c00233de:	84 c0                	test   %al,%al
c00233e0:	74 09                	je     c00233eb <palloc_free_multiple+0x88>
    pool = &user_pool;
c00233e2:	c7 45 f4 60 9e 03 c0 	movl   $0xc0039e60,-0xc(%ebp)
c00233e9:	eb 19                	jmp    c0023404 <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c00233eb:	68 14 05 03 c0       	push   $0xc0030514
c00233f0:	68 c4 05 03 c0       	push   $0xc00305c4
c00233f5:	68 84 00 00 00       	push   $0x84
c00233fa:	68 e7 04 03 c0       	push   $0xc00304e7
c00233ff:	e8 6a 63 00 00       	call   c002976e <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c0023404:	83 ec 0c             	sub    $0xc,%esp
c0023407:	ff 75 08             	pushl  0x8(%ebp)
c002340a:	e8 7f fd ff ff       	call   c002318e <pg_no>
c002340f:	83 c4 10             	add    $0x10,%esp
c0023412:	89 c3                	mov    %eax,%ebx
c0023414:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023417:	8b 40 1c             	mov    0x1c(%eax),%eax
c002341a:	83 ec 0c             	sub    $0xc,%esp
c002341d:	50                   	push   %eax
c002341e:	e8 6b fd ff ff       	call   c002318e <pg_no>
c0023423:	83 c4 10             	add    $0x10,%esp
c0023426:	29 c3                	sub    %eax,%ebx
c0023428:	89 d8                	mov    %ebx,%eax
c002342a:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c002342d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023430:	c1 e0 0c             	shl    $0xc,%eax
c0023433:	83 ec 04             	sub    $0x4,%esp
c0023436:	50                   	push   %eax
c0023437:	68 cc 00 00 00       	push   $0xcc
c002343c:	ff 75 08             	pushl  0x8(%ebp)
c002343f:	e8 44 57 00 00       	call   c0028b88 <memset>
c0023444:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023447:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002344a:	8b 40 18             	mov    0x18(%eax),%eax
c002344d:	83 ec 04             	sub    $0x4,%esp
c0023450:	ff 75 0c             	pushl  0xc(%ebp)
c0023453:	ff 75 f0             	pushl  -0x10(%ebp)
c0023456:	50                   	push   %eax
c0023457:	e8 7a 79 00 00       	call   c002add6 <bitmap_all>
c002345c:	83 c4 10             	add    $0x10,%esp
c002345f:	84 c0                	test   %al,%al
c0023461:	75 21                	jne    c0023484 <palloc_free_multiple+0x121>
c0023463:	83 ec 0c             	sub    $0xc,%esp
c0023466:	68 38 05 03 c0       	push   $0xc0030538
c002346b:	68 8b 04 03 c0       	push   $0xc003048b
c0023470:	68 c4 05 03 c0       	push   $0xc00305c4
c0023475:	68 8c 00 00 00       	push   $0x8c
c002347a:	68 e7 04 03 c0       	push   $0xc00304e7
c002347f:	e8 ea 62 00 00       	call   c002976e <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c0023484:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023487:	8b 40 18             	mov    0x18(%eax),%eax
c002348a:	6a 00                	push   $0x0
c002348c:	ff 75 0c             	pushl  0xc(%ebp)
c002348f:	ff 75 f0             	pushl  -0x10(%ebp)
c0023492:	50                   	push   %eax
c0023493:	e8 9d 76 00 00       	call   c002ab35 <bitmap_set_multiple>
c0023498:	83 c4 10             	add    $0x10,%esp
c002349b:	eb 01                	jmp    c002349e <palloc_free_multiple+0x13b>
    return;
c002349d:	90                   	nop
}
c002349e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00234a1:	c9                   	leave  
c00234a2:	c3                   	ret    

c00234a3 <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c00234a3:	55                   	push   %ebp
c00234a4:	89 e5                	mov    %esp,%ebp
c00234a6:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c00234a9:	83 ec 08             	sub    $0x8,%esp
c00234ac:	6a 01                	push   $0x1
c00234ae:	ff 75 08             	pushl  0x8(%ebp)
c00234b1:	e8 ad fe ff ff       	call   c0023363 <palloc_free_multiple>
c00234b6:	83 c4 10             	add    $0x10,%esp
}
c00234b9:	90                   	nop
c00234ba:	c9                   	leave  
c00234bb:	c3                   	ret    

c00234bc <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c00234bc:	55                   	push   %ebp
c00234bd:	89 e5                	mov    %esp,%ebp
c00234bf:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c00234c2:	83 ec 0c             	sub    $0xc,%esp
c00234c5:	ff 75 10             	pushl  0x10(%ebp)
c00234c8:	e8 fe 73 00 00       	call   c002a8cb <bitmap_buf_size>
c00234cd:	83 c4 10             	add    $0x10,%esp
c00234d0:	05 ff 0f 00 00       	add    $0xfff,%eax
c00234d5:	c1 e8 0c             	shr    $0xc,%eax
c00234d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c00234db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00234de:	3b 45 10             	cmp    0x10(%ebp),%eax
c00234e1:	76 1f                	jbe    c0023502 <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c00234e3:	83 ec 0c             	sub    $0xc,%esp
c00234e6:	ff 75 14             	pushl  0x14(%ebp)
c00234e9:	68 68 05 03 c0       	push   $0xc0030568
c00234ee:	68 dc 05 03 c0       	push   $0xc00305dc
c00234f3:	68 a1 00 00 00       	push   $0xa1
c00234f8:	68 e7 04 03 c0       	push   $0xc00304e7
c00234fd:	e8 6c 62 00 00       	call   c002976e <debug_panic>
  page_cnt -= bm_pages;
c0023502:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023505:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c0023508:	83 ec 04             	sub    $0x4,%esp
c002350b:	ff 75 14             	pushl  0x14(%ebp)
c002350e:	ff 75 10             	pushl  0x10(%ebp)
c0023511:	68 8c 05 03 c0       	push   $0xc003058c
c0023516:	e8 94 3e 00 00       	call   c00273af <printf>
c002351b:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c002351e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023521:	83 ec 0c             	sub    $0xc,%esp
c0023524:	50                   	push   %eax
c0023525:	e8 50 f7 ff ff       	call   c0022c7a <lock_init>
c002352a:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c002352d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023530:	c1 e0 0c             	shl    $0xc,%eax
c0023533:	83 ec 04             	sub    $0x4,%esp
c0023536:	50                   	push   %eax
c0023537:	ff 75 0c             	pushl  0xc(%ebp)
c002353a:	ff 75 10             	pushl  0x10(%ebp)
c002353d:	e8 23 73 00 00       	call   c002a865 <bitmap_create_in_buf>
c0023542:	83 c4 10             	add    $0x10,%esp
c0023545:	89 c2                	mov    %eax,%edx
c0023547:	8b 45 08             	mov    0x8(%ebp),%eax
c002354a:	89 50 18             	mov    %edx,0x18(%eax)
  p->base = base + bm_pages * PGSIZE;
c002354d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023550:	c1 e0 0c             	shl    $0xc,%eax
c0023553:	89 c2                	mov    %eax,%edx
c0023555:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023558:	01 c2                	add    %eax,%edx
c002355a:	8b 45 08             	mov    0x8(%ebp),%eax
c002355d:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c0023560:	90                   	nop
c0023561:	c9                   	leave  
c0023562:	c3                   	ret    

c0023563 <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c0023563:	55                   	push   %ebp
c0023564:	89 e5                	mov    %esp,%ebp
c0023566:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c0023569:	ff 75 0c             	pushl  0xc(%ebp)
c002356c:	e8 1d fc ff ff       	call   c002318e <pg_no>
c0023571:	83 c4 04             	add    $0x4,%esp
c0023574:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c0023577:	8b 45 08             	mov    0x8(%ebp),%eax
c002357a:	8b 40 1c             	mov    0x1c(%eax),%eax
c002357d:	50                   	push   %eax
c002357e:	e8 0b fc ff ff       	call   c002318e <pg_no>
c0023583:	83 c4 04             	add    $0x4,%esp
c0023586:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023589:	8b 45 08             	mov    0x8(%ebp),%eax
c002358c:	8b 40 18             	mov    0x18(%eax),%eax
c002358f:	83 ec 0c             	sub    $0xc,%esp
c0023592:	50                   	push   %eax
c0023593:	e8 75 73 00 00       	call   c002a90d <bitmap_size>
c0023598:	83 c4 10             	add    $0x10,%esp
c002359b:	89 c2                	mov    %eax,%edx
c002359d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00235a0:	01 d0                	add    %edx,%eax
c00235a2:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c00235a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00235ab:	72 0f                	jb     c00235bc <page_from_pool+0x59>
c00235ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235b0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00235b3:	73 07                	jae    c00235bc <page_from_pool+0x59>
c00235b5:	b8 01 00 00 00       	mov    $0x1,%eax
c00235ba:	eb 05                	jmp    c00235c1 <page_from_pool+0x5e>
c00235bc:	b8 00 00 00 00       	mov    $0x0,%eax
c00235c1:	83 e0 01             	and    $0x1,%eax
}
c00235c4:	c9                   	leave  
c00235c5:	c3                   	ret    

c00235c6 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c00235c6:	55                   	push   %ebp
c00235c7:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c00235c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00235cc:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c00235d1:	5d                   	pop    %ebp
c00235d2:	c3                   	ret    

c00235d3 <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c00235d3:	55                   	push   %ebp
c00235d4:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00235d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00235d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00235de:	5d                   	pop    %ebp
c00235df:	c3                   	ret    

c00235e0 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c00235e0:	55                   	push   %ebp
c00235e1:	89 e5                	mov    %esp,%ebp
c00235e3:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00235e6:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c00235ed:	e9 90 00 00 00       	jmp    c0023682 <malloc_init+0xa2>
    {
      struct desc *d = &descs[desc_cnt++];
c00235f2:	8b 15 60 a0 03 c0    	mov    0xc003a060,%edx
c00235f8:	8d 42 01             	lea    0x1(%edx),%eax
c00235fb:	a3 60 a0 03 c0       	mov    %eax,0xc003a060
c0023600:	89 d0                	mov    %edx,%eax
c0023602:	01 c0                	add    %eax,%eax
c0023604:	01 d0                	add    %edx,%eax
c0023606:	c1 e0 04             	shl    $0x4,%eax
c0023609:	05 80 9e 03 c0       	add    $0xc0039e80,%eax
c002360e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c0023611:	a1 60 a0 03 c0       	mov    0xc003a060,%eax
c0023616:	83 f8 0a             	cmp    $0xa,%eax
c0023619:	76 1e                	jbe    c0023639 <malloc_init+0x59>
c002361b:	83 ec 0c             	sub    $0xc,%esp
c002361e:	68 e8 05 03 c0       	push   $0xc00305e8
c0023623:	68 11 06 03 c0       	push   $0xc0030611
c0023628:	68 1c 07 03 c0       	push   $0xc003071c
c002362d:	6a 4f                	push   $0x4f
c002362f:	68 28 06 03 c0       	push   $0xc0030628
c0023634:	e8 35 61 00 00       	call   c002976e <debug_panic>
      d->block_size = block_size;
c0023639:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002363c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002363f:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023641:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0023646:	ba 00 00 00 00       	mov    $0x0,%edx
c002364b:	f7 75 f4             	divl   -0xc(%ebp)
c002364e:	89 c2                	mov    %eax,%edx
c0023650:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023653:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c0023656:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023659:	83 c0 08             	add    $0x8,%eax
c002365c:	83 ec 0c             	sub    $0xc,%esp
c002365f:	50                   	push   %eax
c0023660:	e8 7a 63 00 00       	call   c00299df <list_init>
c0023665:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c0023668:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002366b:	83 c0 18             	add    $0x18,%eax
c002366e:	83 ec 0c             	sub    $0xc,%esp
c0023671:	50                   	push   %eax
c0023672:	e8 03 f6 ff ff       	call   c0022c7a <lock_init>
c0023677:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002367a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002367d:	01 c0                	add    %eax,%eax
c002367f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023682:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023689:	0f 86 63 ff ff ff    	jbe    c00235f2 <malloc_init+0x12>
    }
}
c002368f:	90                   	nop
c0023690:	c9                   	leave  
c0023691:	c3                   	ret    

c0023692 <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c0023692:	55                   	push   %ebp
c0023693:	89 e5                	mov    %esp,%ebp
c0023695:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023698:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002369c:	75 0a                	jne    c00236a8 <malloc+0x16>
    return NULL;
c002369e:	b8 00 00 00 00       	mov    $0x0,%eax
c00236a3:	e9 b1 01 00 00       	jmp    c0023859 <malloc+0x1c7>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c00236a8:	c7 45 f4 80 9e 03 c0 	movl   $0xc0039e80,-0xc(%ebp)
c00236af:	eb 0e                	jmp    c00236bf <malloc+0x2d>
    if (d->block_size >= size)
c00236b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00236b4:	8b 00                	mov    (%eax),%eax
c00236b6:	3b 45 08             	cmp    0x8(%ebp),%eax
c00236b9:	73 1f                	jae    c00236da <malloc+0x48>
  for (d = descs; d < descs + desc_cnt; d++)
c00236bb:	83 45 f4 30          	addl   $0x30,-0xc(%ebp)
c00236bf:	8b 15 60 a0 03 c0    	mov    0xc003a060,%edx
c00236c5:	89 d0                	mov    %edx,%eax
c00236c7:	01 c0                	add    %eax,%eax
c00236c9:	01 d0                	add    %edx,%eax
c00236cb:	c1 e0 04             	shl    $0x4,%eax
c00236ce:	05 80 9e 03 c0       	add    $0xc0039e80,%eax
c00236d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00236d6:	77 d9                	ja     c00236b1 <malloc+0x1f>
c00236d8:	eb 01                	jmp    c00236db <malloc+0x49>
      break;
c00236da:	90                   	nop
  if (d == descs + desc_cnt) 
c00236db:	8b 15 60 a0 03 c0    	mov    0xc003a060,%edx
c00236e1:	89 d0                	mov    %edx,%eax
c00236e3:	01 c0                	add    %eax,%eax
c00236e5:	01 d0                	add    %edx,%eax
c00236e7:	c1 e0 04             	shl    $0x4,%eax
c00236ea:	05 80 9e 03 c0       	add    $0xc0039e80,%eax
c00236ef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00236f2:	75 58                	jne    c002374c <malloc+0xba>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00236f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00236f7:	05 0b 10 00 00       	add    $0x100b,%eax
c00236fc:	c1 e8 0c             	shr    $0xc,%eax
c00236ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c0023702:	83 ec 08             	sub    $0x8,%esp
c0023705:	ff 75 ec             	pushl  -0x14(%ebp)
c0023708:	6a 00                	push   $0x0
c002370a:	e8 68 fb ff ff       	call   c0023277 <palloc_get_multiple>
c002370f:	83 c4 10             	add    $0x10,%esp
c0023712:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL)
c0023715:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023719:	75 0a                	jne    c0023725 <malloc+0x93>
        return NULL;
c002371b:	b8 00 00 00 00       	mov    $0x0,%eax
c0023720:	e9 34 01 00 00       	jmp    c0023859 <malloc+0x1c7>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c0023725:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023728:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c002372e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023731:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023738:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002373b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002373e:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c0023741:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023744:	83 c0 0c             	add    $0xc,%eax
c0023747:	e9 0d 01 00 00       	jmp    c0023859 <malloc+0x1c7>
    }

  lock_acquire (&d->lock);
c002374c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002374f:	83 c0 18             	add    $0x18,%eax
c0023752:	83 ec 0c             	sub    $0xc,%esp
c0023755:	50                   	push   %eax
c0023756:	e8 6c f5 ff ff       	call   c0022cc7 <lock_acquire>
c002375b:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c002375e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023761:	83 c0 08             	add    $0x8,%eax
c0023764:	83 ec 0c             	sub    $0xc,%esp
c0023767:	50                   	push   %eax
c0023768:	e8 f9 67 00 00       	call   c0029f66 <list_empty>
c002376d:	83 c4 10             	add    $0x10,%esp
c0023770:	84 c0                	test   %al,%al
c0023772:	0f 84 91 00 00 00    	je     c0023809 <malloc+0x177>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023778:	83 ec 0c             	sub    $0xc,%esp
c002377b:	6a 00                	push   $0x0
c002377d:	e8 c9 fb ff ff       	call   c002334b <palloc_get_page>
c0023782:	83 c4 10             	add    $0x10,%esp
c0023785:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL) 
c0023788:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002378c:	75 1c                	jne    c00237aa <malloc+0x118>
        {
          lock_release (&d->lock);
c002378e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023791:	83 c0 18             	add    $0x18,%eax
c0023794:	83 ec 0c             	sub    $0xc,%esp
c0023797:	50                   	push   %eax
c0023798:	e8 6a f6 ff ff       	call   c0022e07 <lock_release>
c002379d:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c00237a0:	b8 00 00 00 00       	mov    $0x0,%eax
c00237a5:	e9 af 00 00 00       	jmp    c0023859 <malloc+0x1c7>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c00237aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237ad:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c00237b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00237b9:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c00237bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00237bf:	8b 50 04             	mov    0x4(%eax),%edx
c00237c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237c5:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c00237c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00237cf:	eb 2d                	jmp    c00237fe <malloc+0x16c>
        {
          struct block *b = arena_to_block (a, i);
c00237d1:	83 ec 08             	sub    $0x8,%esp
c00237d4:	ff 75 f0             	pushl  -0x10(%ebp)
c00237d7:	ff 75 e8             	pushl  -0x18(%ebp)
c00237da:	e8 ea 03 00 00       	call   c0023bc9 <arena_to_block>
c00237df:	83 c4 10             	add    $0x10,%esp
c00237e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c00237e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00237e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00237eb:	83 c2 08             	add    $0x8,%edx
c00237ee:	83 ec 08             	sub    $0x8,%esp
c00237f1:	50                   	push   %eax
c00237f2:	52                   	push   %edx
c00237f3:	e8 c7 65 00 00       	call   c0029dbf <list_push_back>
c00237f8:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < d->blocks_per_arena; i++) 
c00237fb:	ff 45 f0             	incl   -0x10(%ebp)
c00237fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023801:	8b 40 04             	mov    0x4(%eax),%eax
c0023804:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023807:	77 c8                	ja     c00237d1 <malloc+0x13f>
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023809:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002380c:	83 c0 08             	add    $0x8,%eax
c002380f:	83 ec 0c             	sub    $0xc,%esp
c0023812:	50                   	push   %eax
c0023813:	e8 26 66 00 00       	call   c0029e3e <list_pop_front>
c0023818:	83 c4 10             	add    $0x10,%esp
c002381b:	83 c0 04             	add    $0x4,%eax
c002381e:	83 e8 04             	sub    $0x4,%eax
c0023821:	89 45 e0             	mov    %eax,-0x20(%ebp)
  a = block_to_arena (b);
c0023824:	83 ec 0c             	sub    $0xc,%esp
c0023827:	ff 75 e0             	pushl  -0x20(%ebp)
c002382a:	e8 9c 02 00 00       	call   c0023acb <block_to_arena>
c002382f:	83 c4 10             	add    $0x10,%esp
c0023832:	89 45 e8             	mov    %eax,-0x18(%ebp)
  a->free_cnt--;
c0023835:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023838:	8b 40 08             	mov    0x8(%eax),%eax
c002383b:	8d 50 ff             	lea    -0x1(%eax),%edx
c002383e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023841:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c0023844:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023847:	83 c0 18             	add    $0x18,%eax
c002384a:	83 ec 0c             	sub    $0xc,%esp
c002384d:	50                   	push   %eax
c002384e:	e8 b4 f5 ff ff       	call   c0022e07 <lock_release>
c0023853:	83 c4 10             	add    $0x10,%esp
  return b;
c0023856:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c0023859:	c9                   	leave  
c002385a:	c3                   	ret    

c002385b <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c002385b:	55                   	push   %ebp
c002385c:	89 e5                	mov    %esp,%ebp
c002385e:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c0023861:	8b 45 08             	mov    0x8(%ebp),%eax
c0023864:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023868:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c002386b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002386e:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023871:	72 08                	jb     c002387b <calloc+0x20>
c0023873:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023876:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023879:	73 07                	jae    c0023882 <calloc+0x27>
    return NULL;
c002387b:	b8 00 00 00 00       	mov    $0x0,%eax
c0023880:	eb 2d                	jmp    c00238af <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c0023882:	83 ec 0c             	sub    $0xc,%esp
c0023885:	ff 75 f4             	pushl  -0xc(%ebp)
c0023888:	e8 05 fe ff ff       	call   c0023692 <malloc>
c002388d:	83 c4 10             	add    $0x10,%esp
c0023890:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c0023893:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023897:	74 13                	je     c00238ac <calloc+0x51>
    memset (p, 0, size);
c0023899:	83 ec 04             	sub    $0x4,%esp
c002389c:	ff 75 f4             	pushl  -0xc(%ebp)
c002389f:	6a 00                	push   $0x0
c00238a1:	ff 75 f0             	pushl  -0x10(%ebp)
c00238a4:	e8 df 52 00 00       	call   c0028b88 <memset>
c00238a9:	83 c4 10             	add    $0x10,%esp

  return p;
c00238ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00238af:	c9                   	leave  
c00238b0:	c3                   	ret    

c00238b1 <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c00238b1:	55                   	push   %ebp
c00238b2:	89 e5                	mov    %esp,%ebp
c00238b4:	53                   	push   %ebx
c00238b5:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c00238b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00238bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c00238be:	83 ec 0c             	sub    $0xc,%esp
c00238c1:	ff 75 f4             	pushl  -0xc(%ebp)
c00238c4:	e8 02 02 00 00       	call   c0023acb <block_to_arena>
c00238c9:	83 c4 10             	add    $0x10,%esp
c00238cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c00238cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00238d2:	8b 40 04             	mov    0x4(%eax),%eax
c00238d5:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c00238d8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00238dc:	74 07                	je     c00238e5 <block_size+0x34>
c00238de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00238e1:	8b 00                	mov    (%eax),%eax
c00238e3:	eb 1d                	jmp    c0023902 <block_size+0x51>
c00238e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00238e8:	8b 40 08             	mov    0x8(%eax),%eax
c00238eb:	c1 e0 0c             	shl    $0xc,%eax
c00238ee:	89 c3                	mov    %eax,%ebx
c00238f0:	83 ec 0c             	sub    $0xc,%esp
c00238f3:	ff 75 08             	pushl  0x8(%ebp)
c00238f6:	e8 cb fc ff ff       	call   c00235c6 <pg_ofs>
c00238fb:	83 c4 10             	add    $0x10,%esp
c00238fe:	29 c3                	sub    %eax,%ebx
c0023900:	89 d8                	mov    %ebx,%eax
}
c0023902:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023905:	c9                   	leave  
c0023906:	c3                   	ret    

c0023907 <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c0023907:	55                   	push   %ebp
c0023908:	89 e5                	mov    %esp,%ebp
c002390a:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c002390d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023911:	75 15                	jne    c0023928 <realloc+0x21>
    {
      free (old_block);
c0023913:	83 ec 0c             	sub    $0xc,%esp
c0023916:	ff 75 08             	pushl  0x8(%ebp)
c0023919:	e8 6e 00 00 00       	call   c002398c <free>
c002391e:	83 c4 10             	add    $0x10,%esp
      return NULL;
c0023921:	b8 00 00 00 00       	mov    $0x0,%eax
c0023926:	eb 62                	jmp    c002398a <realloc+0x83>
    }
  else 
    {
      void *new_block = malloc (new_size);
c0023928:	83 ec 0c             	sub    $0xc,%esp
c002392b:	ff 75 0c             	pushl  0xc(%ebp)
c002392e:	e8 5f fd ff ff       	call   c0023692 <malloc>
c0023933:	83 c4 10             	add    $0x10,%esp
c0023936:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c0023939:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002393d:	74 48                	je     c0023987 <realloc+0x80>
c002393f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023943:	74 42                	je     c0023987 <realloc+0x80>
        {
          size_t old_size = block_size (old_block);
c0023945:	83 ec 0c             	sub    $0xc,%esp
c0023948:	ff 75 08             	pushl  0x8(%ebp)
c002394b:	e8 61 ff ff ff       	call   c00238b1 <block_size>
c0023950:	83 c4 10             	add    $0x10,%esp
c0023953:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023956:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023959:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002395c:	39 d0                	cmp    %edx,%eax
c002395e:	76 02                	jbe    c0023962 <realloc+0x5b>
c0023960:	89 d0                	mov    %edx,%eax
c0023962:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c0023965:	83 ec 04             	sub    $0x4,%esp
c0023968:	ff 75 ec             	pushl  -0x14(%ebp)
c002396b:	ff 75 08             	pushl  0x8(%ebp)
c002396e:	ff 75 f4             	pushl  -0xc(%ebp)
c0023971:	e8 38 4c 00 00       	call   c00285ae <memcpy>
c0023976:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0023979:	83 ec 0c             	sub    $0xc,%esp
c002397c:	ff 75 08             	pushl  0x8(%ebp)
c002397f:	e8 08 00 00 00       	call   c002398c <free>
c0023984:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0023987:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c002398a:	c9                   	leave  
c002398b:	c3                   	ret    

c002398c <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c002398c:	55                   	push   %ebp
c002398d:	89 e5                	mov    %esp,%ebp
c002398f:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c0023992:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023996:	0f 84 2d 01 00 00    	je     c0023ac9 <free+0x13d>
    {
      struct block *b = p;
c002399c:	8b 45 08             	mov    0x8(%ebp),%eax
c002399f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c00239a2:	83 ec 0c             	sub    $0xc,%esp
c00239a5:	ff 75 f0             	pushl  -0x10(%ebp)
c00239a8:	e8 1e 01 00 00       	call   c0023acb <block_to_arena>
c00239ad:	83 c4 10             	add    $0x10,%esp
c00239b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c00239b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00239b6:	8b 40 04             	mov    0x4(%eax),%eax
c00239b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c00239bc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00239c0:	0f 84 ed 00 00 00    	je     c0023ab3 <free+0x127>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c00239c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00239c9:	8b 00                	mov    (%eax),%eax
c00239cb:	83 ec 04             	sub    $0x4,%esp
c00239ce:	50                   	push   %eax
c00239cf:	68 cc 00 00 00       	push   $0xcc
c00239d4:	ff 75 f0             	pushl  -0x10(%ebp)
c00239d7:	e8 ac 51 00 00       	call   c0028b88 <memset>
c00239dc:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c00239df:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00239e2:	83 c0 18             	add    $0x18,%eax
c00239e5:	83 ec 0c             	sub    $0xc,%esp
c00239e8:	50                   	push   %eax
c00239e9:	e8 d9 f2 ff ff       	call   c0022cc7 <lock_acquire>
c00239ee:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c00239f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00239f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00239f7:	83 c2 08             	add    $0x8,%edx
c00239fa:	83 ec 08             	sub    $0x8,%esp
c00239fd:	50                   	push   %eax
c00239fe:	52                   	push   %edx
c00239ff:	e8 95 63 00 00       	call   c0029d99 <list_push_front>
c0023a04:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c0023a07:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023a0a:	8b 40 08             	mov    0x8(%eax),%eax
c0023a0d:	8d 50 01             	lea    0x1(%eax),%edx
c0023a10:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023a13:	89 50 08             	mov    %edx,0x8(%eax)
c0023a16:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023a19:	8b 50 08             	mov    0x8(%eax),%edx
c0023a1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a1f:	8b 40 04             	mov    0x4(%eax),%eax
c0023a22:	39 c2                	cmp    %eax,%edx
c0023a24:	72 79                	jb     c0023a9f <free+0x113>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023a26:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023a29:	8b 50 08             	mov    0x8(%eax),%edx
c0023a2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a2f:	8b 40 04             	mov    0x4(%eax),%eax
c0023a32:	39 c2                	cmp    %eax,%edx
c0023a34:	74 21                	je     c0023a57 <free+0xcb>
c0023a36:	83 ec 0c             	sub    $0xc,%esp
c0023a39:	68 40 06 03 c0       	push   $0xc0030640
c0023a3e:	68 11 06 03 c0       	push   $0xc0030611
c0023a43:	68 28 07 03 c0       	push   $0xc0030728
c0023a48:	68 f6 00 00 00       	push   $0xf6
c0023a4d:	68 28 06 03 c0       	push   $0xc0030628
c0023a52:	e8 17 5d 00 00       	call   c002976e <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023a57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023a5e:	eb 26                	jmp    c0023a86 <free+0xfa>
                {
                  struct block *b = arena_to_block (a, i);
c0023a60:	83 ec 08             	sub    $0x8,%esp
c0023a63:	ff 75 f4             	pushl  -0xc(%ebp)
c0023a66:	ff 75 ec             	pushl  -0x14(%ebp)
c0023a69:	e8 5b 01 00 00       	call   c0023bc9 <arena_to_block>
c0023a6e:	83 c4 10             	add    $0x10,%esp
c0023a71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c0023a74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023a77:	83 ec 0c             	sub    $0xc,%esp
c0023a7a:	50                   	push   %eax
c0023a7b:	e8 65 63 00 00       	call   c0029de5 <list_remove>
c0023a80:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023a83:	ff 45 f4             	incl   -0xc(%ebp)
c0023a86:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a89:	8b 40 04             	mov    0x4(%eax),%eax
c0023a8c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023a8f:	77 cf                	ja     c0023a60 <free+0xd4>
                }
              palloc_free_page (a);
c0023a91:	83 ec 0c             	sub    $0xc,%esp
c0023a94:	ff 75 ec             	pushl  -0x14(%ebp)
c0023a97:	e8 07 fa ff ff       	call   c00234a3 <palloc_free_page>
c0023a9c:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0023a9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023aa2:	83 c0 18             	add    $0x18,%eax
c0023aa5:	83 ec 0c             	sub    $0xc,%esp
c0023aa8:	50                   	push   %eax
c0023aa9:	e8 59 f3 ff ff       	call   c0022e07 <lock_release>
c0023aae:	83 c4 10             	add    $0x10,%esp
c0023ab1:	eb 16                	jmp    c0023ac9 <free+0x13d>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c0023ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023ab6:	8b 40 08             	mov    0x8(%eax),%eax
c0023ab9:	83 ec 08             	sub    $0x8,%esp
c0023abc:	50                   	push   %eax
c0023abd:	ff 75 ec             	pushl  -0x14(%ebp)
c0023ac0:	e8 9e f8 ff ff       	call   c0023363 <palloc_free_multiple>
c0023ac5:	83 c4 10             	add    $0x10,%esp
          return;
c0023ac8:	90                   	nop
        }
    }
}
c0023ac9:	c9                   	leave  
c0023aca:	c3                   	ret    

c0023acb <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c0023acb:	55                   	push   %ebp
c0023acc:	89 e5                	mov    %esp,%ebp
c0023ace:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c0023ad1:	ff 75 08             	pushl  0x8(%ebp)
c0023ad4:	e8 fa fa ff ff       	call   c00235d3 <pg_round_down>
c0023ad9:	83 c4 04             	add    $0x4,%esp
c0023adc:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c0023adf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023ae3:	75 21                	jne    c0023b06 <block_to_arena+0x3b>
c0023ae5:	83 ec 0c             	sub    $0xc,%esp
c0023ae8:	68 63 06 03 c0       	push   $0xc0030663
c0023aed:	68 11 06 03 c0       	push   $0xc0030611
c0023af2:	68 30 07 03 c0       	push   $0xc0030730
c0023af7:	68 11 01 00 00       	push   $0x111
c0023afc:	68 28 06 03 c0       	push   $0xc0030628
c0023b01:	e8 68 5c 00 00       	call   c002976e <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b09:	8b 00                	mov    (%eax),%eax
c0023b0b:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023b10:	74 21                	je     c0023b33 <block_to_arena+0x68>
c0023b12:	83 ec 0c             	sub    $0xc,%esp
c0023b15:	68 6d 06 03 c0       	push   $0xc003066d
c0023b1a:	68 11 06 03 c0       	push   $0xc0030611
c0023b1f:	68 30 07 03 c0       	push   $0xc0030730
c0023b24:	68 12 01 00 00       	push   $0x112
c0023b29:	68 28 06 03 c0       	push   $0xc0030628
c0023b2e:	e8 3b 5c 00 00       	call   c002976e <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c0023b33:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b36:	8b 40 04             	mov    0x4(%eax),%eax
c0023b39:	85 c0                	test   %eax,%eax
c0023b3b:	74 49                	je     c0023b86 <block_to_arena+0xbb>
c0023b3d:	83 ec 0c             	sub    $0xc,%esp
c0023b40:	ff 75 08             	pushl  0x8(%ebp)
c0023b43:	e8 7e fa ff ff       	call   c00235c6 <pg_ofs>
c0023b48:	83 c4 10             	add    $0x10,%esp
c0023b4b:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b51:	8b 40 04             	mov    0x4(%eax),%eax
c0023b54:	8b 08                	mov    (%eax),%ecx
c0023b56:	89 d0                	mov    %edx,%eax
c0023b58:	ba 00 00 00 00       	mov    $0x0,%edx
c0023b5d:	f7 f1                	div    %ecx
c0023b5f:	89 d0                	mov    %edx,%eax
c0023b61:	85 c0                	test   %eax,%eax
c0023b63:	74 21                	je     c0023b86 <block_to_arena+0xbb>
c0023b65:	83 ec 0c             	sub    $0xc,%esp
c0023b68:	68 88 06 03 c0       	push   $0xc0030688
c0023b6d:	68 11 06 03 c0       	push   $0xc0030611
c0023b72:	68 30 07 03 c0       	push   $0xc0030730
c0023b77:	68 16 01 00 00       	push   $0x116
c0023b7c:	68 28 06 03 c0       	push   $0xc0030628
c0023b81:	e8 e8 5b 00 00       	call   c002976e <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023b86:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b89:	8b 40 04             	mov    0x4(%eax),%eax
c0023b8c:	85 c0                	test   %eax,%eax
c0023b8e:	75 34                	jne    c0023bc4 <block_to_arena+0xf9>
c0023b90:	83 ec 0c             	sub    $0xc,%esp
c0023b93:	ff 75 08             	pushl  0x8(%ebp)
c0023b96:	e8 2b fa ff ff       	call   c00235c6 <pg_ofs>
c0023b9b:	83 c4 10             	add    $0x10,%esp
c0023b9e:	83 f8 0c             	cmp    $0xc,%eax
c0023ba1:	74 21                	je     c0023bc4 <block_to_arena+0xf9>
c0023ba3:	83 ec 0c             	sub    $0xc,%esp
c0023ba6:	68 d0 06 03 c0       	push   $0xc00306d0
c0023bab:	68 11 06 03 c0       	push   $0xc0030611
c0023bb0:	68 30 07 03 c0       	push   $0xc0030730
c0023bb5:	68 17 01 00 00       	push   $0x117
c0023bba:	68 28 06 03 c0       	push   $0xc0030628
c0023bbf:	e8 aa 5b 00 00       	call   c002976e <debug_panic>

  return a;
c0023bc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023bc7:	c9                   	leave  
c0023bc8:	c3                   	ret    

c0023bc9 <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023bc9:	55                   	push   %ebp
c0023bca:	89 e5                	mov    %esp,%ebp
c0023bcc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0023bcf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023bd3:	75 21                	jne    c0023bf6 <arena_to_block+0x2d>
c0023bd5:	83 ec 0c             	sub    $0xc,%esp
c0023bd8:	68 63 06 03 c0       	push   $0xc0030663
c0023bdd:	68 11 06 03 c0       	push   $0xc0030611
c0023be2:	68 40 07 03 c0       	push   $0xc0030740
c0023be7:	68 20 01 00 00       	push   $0x120
c0023bec:	68 28 06 03 c0       	push   $0xc0030628
c0023bf1:	e8 78 5b 00 00       	call   c002976e <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023bf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0023bf9:	8b 00                	mov    (%eax),%eax
c0023bfb:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023c00:	74 21                	je     c0023c23 <arena_to_block+0x5a>
c0023c02:	83 ec 0c             	sub    $0xc,%esp
c0023c05:	68 6d 06 03 c0       	push   $0xc003066d
c0023c0a:	68 11 06 03 c0       	push   $0xc0030611
c0023c0f:	68 40 07 03 c0       	push   $0xc0030740
c0023c14:	68 21 01 00 00       	push   $0x121
c0023c19:	68 28 06 03 c0       	push   $0xc0030628
c0023c1e:	e8 4b 5b 00 00       	call   c002976e <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023c23:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c26:	8b 40 04             	mov    0x4(%eax),%eax
c0023c29:	8b 40 04             	mov    0x4(%eax),%eax
c0023c2c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023c2f:	77 21                	ja     c0023c52 <arena_to_block+0x89>
c0023c31:	83 ec 0c             	sub    $0xc,%esp
c0023c34:	68 fc 06 03 c0       	push   $0xc00306fc
c0023c39:	68 11 06 03 c0       	push   $0xc0030611
c0023c3e:	68 40 07 03 c0       	push   $0xc0030740
c0023c43:	68 22 01 00 00       	push   $0x122
c0023c48:	68 28 06 03 c0       	push   $0xc0030628
c0023c4d:	e8 1c 5b 00 00       	call   c002976e <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023c52:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c55:	8b 40 04             	mov    0x4(%eax),%eax
c0023c58:	8b 00                	mov    (%eax),%eax
c0023c5a:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023c5e:	8d 50 0c             	lea    0xc(%eax),%edx
  return (struct block *) ((uint8_t *) a
c0023c61:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c64:	01 d0                	add    %edx,%eax
}
c0023c66:	c9                   	leave  
c0023c67:	c3                   	ret    

c0023c68 <outb>:
{
c0023c68:	55                   	push   %ebp
c0023c69:	89 e5                	mov    %esp,%ebp
c0023c6b:	83 ec 08             	sub    $0x8,%esp
c0023c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c71:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023c74:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0023c78:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023c7b:	8a 45 f8             	mov    -0x8(%ebp),%al
c0023c7e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0023c81:	ee                   	out    %al,(%dx)
}
c0023c82:	90                   	nop
c0023c83:	c9                   	leave  
c0023c84:	c3                   	ret    

c0023c85 <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023c85:	55                   	push   %ebp
c0023c86:	89 e5                	mov    %esp,%ebp
c0023c88:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023c8b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023c8f:	74 24                	je     c0023cb5 <pit_configure_channel+0x30>
c0023c91:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0023c95:	74 1e                	je     c0023cb5 <pit_configure_channel+0x30>
c0023c97:	83 ec 0c             	sub    $0xc,%esp
c0023c9a:	68 50 07 03 c0       	push   $0xc0030750
c0023c9f:	68 6d 07 03 c0       	push   $0xc003076d
c0023ca4:	68 b0 07 03 c0       	push   $0xc00307b0
c0023ca9:	6a 33                	push   $0x33
c0023cab:	68 84 07 03 c0       	push   $0xc0030784
c0023cb0:	e8 b9 5a 00 00       	call   c002976e <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023cb5:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0023cb9:	74 24                	je     c0023cdf <pit_configure_channel+0x5a>
c0023cbb:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0023cbf:	74 1e                	je     c0023cdf <pit_configure_channel+0x5a>
c0023cc1:	83 ec 0c             	sub    $0xc,%esp
c0023cc4:	68 98 07 03 c0       	push   $0xc0030798
c0023cc9:	68 6d 07 03 c0       	push   $0xc003076d
c0023cce:	68 b0 07 03 c0       	push   $0xc00307b0
c0023cd3:	6a 34                	push   $0x34
c0023cd5:	68 84 07 03 c0       	push   $0xc0030784
c0023cda:	e8 8f 5a 00 00       	call   c002976e <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023cdf:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0023ce3:	7f 08                	jg     c0023ced <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023ce5:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0023ceb:	eb 2a                	jmp    c0023d17 <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0023ced:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0023cf4:	7e 08                	jle    c0023cfe <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023cf6:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0023cfc:	eb 19                	jmp    c0023d17 <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023cfe:	8b 45 10             	mov    0x10(%ebp),%eax
c0023d01:	89 c2                	mov    %eax,%edx
c0023d03:	c1 ea 1f             	shr    $0x1f,%edx
c0023d06:	01 d0                	add    %edx,%eax
c0023d08:	d1 f8                	sar    %eax
c0023d0a:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023d0f:	99                   	cltd   
c0023d10:	f7 7d 10             	idivl  0x10(%ebp)
c0023d13:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023d17:	e8 a7 d8 ff ff       	call   c00215c3 <intr_disable>
c0023d1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023d1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d22:	c1 e0 06             	shl    $0x6,%eax
c0023d25:	83 c8 30             	or     $0x30,%eax
c0023d28:	88 c2                	mov    %al,%dl
c0023d2a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d2d:	01 c0                	add    %eax,%eax
c0023d2f:	09 d0                	or     %edx,%eax
c0023d31:	0f b6 c0             	movzbl %al,%eax
c0023d34:	83 ec 08             	sub    $0x8,%esp
c0023d37:	50                   	push   %eax
c0023d38:	6a 43                	push   $0x43
c0023d3a:	e8 29 ff ff ff       	call   c0023c68 <outb>
c0023d3f:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0023d42:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0023d46:	0f b6 d0             	movzbl %al,%edx
c0023d49:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d4c:	83 c0 40             	add    $0x40,%eax
c0023d4f:	0f b7 c0             	movzwl %ax,%eax
c0023d52:	83 ec 08             	sub    $0x8,%esp
c0023d55:	52                   	push   %edx
c0023d56:	50                   	push   %eax
c0023d57:	e8 0c ff ff ff       	call   c0023c68 <outb>
c0023d5c:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023d5f:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0023d63:	66 c1 e8 08          	shr    $0x8,%ax
c0023d67:	0f b6 d0             	movzbl %al,%edx
c0023d6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d6d:	83 c0 40             	add    $0x40,%eax
c0023d70:	0f b7 c0             	movzwl %ax,%eax
c0023d73:	83 ec 08             	sub    $0x8,%esp
c0023d76:	52                   	push   %edx
c0023d77:	50                   	push   %eax
c0023d78:	e8 eb fe ff ff       	call   c0023c68 <outb>
c0023d7d:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0023d80:	83 ec 0c             	sub    $0xc,%esp
c0023d83:	ff 75 f0             	pushl  -0x10(%ebp)
c0023d86:	e8 e0 d7 ff ff       	call   c002156b <intr_set_level>
c0023d8b:	83 c4 10             	add    $0x10,%esp
}
c0023d8e:	90                   	nop
c0023d8f:	c9                   	leave  
c0023d90:	c3                   	ret    

c0023d91 <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c0023d91:	55                   	push   %ebp
c0023d92:	89 e5                	mov    %esp,%ebp
c0023d94:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023d97:	83 ec 04             	sub    $0x4,%esp
c0023d9a:	6a 64                	push   $0x64
c0023d9c:	6a 02                	push   $0x2
c0023d9e:	6a 00                	push   $0x0
c0023da0:	e8 e0 fe ff ff       	call   c0023c85 <pit_configure_channel>
c0023da5:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0023da8:	83 ec 04             	sub    $0x4,%esp
c0023dab:	68 c8 07 03 c0       	push   $0xc00307c8
c0023db0:	68 b8 40 02 c0       	push   $0xc00240b8
c0023db5:	6a 20                	push   $0x20
c0023db7:	e8 26 da ff ff       	call   c00217e2 <intr_register_ext>
c0023dbc:	83 c4 10             	add    $0x10,%esp
}
c0023dbf:	90                   	nop
c0023dc0:	c9                   	leave  
c0023dc1:	c3                   	ret    

c0023dc2 <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0023dc2:	55                   	push   %ebp
c0023dc3:	89 e5                	mov    %esp,%ebp
c0023dc5:	53                   	push   %ebx
c0023dc6:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0023dc9:	e8 80 d7 ff ff       	call   c002154e <intr_get_level>
c0023dce:	83 f8 01             	cmp    $0x1,%eax
c0023dd1:	74 1e                	je     c0023df1 <timer_calibrate+0x2f>
c0023dd3:	83 ec 0c             	sub    $0xc,%esp
c0023dd6:	68 d3 07 03 c0       	push   $0xc00307d3
c0023ddb:	68 f0 07 03 c0       	push   $0xc00307f0
c0023de0:	68 80 08 03 c0       	push   $0xc0030880
c0023de5:	6a 30                	push   $0x30
c0023de7:	68 07 08 03 c0       	push   $0xc0030807
c0023dec:	e8 7d 59 00 00       	call   c002976e <debug_panic>
  printf ("Calibrating timer...  ");
c0023df1:	83 ec 0c             	sub    $0xc,%esp
c0023df4:	68 1d 08 03 c0       	push   $0xc003081d
c0023df9:	e8 b1 35 00 00       	call   c00273af <printf>
c0023dfe:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0023e01:	c7 05 70 a0 03 c0 00 	movl   $0x400,0xc003a070
c0023e08:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0023e0b:	eb 33                	jmp    c0023e40 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0023e0d:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c0023e12:	01 c0                	add    %eax,%eax
c0023e14:	a3 70 a0 03 c0       	mov    %eax,0xc003a070
      ASSERT (loops_per_tick != 0);
c0023e19:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c0023e1e:	85 c0                	test   %eax,%eax
c0023e20:	75 1e                	jne    c0023e40 <timer_calibrate+0x7e>
c0023e22:	83 ec 0c             	sub    $0xc,%esp
c0023e25:	68 34 08 03 c0       	push   $0xc0030834
c0023e2a:	68 f0 07 03 c0       	push   $0xc00307f0
c0023e2f:	68 80 08 03 c0       	push   $0xc0030880
c0023e34:	6a 39                	push   $0x39
c0023e36:	68 07 08 03 c0       	push   $0xc0030807
c0023e3b:	e8 2e 59 00 00       	call   c002976e <debug_panic>
  while (!too_many_loops (loops_per_tick << 1)) 
c0023e40:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c0023e45:	01 c0                	add    %eax,%eax
c0023e47:	83 ec 0c             	sub    $0xc,%esp
c0023e4a:	50                   	push   %eax
c0023e4b:	e8 92 02 00 00       	call   c00240e2 <too_many_loops>
c0023e50:	83 c4 10             	add    $0x10,%esp
c0023e53:	83 f0 01             	xor    $0x1,%eax
c0023e56:	84 c0                	test   %al,%al
c0023e58:	75 b3                	jne    c0023e0d <timer_calibrate+0x4b>
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c0023e5a:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c0023e5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023e65:	d1 e8                	shr    %eax
c0023e67:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023e6a:	eb 29                	jmp    c0023e95 <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c0023e6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023e6f:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023e72:	83 ec 0c             	sub    $0xc,%esp
c0023e75:	50                   	push   %eax
c0023e76:	e8 67 02 00 00       	call   c00240e2 <too_many_loops>
c0023e7b:	83 c4 10             	add    $0x10,%esp
c0023e7e:	83 f0 01             	xor    $0x1,%eax
c0023e81:	84 c0                	test   %al,%al
c0023e83:	74 0d                	je     c0023e92 <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c0023e85:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c0023e8a:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023e8d:	a3 70 a0 03 c0       	mov    %eax,0xc003a070
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023e92:	d1 6d f4             	shrl   -0xc(%ebp)
c0023e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023e98:	c1 e8 0a             	shr    $0xa,%eax
c0023e9b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023e9e:	75 cc                	jne    c0023e6c <timer_calibrate+0xaa>

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023ea0:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c0023ea5:	ba 00 00 00 00       	mov    $0x0,%edx
c0023eaa:	6b da 64             	imul   $0x64,%edx,%ebx
c0023ead:	6b c8 00             	imul   $0x0,%eax,%ecx
c0023eb0:	01 d9                	add    %ebx,%ecx
c0023eb2:	bb 64 00 00 00       	mov    $0x64,%ebx
c0023eb7:	f7 e3                	mul    %ebx
c0023eb9:	01 d1                	add    %edx,%ecx
c0023ebb:	89 ca                	mov    %ecx,%edx
c0023ebd:	83 ec 04             	sub    $0x4,%esp
c0023ec0:	52                   	push   %edx
c0023ec1:	50                   	push   %eax
c0023ec2:	68 48 08 03 c0       	push   $0xc0030848
c0023ec7:	e8 e3 34 00 00       	call   c00273af <printf>
c0023ecc:	83 c4 10             	add    $0x10,%esp
}
c0023ecf:	90                   	nop
c0023ed0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023ed3:	c9                   	leave  
c0023ed4:	c3                   	ret    

c0023ed5 <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0023ed5:	55                   	push   %ebp
c0023ed6:	89 e5                	mov    %esp,%ebp
c0023ed8:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0023edb:	e8 e3 d6 ff ff       	call   c00215c3 <intr_disable>
c0023ee0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0023ee3:	a1 68 a0 03 c0       	mov    0xc003a068,%eax
c0023ee8:	8b 15 6c a0 03 c0    	mov    0xc003a06c,%edx
c0023eee:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0023ef1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0023ef4:	83 ec 0c             	sub    $0xc,%esp
c0023ef7:	ff 75 f4             	pushl  -0xc(%ebp)
c0023efa:	e8 6c d6 ff ff       	call   c002156b <intr_set_level>
c0023eff:	83 c4 10             	add    $0x10,%esp
  return t;
c0023f02:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023f05:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0023f08:	c9                   	leave  
c0023f09:	c3                   	ret    

c0023f0a <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0023f0a:	55                   	push   %ebp
c0023f0b:	89 e5                	mov    %esp,%ebp
c0023f0d:	83 ec 18             	sub    $0x18,%esp
c0023f10:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f13:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f16:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f19:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0023f1c:	e8 b4 ff ff ff       	call   c0023ed5 <timer_ticks>
c0023f21:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0023f24:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c0023f27:	c9                   	leave  
c0023f28:	c3                   	ret    

c0023f29 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0023f29:	55                   	push   %ebp
c0023f2a:	89 e5                	mov    %esp,%ebp
c0023f2c:	83 ec 28             	sub    $0x28,%esp
c0023f2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f32:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023f35:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int64_t start = timer_ticks ();
c0023f3b:	e8 95 ff ff ff       	call   c0023ed5 <timer_ticks>
c0023f40:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f43:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023f46:	e8 03 d6 ff ff       	call   c002154e <intr_get_level>
c0023f4b:	83 f8 01             	cmp    $0x1,%eax
c0023f4e:	74 23                	je     c0023f73 <timer_sleep+0x4a>
c0023f50:	83 ec 0c             	sub    $0xc,%esp
c0023f53:	68 d3 07 03 c0       	push   $0xc00307d3
c0023f58:	68 f0 07 03 c0       	push   $0xc00307f0
c0023f5d:	68 90 08 03 c0       	push   $0xc0030890
c0023f62:	6a 5e                	push   $0x5e
c0023f64:	68 07 08 03 c0       	push   $0xc0030807
c0023f69:	e8 00 58 00 00       	call   c002976e <debug_panic>
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
c0023f6e:	e8 e8 cf ff ff       	call   c0020f5b <thread_yield>
  while (timer_elapsed (start) < ticks) 
c0023f73:	83 ec 08             	sub    $0x8,%esp
c0023f76:	ff 75 f4             	pushl  -0xc(%ebp)
c0023f79:	ff 75 f0             	pushl  -0x10(%ebp)
c0023f7c:	e8 89 ff ff ff       	call   c0023f0a <timer_elapsed>
c0023f81:	83 c4 10             	add    $0x10,%esp
c0023f84:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023f87:	7c e5                	jl     c0023f6e <timer_sleep+0x45>
c0023f89:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023f8c:	7f 05                	jg     c0023f93 <timer_sleep+0x6a>
c0023f8e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0023f91:	72 db                	jb     c0023f6e <timer_sleep+0x45>
}
c0023f93:	90                   	nop
c0023f94:	c9                   	leave  
c0023f95:	c3                   	ret    

c0023f96 <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c0023f96:	55                   	push   %ebp
c0023f97:	89 e5                	mov    %esp,%ebp
c0023f99:	83 ec 18             	sub    $0x18,%esp
c0023f9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023fa2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023fa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c0023fa8:	83 ec 04             	sub    $0x4,%esp
c0023fab:	68 e8 03 00 00       	push   $0x3e8
c0023fb0:	ff 75 f4             	pushl  -0xc(%ebp)
c0023fb3:	ff 75 f0             	pushl  -0x10(%ebp)
c0023fb6:	e8 f9 01 00 00       	call   c00241b4 <real_time_sleep>
c0023fbb:	83 c4 10             	add    $0x10,%esp
}
c0023fbe:	90                   	nop
c0023fbf:	c9                   	leave  
c0023fc0:	c3                   	ret    

c0023fc1 <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0023fc1:	55                   	push   %ebp
c0023fc2:	89 e5                	mov    %esp,%ebp
c0023fc4:	83 ec 18             	sub    $0x18,%esp
c0023fc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0023fca:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023fcd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023fd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0023fd3:	83 ec 04             	sub    $0x4,%esp
c0023fd6:	68 40 42 0f 00       	push   $0xf4240
c0023fdb:	ff 75 f4             	pushl  -0xc(%ebp)
c0023fde:	ff 75 f0             	pushl  -0x10(%ebp)
c0023fe1:	e8 ce 01 00 00       	call   c00241b4 <real_time_sleep>
c0023fe6:	83 c4 10             	add    $0x10,%esp
}
c0023fe9:	90                   	nop
c0023fea:	c9                   	leave  
c0023feb:	c3                   	ret    

c0023fec <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0023fec:	55                   	push   %ebp
c0023fed:	89 e5                	mov    %esp,%ebp
c0023fef:	83 ec 18             	sub    $0x18,%esp
c0023ff2:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0023ffe:	83 ec 04             	sub    $0x4,%esp
c0024001:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0024006:	ff 75 f4             	pushl  -0xc(%ebp)
c0024009:	ff 75 f0             	pushl  -0x10(%ebp)
c002400c:	e8 a3 01 00 00       	call   c00241b4 <real_time_sleep>
c0024011:	83 c4 10             	add    $0x10,%esp
}
c0024014:	90                   	nop
c0024015:	c9                   	leave  
c0024016:	c3                   	ret    

c0024017 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0024017:	55                   	push   %ebp
c0024018:	89 e5                	mov    %esp,%ebp
c002401a:	83 ec 18             	sub    $0x18,%esp
c002401d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024020:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024023:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024026:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0024029:	83 ec 04             	sub    $0x4,%esp
c002402c:	68 e8 03 00 00       	push   $0x3e8
c0024031:	ff 75 f4             	pushl  -0xc(%ebp)
c0024034:	ff 75 f0             	pushl  -0x10(%ebp)
c0024037:	e8 2a 02 00 00       	call   c0024266 <real_time_delay>
c002403c:	83 c4 10             	add    $0x10,%esp
}
c002403f:	90                   	nop
c0024040:	c9                   	leave  
c0024041:	c3                   	ret    

c0024042 <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0024042:	55                   	push   %ebp
c0024043:	89 e5                	mov    %esp,%ebp
c0024045:	83 ec 18             	sub    $0x18,%esp
c0024048:	8b 45 08             	mov    0x8(%ebp),%eax
c002404b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002404e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024051:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c0024054:	83 ec 04             	sub    $0x4,%esp
c0024057:	68 40 42 0f 00       	push   $0xf4240
c002405c:	ff 75 f4             	pushl  -0xc(%ebp)
c002405f:	ff 75 f0             	pushl  -0x10(%ebp)
c0024062:	e8 ff 01 00 00       	call   c0024266 <real_time_delay>
c0024067:	83 c4 10             	add    $0x10,%esp
}
c002406a:	90                   	nop
c002406b:	c9                   	leave  
c002406c:	c3                   	ret    

c002406d <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c002406d:	55                   	push   %ebp
c002406e:	89 e5                	mov    %esp,%ebp
c0024070:	83 ec 18             	sub    $0x18,%esp
c0024073:	8b 45 08             	mov    0x8(%ebp),%eax
c0024076:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024079:	8b 45 0c             	mov    0xc(%ebp),%eax
c002407c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c002407f:	83 ec 04             	sub    $0x4,%esp
c0024082:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0024087:	ff 75 f4             	pushl  -0xc(%ebp)
c002408a:	ff 75 f0             	pushl  -0x10(%ebp)
c002408d:	e8 d4 01 00 00       	call   c0024266 <real_time_delay>
c0024092:	83 c4 10             	add    $0x10,%esp
}
c0024095:	90                   	nop
c0024096:	c9                   	leave  
c0024097:	c3                   	ret    

c0024098 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c0024098:	55                   	push   %ebp
c0024099:	89 e5                	mov    %esp,%ebp
c002409b:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c002409e:	e8 32 fe ff ff       	call   c0023ed5 <timer_ticks>
c00240a3:	83 ec 04             	sub    $0x4,%esp
c00240a6:	52                   	push   %edx
c00240a7:	50                   	push   %eax
c00240a8:	68 58 08 03 c0       	push   $0xc0030858
c00240ad:	e8 fd 32 00 00       	call   c00273af <printf>
c00240b2:	83 c4 10             	add    $0x10,%esp
}
c00240b5:	90                   	nop
c00240b6:	c9                   	leave  
c00240b7:	c3                   	ret    

c00240b8 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c00240b8:	55                   	push   %ebp
c00240b9:	89 e5                	mov    %esp,%ebp
c00240bb:	83 ec 08             	sub    $0x8,%esp
  ticks++;
c00240be:	a1 68 a0 03 c0       	mov    0xc003a068,%eax
c00240c3:	8b 15 6c a0 03 c0    	mov    0xc003a06c,%edx
c00240c9:	83 c0 01             	add    $0x1,%eax
c00240cc:	83 d2 00             	adc    $0x0,%edx
c00240cf:	a3 68 a0 03 c0       	mov    %eax,0xc003a068
c00240d4:	89 15 6c a0 03 c0    	mov    %edx,0xc003a06c
  thread_tick ();
c00240da:	e8 86 ca ff ff       	call   c0020b65 <thread_tick>
}
c00240df:	90                   	nop
c00240e0:	c9                   	leave  
c00240e1:	c3                   	ret    

c00240e2 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c00240e2:	55                   	push   %ebp
c00240e3:	89 e5                	mov    %esp,%ebp
c00240e5:	56                   	push   %esi
c00240e6:	53                   	push   %ebx
c00240e7:	83 ec 20             	sub    $0x20,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c00240ea:	a1 68 a0 03 c0       	mov    0xc003a068,%eax
c00240ef:	8b 15 6c a0 03 c0    	mov    0xc003a06c,%edx
c00240f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00240f8:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c00240fb:	eb 00                	jmp    c00240fd <too_many_loops+0x1b>
c00240fd:	a1 68 a0 03 c0       	mov    0xc003a068,%eax
c0024102:	8b 15 6c a0 03 c0    	mov    0xc003a06c,%edx
c0024108:	89 c1                	mov    %eax,%ecx
c002410a:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002410d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0024110:	89 d0                	mov    %edx,%eax
c0024112:	33 45 f4             	xor    -0xc(%ebp),%eax
c0024115:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0024118:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002411b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002411e:	89 c8                	mov    %ecx,%eax
c0024120:	09 d0                	or     %edx,%eax
c0024122:	85 c0                	test   %eax,%eax
c0024124:	74 d7                	je     c00240fd <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0024126:	a1 68 a0 03 c0       	mov    0xc003a068,%eax
c002412b:	8b 15 6c a0 03 c0    	mov    0xc003a06c,%edx
c0024131:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024134:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c0024137:	8b 45 08             	mov    0x8(%ebp),%eax
c002413a:	ba 00 00 00 00       	mov    $0x0,%edx
c002413f:	83 ec 08             	sub    $0x8,%esp
c0024142:	52                   	push   %edx
c0024143:	50                   	push   %eax
c0024144:	e8 2c 00 00 00       	call   c0024175 <busy_wait>
c0024149:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c002414c:	a1 68 a0 03 c0       	mov    0xc003a068,%eax
c0024151:	8b 15 6c a0 03 c0    	mov    0xc003a06c,%edx
c0024157:	89 c1                	mov    %eax,%ecx
c0024159:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002415c:	89 cb                	mov    %ecx,%ebx
c002415e:	89 d0                	mov    %edx,%eax
c0024160:	33 45 f4             	xor    -0xc(%ebp),%eax
c0024163:	89 c6                	mov    %eax,%esi
c0024165:	89 d8                	mov    %ebx,%eax
c0024167:	09 f0                	or     %esi,%eax
c0024169:	85 c0                	test   %eax,%eax
c002416b:	0f 95 c0             	setne  %al
}
c002416e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024171:	5b                   	pop    %ebx
c0024172:	5e                   	pop    %esi
c0024173:	5d                   	pop    %ebp
c0024174:	c3                   	ret    

c0024175 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0024175:	55                   	push   %ebp
c0024176:	89 e5                	mov    %esp,%ebp
c0024178:	53                   	push   %ebx
c0024179:	83 ec 0c             	sub    $0xc,%esp
c002417c:	8b 45 08             	mov    0x8(%ebp),%eax
c002417f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024182:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024185:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c0024188:	eb 00                	jmp    c002418a <busy_wait+0x15>
c002418a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002418d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0024190:	89 c1                	mov    %eax,%ecx
c0024192:	89 d3                	mov    %edx,%ebx
c0024194:	83 c1 ff             	add    $0xffffffff,%ecx
c0024197:	83 d3 ff             	adc    $0xffffffff,%ebx
c002419a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c002419d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c00241a0:	85 d2                	test   %edx,%edx
c00241a2:	7f e6                	jg     c002418a <busy_wait+0x15>
c00241a4:	85 d2                	test   %edx,%edx
c00241a6:	78 05                	js     c00241ad <busy_wait+0x38>
c00241a8:	83 f8 00             	cmp    $0x0,%eax
c00241ab:	77 dd                	ja     c002418a <busy_wait+0x15>
    barrier ();
}
c00241ad:	90                   	nop
c00241ae:	83 c4 0c             	add    $0xc,%esp
c00241b1:	5b                   	pop    %ebx
c00241b2:	5d                   	pop    %ebp
c00241b3:	c3                   	ret    

c00241b4 <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c00241b4:	55                   	push   %ebp
c00241b5:	89 e5                	mov    %esp,%ebp
c00241b7:	53                   	push   %ebx
c00241b8:	83 ec 24             	sub    $0x24,%esp
c00241bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00241be:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00241c1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00241c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c00241c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00241ca:	6b d0 64             	imul   $0x64,%eax,%edx
c00241cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00241d0:	6b c0 00             	imul   $0x0,%eax,%eax
c00241d3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00241d6:	b8 64 00 00 00       	mov    $0x64,%eax
c00241db:	f7 65 e0             	mull   -0x20(%ebp)
c00241de:	01 d1                	add    %edx,%ecx
c00241e0:	89 ca                	mov    %ecx,%edx
c00241e2:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00241e5:	89 cb                	mov    %ecx,%ebx
c00241e7:	c1 fb 1f             	sar    $0x1f,%ebx
c00241ea:	53                   	push   %ebx
c00241eb:	51                   	push   %ecx
c00241ec:	52                   	push   %edx
c00241ed:	50                   	push   %eax
c00241ee:	e8 81 4f 00 00       	call   c0029174 <__divdi3>
c00241f3:	83 c4 10             	add    $0x10,%esp
c00241f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00241f9:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c00241fc:	e8 4d d3 ff ff       	call   c002154e <intr_get_level>
c0024201:	83 f8 01             	cmp    $0x1,%eax
c0024204:	74 21                	je     c0024227 <real_time_sleep+0x73>
c0024206:	83 ec 0c             	sub    $0xc,%esp
c0024209:	68 d3 07 03 c0       	push   $0xc00307d3
c002420e:	68 f0 07 03 c0       	push   $0xc00307f0
c0024213:	68 9c 08 03 c0       	push   $0xc003089c
c0024218:	68 de 00 00 00       	push   $0xde
c002421d:	68 07 08 03 c0       	push   $0xc0030807
c0024222:	e8 47 55 00 00       	call   c002976e <debug_panic>
  if (ticks > 0)
c0024227:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002422b:	78 1f                	js     c002424c <real_time_sleep+0x98>
c002422d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024231:	7f 06                	jg     c0024239 <real_time_sleep+0x85>
c0024233:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024237:	76 13                	jbe    c002424c <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c0024239:	83 ec 08             	sub    $0x8,%esp
c002423c:	ff 75 f4             	pushl  -0xc(%ebp)
c002423f:	ff 75 f0             	pushl  -0x10(%ebp)
c0024242:	e8 e2 fc ff ff       	call   c0023f29 <timer_sleep>
c0024247:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c002424a:	eb 14                	jmp    c0024260 <real_time_sleep+0xac>
      real_time_delay (num, denom); 
c002424c:	83 ec 04             	sub    $0x4,%esp
c002424f:	ff 75 10             	pushl  0x10(%ebp)
c0024252:	ff 75 e4             	pushl  -0x1c(%ebp)
c0024255:	ff 75 e0             	pushl  -0x20(%ebp)
c0024258:	e8 09 00 00 00       	call   c0024266 <real_time_delay>
c002425d:	83 c4 10             	add    $0x10,%esp
}
c0024260:	90                   	nop
c0024261:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024264:	c9                   	leave  
c0024265:	c3                   	ret    

c0024266 <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c0024266:	55                   	push   %ebp
c0024267:	89 e5                	mov    %esp,%ebp
c0024269:	56                   	push   %esi
c002426a:	53                   	push   %ebx
c002426b:	83 ec 10             	sub    $0x10,%esp
c002426e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024271:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024274:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024277:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c002427a:	8b 45 10             	mov    0x10(%ebp),%eax
c002427d:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024282:	99                   	cltd   
c0024283:	f7 f9                	idiv   %ecx
c0024285:	89 d0                	mov    %edx,%eax
c0024287:	85 c0                	test   %eax,%eax
c0024289:	74 21                	je     c00242ac <real_time_delay+0x46>
c002428b:	83 ec 0c             	sub    $0xc,%esp
c002428e:	68 6b 08 03 c0       	push   $0xc003086b
c0024293:	68 f0 07 03 c0       	push   $0xc00307f0
c0024298:	68 ac 08 03 c0       	push   $0xc00308ac
c002429d:	68 f4 00 00 00       	push   $0xf4
c00242a2:	68 07 08 03 c0       	push   $0xc0030807
c00242a7:	e8 c2 54 00 00       	call   c002976e <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c00242ac:	a1 70 a0 03 c0       	mov    0xc003a070,%eax
c00242b1:	ba 00 00 00 00       	mov    $0x0,%edx
c00242b6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00242b9:	89 cb                	mov    %ecx,%ebx
c00242bb:	0f af da             	imul   %edx,%ebx
c00242be:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00242c1:	0f af c8             	imul   %eax,%ecx
c00242c4:	01 d9                	add    %ebx,%ecx
c00242c6:	f7 65 f0             	mull   -0x10(%ebp)
c00242c9:	01 d1                	add    %edx,%ecx
c00242cb:	89 ca                	mov    %ecx,%edx
c00242cd:	6a 00                	push   $0x0
c00242cf:	68 e8 03 00 00       	push   $0x3e8
c00242d4:	52                   	push   %edx
c00242d5:	50                   	push   %eax
c00242d6:	e8 99 4e 00 00       	call   c0029174 <__divdi3>
c00242db:	83 c4 10             	add    $0x10,%esp
c00242de:	6b da 64             	imul   $0x64,%edx,%ebx
c00242e1:	6b c8 00             	imul   $0x0,%eax,%ecx
c00242e4:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c00242e7:	b9 64 00 00 00       	mov    $0x64,%ecx
c00242ec:	f7 e1                	mul    %ecx
c00242ee:	89 c1                	mov    %eax,%ecx
c00242f0:	89 d3                	mov    %edx,%ebx
c00242f2:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c00242f5:	89 c3                	mov    %eax,%ebx
c00242f7:	8b 75 10             	mov    0x10(%ebp),%esi
c00242fa:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c00242ff:	f7 ee                	imul   %esi
c0024301:	c1 fa 06             	sar    $0x6,%edx
c0024304:	89 f0                	mov    %esi,%eax
c0024306:	c1 f8 1f             	sar    $0x1f,%eax
c0024309:	29 c2                	sub    %eax,%edx
c002430b:	89 d0                	mov    %edx,%eax
c002430d:	99                   	cltd   
c002430e:	52                   	push   %edx
c002430f:	50                   	push   %eax
c0024310:	53                   	push   %ebx
c0024311:	51                   	push   %ecx
c0024312:	e8 5d 4e 00 00       	call   c0029174 <__divdi3>
c0024317:	83 c4 10             	add    $0x10,%esp
c002431a:	83 ec 08             	sub    $0x8,%esp
c002431d:	52                   	push   %edx
c002431e:	50                   	push   %eax
c002431f:	e8 51 fe ff ff       	call   c0024175 <busy_wait>
c0024324:	83 c4 10             	add    $0x10,%esp
}
c0024327:	90                   	nop
c0024328:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002432b:	5b                   	pop    %ebx
c002432c:	5e                   	pop    %esi
c002432d:	5d                   	pop    %ebp
c002432e:	c3                   	ret    

c002432f <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c002432f:	55                   	push   %ebp
c0024330:	89 e5                	mov    %esp,%ebp
c0024332:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0024336:	7e 0d                	jle    c0024345 <isupper+0x16>
c0024338:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c002433c:	7f 07                	jg     c0024345 <isupper+0x16>
c002433e:	b8 01 00 00 00       	mov    $0x1,%eax
c0024343:	eb 05                	jmp    c002434a <isupper+0x1b>
c0024345:	b8 00 00 00 00       	mov    $0x0,%eax
c002434a:	5d                   	pop    %ebp
c002434b:	c3                   	ret    

c002434c <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c002434c:	55                   	push   %ebp
c002434d:	89 e5                	mov    %esp,%ebp
c002434f:	ff 75 08             	pushl  0x8(%ebp)
c0024352:	e8 d8 ff ff ff       	call   c002432f <isupper>
c0024357:	83 c4 04             	add    $0x4,%esp
c002435a:	85 c0                	test   %eax,%eax
c002435c:	74 08                	je     c0024366 <tolower+0x1a>
c002435e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024361:	83 c0 20             	add    $0x20,%eax
c0024364:	eb 03                	jmp    c0024369 <tolower+0x1d>
c0024366:	8b 45 08             	mov    0x8(%ebp),%eax
c0024369:	c9                   	leave  
c002436a:	c3                   	ret    

c002436b <inb>:
{
c002436b:	55                   	push   %ebp
c002436c:	89 e5                	mov    %esp,%ebp
c002436e:	83 ec 14             	sub    $0x14,%esp
c0024371:	8b 45 08             	mov    0x8(%ebp),%eax
c0024374:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024378:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002437b:	89 c2                	mov    %eax,%edx
c002437d:	ec                   	in     (%dx),%al
c002437e:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024381:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024384:	c9                   	leave  
c0024385:	c3                   	ret    

c0024386 <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c0024386:	55                   	push   %ebp
c0024387:	89 e5                	mov    %esp,%ebp
c0024389:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c002438c:	83 ec 04             	sub    $0x4,%esp
c002438f:	68 c0 08 03 c0       	push   $0xc00308c0
c0024394:	68 cc 43 02 c0       	push   $0xc00243cc
c0024399:	6a 21                	push   $0x21
c002439b:	e8 42 d4 ff ff       	call   c00217e2 <intr_register_ext>
c00243a0:	83 c4 10             	add    $0x10,%esp
}
c00243a3:	90                   	nop
c00243a4:	c9                   	leave  
c00243a5:	c3                   	ret    

c00243a6 <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c00243a6:	55                   	push   %ebp
c00243a7:	89 e5                	mov    %esp,%ebp
c00243a9:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c00243ac:	a1 80 a0 03 c0       	mov    0xc003a080,%eax
c00243b1:	8b 15 84 a0 03 c0    	mov    0xc003a084,%edx
c00243b7:	83 ec 04             	sub    $0x4,%esp
c00243ba:	52                   	push   %edx
c00243bb:	50                   	push   %eax
c00243bc:	68 ce 08 03 c0       	push   $0xc00308ce
c00243c1:	e8 e9 2f 00 00       	call   c00273af <printf>
c00243c6:	83 c4 10             	add    $0x10,%esp
}
c00243c9:	90                   	nop
c00243ca:	c9                   	leave  
c00243cb:	c3                   	ret    

c00243cc <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c00243cc:	55                   	push   %ebp
c00243cd:	89 e5                	mov    %esp,%ebp
c00243cf:	53                   	push   %ebx
c00243d0:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c00243d3:	a0 78 a0 03 c0       	mov    0xc003a078,%al
c00243d8:	84 c0                	test   %al,%al
c00243da:	75 09                	jne    c00243e5 <keyboard_interrupt+0x19>
c00243dc:	a0 79 a0 03 c0       	mov    0xc003a079,%al
c00243e1:	84 c0                	test   %al,%al
c00243e3:	74 07                	je     c00243ec <keyboard_interrupt+0x20>
c00243e5:	b8 01 00 00 00       	mov    $0x1,%eax
c00243ea:	eb 05                	jmp    c00243f1 <keyboard_interrupt+0x25>
c00243ec:	b8 00 00 00 00       	mov    $0x0,%eax
c00243f1:	88 45 ef             	mov    %al,-0x11(%ebp)
c00243f4:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c00243f8:	a0 7a a0 03 c0       	mov    0xc003a07a,%al
c00243fd:	84 c0                	test   %al,%al
c00243ff:	75 09                	jne    c002440a <keyboard_interrupt+0x3e>
c0024401:	a0 7b a0 03 c0       	mov    0xc003a07b,%al
c0024406:	84 c0                	test   %al,%al
c0024408:	74 07                	je     c0024411 <keyboard_interrupt+0x45>
c002440a:	b8 01 00 00 00       	mov    $0x1,%eax
c002440f:	eb 05                	jmp    c0024416 <keyboard_interrupt+0x4a>
c0024411:	b8 00 00 00 00       	mov    $0x0,%eax
c0024416:	88 45 ee             	mov    %al,-0x12(%ebp)
c0024419:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c002441d:	a0 7c a0 03 c0       	mov    0xc003a07c,%al
c0024422:	84 c0                	test   %al,%al
c0024424:	75 09                	jne    c002442f <keyboard_interrupt+0x63>
c0024426:	a0 7d a0 03 c0       	mov    0xc003a07d,%al
c002442b:	84 c0                	test   %al,%al
c002442d:	74 07                	je     c0024436 <keyboard_interrupt+0x6a>
c002442f:	b8 01 00 00 00       	mov    $0x1,%eax
c0024434:	eb 05                	jmp    c002443b <keyboard_interrupt+0x6f>
c0024436:	b8 00 00 00 00       	mov    $0x0,%eax
c002443b:	88 45 ed             	mov    %al,-0x13(%ebp)
c002443e:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c0024442:	6a 60                	push   $0x60
c0024444:	e8 22 ff ff ff       	call   c002436b <inb>
c0024449:	83 c4 04             	add    $0x4,%esp
c002444c:	0f b6 c0             	movzbl %al,%eax
c002444f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c0024452:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0024459:	75 1a                	jne    c0024475 <keyboard_interrupt+0xa9>
    code = (code << 8) | inb (DATA_REG);
c002445b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002445e:	c1 e0 08             	shl    $0x8,%eax
c0024461:	89 c3                	mov    %eax,%ebx
c0024463:	6a 60                	push   $0x60
c0024465:	e8 01 ff ff ff       	call   c002436b <inb>
c002446a:	83 c4 04             	add    $0x4,%esp
c002446d:	0f b6 c0             	movzbl %al,%eax
c0024470:	09 d8                	or     %ebx,%eax
c0024472:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c0024475:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024478:	25 80 00 00 00       	and    $0x80,%eax
c002447d:	85 c0                	test   %eax,%eax
c002447f:	0f 95 c0             	setne  %al
c0024482:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c0024485:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c002448c:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c0024490:	75 2e                	jne    c00244c0 <keyboard_interrupt+0xf4>
    {
      /* Caps Lock. */
      if (!release)
c0024492:	8a 45 ec             	mov    -0x14(%ebp),%al
c0024495:	83 f0 01             	xor    $0x1,%eax
c0024498:	84 c0                	test   %al,%al
c002449a:	0f 84 77 01 00 00    	je     c0024617 <keyboard_interrupt+0x24b>
        caps_lock = !caps_lock;
c00244a0:	a0 7e a0 03 c0       	mov    0xc003a07e,%al
c00244a5:	0f b6 c0             	movzbl %al,%eax
c00244a8:	85 c0                	test   %eax,%eax
c00244aa:	0f 95 c0             	setne  %al
c00244ad:	83 f0 01             	xor    $0x1,%eax
c00244b0:	0f b6 c0             	movzbl %al,%eax
c00244b3:	83 e0 01             	and    $0x1,%eax
c00244b6:	a2 7e a0 03 c0       	mov    %al,0xc003a07e
          {
            *key->state_var = !release;
            break;
          }
    }
}
c00244bb:	e9 57 01 00 00       	jmp    c0024617 <keyboard_interrupt+0x24b>
  else if (map_key (invariant_keymap, code, &c)
c00244c0:	83 ec 04             	sub    $0x4,%esp
c00244c3:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00244c6:	50                   	push   %eax
c00244c7:	ff 75 f4             	pushl  -0xc(%ebp)
c00244ca:	68 20 09 03 c0       	push   $0xc0030920
c00244cf:	e8 49 01 00 00       	call   c002461d <map_key>
c00244d4:	83 c4 10             	add    $0x10,%esp
c00244d7:	84 c0                	test   %al,%al
c00244d9:	75 4e                	jne    c0024529 <keyboard_interrupt+0x15d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00244db:	8a 45 ef             	mov    -0x11(%ebp),%al
c00244de:	83 f0 01             	xor    $0x1,%eax
c00244e1:	84 c0                	test   %al,%al
c00244e3:	74 1b                	je     c0024500 <keyboard_interrupt+0x134>
c00244e5:	83 ec 04             	sub    $0x4,%esp
c00244e8:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00244eb:	50                   	push   %eax
c00244ec:	ff 75 f4             	pushl  -0xc(%ebp)
c00244ef:	68 a0 09 03 c0       	push   $0xc00309a0
c00244f4:	e8 24 01 00 00       	call   c002461d <map_key>
c00244f9:	83 c4 10             	add    $0x10,%esp
c00244fc:	84 c0                	test   %al,%al
c00244fe:	75 29                	jne    c0024529 <keyboard_interrupt+0x15d>
           || (shift && map_key (shifted_keymap, code, &c)))
c0024500:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0024504:	0f 84 ce 00 00 00    	je     c00245d8 <keyboard_interrupt+0x20c>
c002450a:	83 ec 04             	sub    $0x4,%esp
c002450d:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0024510:	50                   	push   %eax
c0024511:	ff 75 f4             	pushl  -0xc(%ebp)
c0024514:	68 00 0a 03 c0       	push   $0xc0030a00
c0024519:	e8 ff 00 00 00       	call   c002461d <map_key>
c002451e:	83 c4 10             	add    $0x10,%esp
c0024521:	84 c0                	test   %al,%al
c0024523:	0f 84 af 00 00 00    	je     c00245d8 <keyboard_interrupt+0x20c>
      if (!release) 
c0024529:	8a 45 ec             	mov    -0x14(%ebp),%al
c002452c:	83 f0 01             	xor    $0x1,%eax
c002452f:	84 c0                	test   %al,%al
c0024531:	0f 84 df 00 00 00    	je     c0024616 <keyboard_interrupt+0x24a>
          if (c == 0177 && ctrl && alt)
c0024537:	8a 45 eb             	mov    -0x15(%ebp),%al
c002453a:	3c 7f                	cmp    $0x7f,%al
c002453c:	75 11                	jne    c002454f <keyboard_interrupt+0x183>
c002453e:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024542:	74 0b                	je     c002454f <keyboard_interrupt+0x183>
c0024544:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024548:	74 05                	je     c002454f <keyboard_interrupt+0x183>
            shutdown_reboot ();
c002454a:	e8 e5 28 00 00       	call   c0026e34 <shutdown_reboot>
          if (ctrl && c >= 0x40 && c < 0x60) 
c002454f:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024553:	74 19                	je     c002456e <keyboard_interrupt+0x1a2>
c0024555:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024558:	3c 3f                	cmp    $0x3f,%al
c002455a:	76 12                	jbe    c002456e <keyboard_interrupt+0x1a2>
c002455c:	8a 45 eb             	mov    -0x15(%ebp),%al
c002455f:	3c 5f                	cmp    $0x5f,%al
c0024561:	77 0b                	ja     c002456e <keyboard_interrupt+0x1a2>
              c -= 0x40; 
c0024563:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024566:	83 e8 40             	sub    $0x40,%eax
c0024569:	88 45 eb             	mov    %al,-0x15(%ebp)
c002456c:	eb 1f                	jmp    c002458d <keyboard_interrupt+0x1c1>
          else if (shift == caps_lock)
c002456e:	a0 7e a0 03 c0       	mov    0xc003a07e,%al
c0024573:	38 45 ef             	cmp    %al,-0x11(%ebp)
c0024576:	75 15                	jne    c002458d <keyboard_interrupt+0x1c1>
            c = tolower (c);
c0024578:	8a 45 eb             	mov    -0x15(%ebp),%al
c002457b:	0f b6 c0             	movzbl %al,%eax
c002457e:	83 ec 0c             	sub    $0xc,%esp
c0024581:	50                   	push   %eax
c0024582:	e8 c5 fd ff ff       	call   c002434c <tolower>
c0024587:	83 c4 10             	add    $0x10,%esp
c002458a:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (alt)
c002458d:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024591:	74 09                	je     c002459c <keyboard_interrupt+0x1d0>
            c += 0x80;
c0024593:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024596:	83 c0 80             	add    $0xffffff80,%eax
c0024599:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (!input_full ())
c002459c:	e8 3a 21 00 00       	call   c00266db <input_full>
c00245a1:	83 f0 01             	xor    $0x1,%eax
c00245a4:	84 c0                	test   %al,%al
c00245a6:	74 6e                	je     c0024616 <keyboard_interrupt+0x24a>
              key_cnt++;
c00245a8:	a1 80 a0 03 c0       	mov    0xc003a080,%eax
c00245ad:	8b 15 84 a0 03 c0    	mov    0xc003a084,%edx
c00245b3:	83 c0 01             	add    $0x1,%eax
c00245b6:	83 d2 00             	adc    $0x0,%edx
c00245b9:	a3 80 a0 03 c0       	mov    %eax,0xc003a080
c00245be:	89 15 84 a0 03 c0    	mov    %edx,0xc003a084
              input_putc (c);
c00245c4:	8a 45 eb             	mov    -0x15(%ebp),%al
c00245c7:	0f b6 c0             	movzbl %al,%eax
c00245ca:	83 ec 0c             	sub    $0xc,%esp
c00245cd:	50                   	push   %eax
c00245ce:	e8 4a 20 00 00       	call   c002661d <input_putc>
c00245d3:	83 c4 10             	add    $0x10,%esp
      if (!release) 
c00245d6:	eb 3e                	jmp    c0024616 <keyboard_interrupt+0x24a>
      for (key = shift_keys; key->scancode != 0; key++) 
c00245d8:	c7 45 f0 40 0a 03 c0 	movl   $0xc0030a40,-0x10(%ebp)
c00245df:	eb 2a                	jmp    c002460b <keyboard_interrupt+0x23f>
        if (key->scancode == code)
c00245e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00245e4:	8b 00                	mov    (%eax),%eax
c00245e6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00245e9:	75 1c                	jne    c0024607 <keyboard_interrupt+0x23b>
            *key->state_var = !release;
c00245eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00245ee:	8b 50 04             	mov    0x4(%eax),%edx
c00245f1:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00245f5:	85 c0                	test   %eax,%eax
c00245f7:	0f 95 c0             	setne  %al
c00245fa:	83 f0 01             	xor    $0x1,%eax
c00245fd:	0f b6 c0             	movzbl %al,%eax
c0024600:	83 e0 01             	and    $0x1,%eax
c0024603:	88 02                	mov    %al,(%edx)
            break;
c0024605:	eb 10                	jmp    c0024617 <keyboard_interrupt+0x24b>
      for (key = shift_keys; key->scancode != 0; key++) 
c0024607:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c002460b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002460e:	8b 00                	mov    (%eax),%eax
c0024610:	85 c0                	test   %eax,%eax
c0024612:	75 cd                	jne    c00245e1 <keyboard_interrupt+0x215>
}
c0024614:	eb 01                	jmp    c0024617 <keyboard_interrupt+0x24b>
      if (!release) 
c0024616:	90                   	nop
}
c0024617:	90                   	nop
c0024618:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002461b:	c9                   	leave  
c002461c:	c3                   	ret    

c002461d <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c002461d:	55                   	push   %ebp
c002461e:	89 e5                	mov    %esp,%ebp
c0024620:	53                   	push   %ebx
c0024621:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c0024624:	eb 56                	jmp    c002467c <map_key+0x5f>
    if (scancode >= k->first_scancode
c0024626:	8b 45 08             	mov    0x8(%ebp),%eax
c0024629:	8a 00                	mov    (%eax),%al
c002462b:	0f b6 c0             	movzbl %al,%eax
c002462e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024631:	77 45                	ja     c0024678 <map_key+0x5b>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024633:	8b 45 08             	mov    0x8(%ebp),%eax
c0024636:	8a 00                	mov    (%eax),%al
c0024638:	0f b6 d8             	movzbl %al,%ebx
c002463b:	8b 45 08             	mov    0x8(%ebp),%eax
c002463e:	8b 40 04             	mov    0x4(%eax),%eax
c0024641:	83 ec 0c             	sub    $0xc,%esp
c0024644:	50                   	push   %eax
c0024645:	e8 97 45 00 00       	call   c0028be1 <strlen>
c002464a:	83 c4 10             	add    $0x10,%esp
c002464d:	01 d8                	add    %ebx,%eax
c002464f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024652:	76 24                	jbe    c0024678 <map_key+0x5b>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024654:	8b 45 08             	mov    0x8(%ebp),%eax
c0024657:	8b 50 04             	mov    0x4(%eax),%edx
c002465a:	8b 45 08             	mov    0x8(%ebp),%eax
c002465d:	8a 00                	mov    (%eax),%al
c002465f:	0f b6 c0             	movzbl %al,%eax
c0024662:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0024665:	29 c1                	sub    %eax,%ecx
c0024667:	89 c8                	mov    %ecx,%eax
c0024669:	01 d0                	add    %edx,%eax
c002466b:	8a 00                	mov    (%eax),%al
c002466d:	88 c2                	mov    %al,%dl
c002466f:	8b 45 10             	mov    0x10(%ebp),%eax
c0024672:	88 10                	mov    %dl,(%eax)
        return true; 
c0024674:	b0 01                	mov    $0x1,%al
c0024676:	eb 0f                	jmp    c0024687 <map_key+0x6a>
  for (; k->first_scancode != 0; k++)
c0024678:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c002467c:	8b 45 08             	mov    0x8(%ebp),%eax
c002467f:	8a 00                	mov    (%eax),%al
c0024681:	84 c0                	test   %al,%al
c0024683:	75 a1                	jne    c0024626 <map_key+0x9>
      }

  return false;
c0024685:	b0 00                	mov    $0x0,%al
}
c0024687:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002468a:	c9                   	leave  
c002468b:	c3                   	ret    

c002468c <inb>:
{
c002468c:	55                   	push   %ebp
c002468d:	89 e5                	mov    %esp,%ebp
c002468f:	83 ec 14             	sub    $0x14,%esp
c0024692:	8b 45 08             	mov    0x8(%ebp),%eax
c0024695:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024699:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002469c:	89 c2                	mov    %eax,%edx
c002469e:	ec                   	in     (%dx),%al
c002469f:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00246a2:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c00246a5:	c9                   	leave  
c00246a6:	c3                   	ret    

c00246a7 <outb>:
{
c00246a7:	55                   	push   %ebp
c00246a8:	89 e5                	mov    %esp,%ebp
c00246aa:	83 ec 08             	sub    $0x8,%esp
c00246ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00246b0:	8b 55 0c             	mov    0xc(%ebp),%edx
c00246b3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00246b7:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00246ba:	8a 45 f8             	mov    -0x8(%ebp),%al
c00246bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00246c0:	ee                   	out    %al,(%dx)
}
c00246c1:	90                   	nop
c00246c2:	c9                   	leave  
c00246c3:	c3                   	ret    

c00246c4 <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c00246c4:	55                   	push   %ebp
c00246c5:	89 e5                	mov    %esp,%ebp
c00246c7:	83 ec 08             	sub    $0x8,%esp
c00246ca:	8b 55 08             	mov    0x8(%ebp),%edx
c00246cd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00246d0:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00246d4:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00246d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00246db:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00246de:	66 ef                	out    %ax,(%dx)
}
c00246e0:	90                   	nop
c00246e1:	c9                   	leave  
c00246e2:	c3                   	ret    

c00246e3 <ptov>:
{
c00246e3:	55                   	push   %ebp
c00246e4:	89 e5                	mov    %esp,%ebp
c00246e6:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00246e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00246ec:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00246f1:	76 1e                	jbe    c0024711 <ptov+0x2e>
c00246f3:	83 ec 0c             	sub    $0xc,%esp
c00246f6:	68 78 0a 03 c0       	push   $0xc0030a78
c00246fb:	68 93 0a 03 c0       	push   $0xc0030a93
c0024700:	68 dc 0a 03 c0       	push   $0xc0030adc
c0024705:	6a 4a                	push   $0x4a
c0024707:	68 aa 0a 03 c0       	push   $0xc0030aaa
c002470c:	e8 5d 50 00 00       	call   c002976e <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0024711:	8b 45 08             	mov    0x8(%ebp),%eax
c0024714:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0024719:	c9                   	leave  
c002471a:	c3                   	ret    

c002471b <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c002471b:	55                   	push   %ebp
c002471c:	89 e5                	mov    %esp,%ebp
c002471e:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0024721:	a0 94 a0 03 c0       	mov    0xc003a094,%al
c0024726:	83 f0 01             	xor    $0x1,%eax
c0024729:	84 c0                	test   %al,%al
c002472b:	74 31                	je     c002475e <init+0x43>
    {
      fb = ptov (0xb8000);
c002472d:	83 ec 0c             	sub    $0xc,%esp
c0024730:	68 00 80 0b 00       	push   $0xb8000
c0024735:	e8 a9 ff ff ff       	call   c00246e3 <ptov>
c002473a:	83 c4 10             	add    $0x10,%esp
c002473d:	a3 90 a0 03 c0       	mov    %eax,0xc003a090
      find_cursor (&cx, &cy);
c0024742:	83 ec 08             	sub    $0x8,%esp
c0024745:	68 8c a0 03 c0       	push   $0xc003a08c
c002474a:	68 88 a0 03 c0       	push   $0xc003a088
c002474f:	e8 8f 02 00 00       	call   c00249e3 <find_cursor>
c0024754:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0024757:	c6 05 94 a0 03 c0 01 	movb   $0x1,0xc003a094
    }
}
c002475e:	90                   	nop
c002475f:	c9                   	leave  
c0024760:	c3                   	ret    

c0024761 <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0024761:	55                   	push   %ebp
c0024762:	89 e5                	mov    %esp,%ebp
c0024764:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0024767:	e8 57 ce ff ff       	call   c00215c3 <intr_disable>
c002476c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c002476f:	e8 a7 ff ff ff       	call   c002471b <init>
  
  switch (c) 
c0024774:	8b 45 08             	mov    0x8(%ebp),%eax
c0024777:	83 e8 07             	sub    $0x7,%eax
c002477a:	83 f8 06             	cmp    $0x6,%eax
c002477d:	0f 87 8b 00 00 00    	ja     c002480e <vga_putc+0xad>
c0024783:	8b 04 85 c0 0a 03 c0 	mov    -0x3ffcf540(,%eax,4),%eax
c002478a:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c002478c:	e8 95 01 00 00       	call   c0024926 <newline>
      break;
c0024791:	e9 e2 00 00 00       	jmp    c0024878 <vga_putc+0x117>

    case '\f':
      cls ();
c0024796:	e8 f3 00 00 00       	call   c002488e <cls>
      break;
c002479b:	e9 d8 00 00 00       	jmp    c0024878 <vga_putc+0x117>

    case '\b':
      if (cx > 0)
c00247a0:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c00247a5:	85 c0                	test   %eax,%eax
c00247a7:	0f 84 c4 00 00 00    	je     c0024871 <vga_putc+0x110>
        cx--;
c00247ad:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c00247b2:	48                   	dec    %eax
c00247b3:	a3 88 a0 03 c0       	mov    %eax,0xc003a088
      break;
c00247b8:	e9 b4 00 00 00       	jmp    c0024871 <vga_putc+0x110>
      
    case '\r':
      cx = 0;
c00247bd:	c7 05 88 a0 03 c0 00 	movl   $0x0,0xc003a088
c00247c4:	00 00 00 
      break;
c00247c7:	e9 ac 00 00 00       	jmp    c0024878 <vga_putc+0x117>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c00247cc:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c00247d1:	83 c0 08             	add    $0x8,%eax
c00247d4:	83 e0 f8             	and    $0xfffffff8,%eax
c00247d7:	a3 88 a0 03 c0       	mov    %eax,0xc003a088
      if (cx >= COL_CNT)
c00247dc:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c00247e1:	83 f8 4f             	cmp    $0x4f,%eax
c00247e4:	0f 86 8a 00 00 00    	jbe    c0024874 <vga_putc+0x113>
        newline ();
c00247ea:	e8 37 01 00 00       	call   c0024926 <newline>
      break;
c00247ef:	e9 80 00 00 00       	jmp    c0024874 <vga_putc+0x113>

    case '\a':
      intr_set_level (old_level);
c00247f4:	83 ec 0c             	sub    $0xc,%esp
c00247f7:	ff 75 f4             	pushl  -0xc(%ebp)
c00247fa:	e8 6c cd ff ff       	call   c002156b <intr_set_level>
c00247ff:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c0024802:	e8 61 28 00 00       	call   c0027068 <speaker_beep>
      intr_disable ();
c0024807:	e8 b7 cd ff ff       	call   c00215c3 <intr_disable>
      break;
c002480c:	eb 6a                	jmp    c0024878 <vga_putc+0x117>
      
    default:
      fb[cy][cx][0] = c;
c002480e:	8b 0d 90 a0 03 c0    	mov    0xc003a090,%ecx
c0024814:	8b 15 8c a0 03 c0    	mov    0xc003a08c,%edx
c002481a:	89 d0                	mov    %edx,%eax
c002481c:	c1 e0 02             	shl    $0x2,%eax
c002481f:	01 d0                	add    %edx,%eax
c0024821:	c1 e0 05             	shl    $0x5,%eax
c0024824:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024827:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c002482c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c002482f:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024832:	8b 0d 90 a0 03 c0    	mov    0xc003a090,%ecx
c0024838:	8b 15 8c a0 03 c0    	mov    0xc003a08c,%edx
c002483e:	89 d0                	mov    %edx,%eax
c0024840:	c1 e0 02             	shl    $0x2,%eax
c0024843:	01 d0                	add    %edx,%eax
c0024845:	c1 e0 05             	shl    $0x5,%eax
c0024848:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c002484b:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c0024850:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c0024855:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c002485a:	40                   	inc    %eax
c002485b:	a3 88 a0 03 c0       	mov    %eax,0xc003a088
c0024860:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c0024865:	83 f8 4f             	cmp    $0x4f,%eax
c0024868:	76 0d                	jbe    c0024877 <vga_putc+0x116>
        newline ();
c002486a:	e8 b7 00 00 00       	call   c0024926 <newline>
      break;
c002486f:	eb 06                	jmp    c0024877 <vga_putc+0x116>
      break;
c0024871:	90                   	nop
c0024872:	eb 04                	jmp    c0024878 <vga_putc+0x117>
      break;
c0024874:	90                   	nop
c0024875:	eb 01                	jmp    c0024878 <vga_putc+0x117>
      break;
c0024877:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c0024878:	e8 0a 01 00 00       	call   c0024987 <move_cursor>

  intr_set_level (old_level);
c002487d:	83 ec 0c             	sub    $0xc,%esp
c0024880:	ff 75 f4             	pushl  -0xc(%ebp)
c0024883:	e8 e3 cc ff ff       	call   c002156b <intr_set_level>
c0024888:	83 c4 10             	add    $0x10,%esp
}
c002488b:	90                   	nop
c002488c:	c9                   	leave  
c002488d:	c3                   	ret    

c002488e <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c002488e:	55                   	push   %ebp
c002488f:	89 e5                	mov    %esp,%ebp
c0024891:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0024894:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002489b:	eb 11                	jmp    c00248ae <cls+0x20>
    clear_row (y);
c002489d:	83 ec 0c             	sub    $0xc,%esp
c00248a0:	ff 75 f4             	pushl  -0xc(%ebp)
c00248a3:	e8 28 00 00 00       	call   c00248d0 <clear_row>
c00248a8:	83 c4 10             	add    $0x10,%esp
  for (y = 0; y < ROW_CNT; y++)
c00248ab:	ff 45 f4             	incl   -0xc(%ebp)
c00248ae:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c00248b2:	76 e9                	jbe    c002489d <cls+0xf>

  cx = cy = 0;
c00248b4:	c7 05 8c a0 03 c0 00 	movl   $0x0,0xc003a08c
c00248bb:	00 00 00 
c00248be:	a1 8c a0 03 c0       	mov    0xc003a08c,%eax
c00248c3:	a3 88 a0 03 c0       	mov    %eax,0xc003a088
  move_cursor ();
c00248c8:	e8 ba 00 00 00       	call   c0024987 <move_cursor>
}
c00248cd:	90                   	nop
c00248ce:	c9                   	leave  
c00248cf:	c3                   	ret    

c00248d0 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c00248d0:	55                   	push   %ebp
c00248d1:	89 e5                	mov    %esp,%ebp
c00248d3:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c00248d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00248dd:	eb 3e                	jmp    c002491d <clear_row+0x4d>
    {
      fb[y][x][0] = ' ';
c00248df:	8b 0d 90 a0 03 c0    	mov    0xc003a090,%ecx
c00248e5:	8b 55 08             	mov    0x8(%ebp),%edx
c00248e8:	89 d0                	mov    %edx,%eax
c00248ea:	c1 e0 02             	shl    $0x2,%eax
c00248ed:	01 d0                	add    %edx,%eax
c00248ef:	c1 e0 05             	shl    $0x5,%eax
c00248f2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00248f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00248f8:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c00248fc:	8b 0d 90 a0 03 c0    	mov    0xc003a090,%ecx
c0024902:	8b 55 08             	mov    0x8(%ebp),%edx
c0024905:	89 d0                	mov    %edx,%eax
c0024907:	c1 e0 02             	shl    $0x2,%eax
c002490a:	01 d0                	add    %edx,%eax
c002490c:	c1 e0 05             	shl    $0x5,%eax
c002490f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024912:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024915:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
  for (x = 0; x < COL_CNT; x++)
c002491a:	ff 45 fc             	incl   -0x4(%ebp)
c002491d:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c0024921:	76 bc                	jbe    c00248df <clear_row+0xf>
    }
}
c0024923:	90                   	nop
c0024924:	c9                   	leave  
c0024925:	c3                   	ret    

c0024926 <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c0024926:	55                   	push   %ebp
c0024927:	89 e5                	mov    %esp,%ebp
c0024929:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c002492c:	c7 05 88 a0 03 c0 00 	movl   $0x0,0xc003a088
c0024933:	00 00 00 
  cy++;
c0024936:	a1 8c a0 03 c0       	mov    0xc003a08c,%eax
c002493b:	40                   	inc    %eax
c002493c:	a3 8c a0 03 c0       	mov    %eax,0xc003a08c
  if (cy >= ROW_CNT)
c0024941:	a1 8c a0 03 c0       	mov    0xc003a08c,%eax
c0024946:	83 f8 18             	cmp    $0x18,%eax
c0024949:	76 39                	jbe    c0024984 <newline+0x5e>
    {
      cy = ROW_CNT - 1;
c002494b:	c7 05 8c a0 03 c0 18 	movl   $0x18,0xc003a08c
c0024952:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024955:	a1 90 a0 03 c0       	mov    0xc003a090,%eax
c002495a:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0024960:	a1 90 a0 03 c0       	mov    0xc003a090,%eax
c0024965:	83 ec 04             	sub    $0x4,%esp
c0024968:	68 00 0f 00 00       	push   $0xf00
c002496d:	52                   	push   %edx
c002496e:	50                   	push   %eax
c002496f:	e8 c8 3c 00 00       	call   c002863c <memmove>
c0024974:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c0024977:	83 ec 0c             	sub    $0xc,%esp
c002497a:	6a 18                	push   $0x18
c002497c:	e8 4f ff ff ff       	call   c00248d0 <clear_row>
c0024981:	83 c4 10             	add    $0x10,%esp
    }
}
c0024984:	90                   	nop
c0024985:	c9                   	leave  
c0024986:	c3                   	ret    

c0024987 <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c0024987:	55                   	push   %ebp
c0024988:	89 e5                	mov    %esp,%ebp
c002498a:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c002498d:	a1 8c a0 03 c0       	mov    0xc003a08c,%eax
c0024992:	89 c2                	mov    %eax,%edx
c0024994:	89 d0                	mov    %edx,%eax
c0024996:	c1 e0 02             	shl    $0x2,%eax
c0024999:	01 d0                	add    %edx,%eax
c002499b:	c1 e0 04             	shl    $0x4,%eax
c002499e:	89 c2                	mov    %eax,%edx
c00249a0:	a1 88 a0 03 c0       	mov    0xc003a088,%eax
c00249a5:	01 d0                	add    %edx,%eax
c00249a7:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c00249ab:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c00249af:	b0 00                	mov    $0x0,%al
c00249b1:	83 c8 0e             	or     $0xe,%eax
c00249b4:	0f b7 c0             	movzwl %ax,%eax
c00249b7:	50                   	push   %eax
c00249b8:	68 d4 03 00 00       	push   $0x3d4
c00249bd:	e8 02 fd ff ff       	call   c00246c4 <outw>
c00249c2:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c00249c5:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c00249c9:	c1 e0 08             	shl    $0x8,%eax
c00249cc:	83 c8 0f             	or     $0xf,%eax
c00249cf:	0f b7 c0             	movzwl %ax,%eax
c00249d2:	50                   	push   %eax
c00249d3:	68 d4 03 00 00       	push   $0x3d4
c00249d8:	e8 e7 fc ff ff       	call   c00246c4 <outw>
c00249dd:	83 c4 08             	add    $0x8,%esp
}
c00249e0:	90                   	nop
c00249e1:	c9                   	leave  
c00249e2:	c3                   	ret    

c00249e3 <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c00249e3:	55                   	push   %ebp
c00249e4:	89 e5                	mov    %esp,%ebp
c00249e6:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c00249e9:	6a 0e                	push   $0xe
c00249eb:	68 d4 03 00 00       	push   $0x3d4
c00249f0:	e8 b2 fc ff ff       	call   c00246a7 <outb>
c00249f5:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c00249f8:	68 d5 03 00 00       	push   $0x3d5
c00249fd:	e8 8a fc ff ff       	call   c002468c <inb>
c0024a02:	83 c4 04             	add    $0x4,%esp
c0024a05:	0f b6 c0             	movzbl %al,%eax
c0024a08:	c1 e0 08             	shl    $0x8,%eax
c0024a0b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c0024a0f:	6a 0f                	push   $0xf
c0024a11:	68 d4 03 00 00       	push   $0x3d4
c0024a16:	e8 8c fc ff ff       	call   c00246a7 <outb>
c0024a1b:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c0024a1e:	68 d5 03 00 00       	push   $0x3d5
c0024a23:	e8 64 fc ff ff       	call   c002468c <inb>
c0024a28:	83 c4 04             	add    $0x4,%esp
c0024a2b:	0f b6 c0             	movzbl %al,%eax
c0024a2e:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c0024a32:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024a36:	b9 50 00 00 00       	mov    $0x50,%ecx
c0024a3b:	ba 00 00 00 00       	mov    $0x0,%edx
c0024a40:	66 f7 f1             	div    %cx
c0024a43:	89 d0                	mov    %edx,%eax
c0024a45:	0f b7 d0             	movzwl %ax,%edx
c0024a48:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a4b:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0024a4d:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024a51:	0f b7 d0             	movzwl %ax,%edx
c0024a54:	89 d0                	mov    %edx,%eax
c0024a56:	c1 e0 02             	shl    $0x2,%eax
c0024a59:	01 d0                	add    %edx,%eax
c0024a5b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0024a62:	01 c8                	add    %ecx,%eax
c0024a64:	01 c0                	add    %eax,%eax
c0024a66:	01 d0                	add    %edx,%eax
c0024a68:	89 c1                	mov    %eax,%ecx
c0024a6a:	c1 e1 08             	shl    $0x8,%ecx
c0024a6d:	01 c8                	add    %ecx,%eax
c0024a6f:	c1 e0 02             	shl    $0x2,%eax
c0024a72:	01 d0                	add    %edx,%eax
c0024a74:	c1 e8 10             	shr    $0x10,%eax
c0024a77:	66 c1 e8 06          	shr    $0x6,%ax
c0024a7b:	0f b7 d0             	movzwl %ax,%edx
c0024a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024a81:	89 10                	mov    %edx,(%eax)
}
c0024a83:	90                   	nop
c0024a84:	c9                   	leave  
c0024a85:	c3                   	ret    

c0024a86 <inb>:
{
c0024a86:	55                   	push   %ebp
c0024a87:	89 e5                	mov    %esp,%ebp
c0024a89:	83 ec 14             	sub    $0x14,%esp
c0024a8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a8f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024a93:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024a96:	89 c2                	mov    %eax,%edx
c0024a98:	ec                   	in     (%dx),%al
c0024a99:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024a9c:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024a9f:	c9                   	leave  
c0024aa0:	c3                   	ret    

c0024aa1 <outb>:
{
c0024aa1:	55                   	push   %ebp
c0024aa2:	89 e5                	mov    %esp,%ebp
c0024aa4:	83 ec 08             	sub    $0x8,%esp
c0024aa7:	8b 45 08             	mov    0x8(%ebp),%eax
c0024aaa:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024aad:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024ab1:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024ab4:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024ab7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024aba:	ee                   	out    %al,(%dx)
}
c0024abb:	90                   	nop
c0024abc:	c9                   	leave  
c0024abd:	c3                   	ret    

c0024abe <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024abe:	55                   	push   %ebp
c0024abf:	89 e5                	mov    %esp,%ebp
c0024ac1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c0024ac4:	a1 a0 a0 03 c0       	mov    0xc003a0a0,%eax
c0024ac9:	85 c0                	test   %eax,%eax
c0024acb:	74 1e                	je     c0024aeb <init_poll+0x2d>
c0024acd:	83 ec 0c             	sub    $0xc,%esp
c0024ad0:	68 e4 0a 03 c0       	push   $0xc0030ae4
c0024ad5:	68 f3 0a 03 c0       	push   $0xc0030af3
c0024ada:	68 70 0b 03 c0       	push   $0xc0030b70
c0024adf:	6a 45                	push   $0x45
c0024ae1:	68 0a 0b 03 c0       	push   $0xc0030b0a
c0024ae6:	e8 83 4c 00 00       	call   c002976e <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c0024aeb:	83 ec 08             	sub    $0x8,%esp
c0024aee:	6a 00                	push   $0x0
c0024af0:	68 f9 03 00 00       	push   $0x3f9
c0024af5:	e8 a7 ff ff ff       	call   c0024aa1 <outb>
c0024afa:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c0024afd:	83 ec 08             	sub    $0x8,%esp
c0024b00:	6a 00                	push   $0x0
c0024b02:	68 fa 03 00 00       	push   $0x3fa
c0024b07:	e8 95 ff ff ff       	call   c0024aa1 <outb>
c0024b0c:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c0024b0f:	83 ec 0c             	sub    $0xc,%esp
c0024b12:	68 80 25 00 00       	push   $0x2580
c0024b17:	e8 e8 01 00 00       	call   c0024d04 <set_serial>
c0024b1c:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c0024b1f:	83 ec 08             	sub    $0x8,%esp
c0024b22:	6a 08                	push   $0x8
c0024b24:	68 fc 03 00 00       	push   $0x3fc
c0024b29:	e8 73 ff ff ff       	call   c0024aa1 <outb>
c0024b2e:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c0024b31:	83 ec 0c             	sub    $0xc,%esp
c0024b34:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024b39:	e8 dc 1b 00 00       	call   c002671a <intq_init>
c0024b3e:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c0024b41:	c7 05 a0 a0 03 c0 01 	movl   $0x1,0xc003a0a0
c0024b48:	00 00 00 
} 
c0024b4b:	90                   	nop
c0024b4c:	c9                   	leave  
c0024b4d:	c3                   	ret    

c0024b4e <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024b4e:	55                   	push   %ebp
c0024b4f:	89 e5                	mov    %esp,%ebp
c0024b51:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c0024b54:	a1 a0 a0 03 c0       	mov    0xc003a0a0,%eax
c0024b59:	85 c0                	test   %eax,%eax
c0024b5b:	75 05                	jne    c0024b62 <serial_init_queue+0x14>
    init_poll ();
c0024b5d:	e8 5c ff ff ff       	call   c0024abe <init_poll>
  ASSERT (mode == POLL);
c0024b62:	a1 a0 a0 03 c0       	mov    0xc003a0a0,%eax
c0024b67:	83 f8 01             	cmp    $0x1,%eax
c0024b6a:	74 1e                	je     c0024b8a <serial_init_queue+0x3c>
c0024b6c:	83 ec 0c             	sub    $0xc,%esp
c0024b6f:	68 21 0b 03 c0       	push   $0xc0030b21
c0024b74:	68 f3 0a 03 c0       	push   $0xc0030af3
c0024b79:	68 7c 0b 03 c0       	push   $0xc0030b7c
c0024b7e:	6a 58                	push   $0x58
c0024b80:	68 0a 0b 03 c0       	push   $0xc0030b0a
c0024b85:	e8 e4 4b 00 00       	call   c002976e <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024b8a:	83 ec 04             	sub    $0x4,%esp
c0024b8d:	68 2e 0b 03 c0       	push   $0xc0030b2e
c0024b92:	68 8d 4e 02 c0       	push   $0xc0024e8d
c0024b97:	6a 24                	push   $0x24
c0024b99:	e8 44 cc ff ff       	call   c00217e2 <intr_register_ext>
c0024b9e:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0024ba1:	c7 05 a0 a0 03 c0 02 	movl   $0x2,0xc003a0a0
c0024ba8:	00 00 00 
  old_level = intr_disable ();
c0024bab:	e8 13 ca ff ff       	call   c00215c3 <intr_disable>
c0024bb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c0024bb3:	e8 f5 01 00 00       	call   c0024dad <write_ier>
  intr_set_level (old_level);
c0024bb8:	83 ec 0c             	sub    $0xc,%esp
c0024bbb:	ff 75 f4             	pushl  -0xc(%ebp)
c0024bbe:	e8 a8 c9 ff ff       	call   c002156b <intr_set_level>
c0024bc3:	83 c4 10             	add    $0x10,%esp
}
c0024bc6:	90                   	nop
c0024bc7:	c9                   	leave  
c0024bc8:	c3                   	ret    

c0024bc9 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0024bc9:	55                   	push   %ebp
c0024bca:	89 e5                	mov    %esp,%ebp
c0024bcc:	83 ec 28             	sub    $0x28,%esp
c0024bcf:	8b 45 08             	mov    0x8(%ebp),%eax
c0024bd2:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c0024bd5:	e8 e9 c9 ff ff       	call   c00215c3 <intr_disable>
c0024bda:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c0024bdd:	a1 a0 a0 03 c0       	mov    0xc003a0a0,%eax
c0024be2:	83 f8 02             	cmp    $0x2,%eax
c0024be5:	74 20                	je     c0024c07 <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c0024be7:	a1 a0 a0 03 c0       	mov    0xc003a0a0,%eax
c0024bec:	85 c0                	test   %eax,%eax
c0024bee:	75 05                	jne    c0024bf5 <serial_putc+0x2c>
        init_poll ();
c0024bf0:	e8 c9 fe ff ff       	call   c0024abe <init_poll>
      putc_poll (byte); 
c0024bf5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024bf9:	83 ec 0c             	sub    $0xc,%esp
c0024bfc:	50                   	push   %eax
c0024bfd:	e8 22 02 00 00       	call   c0024e24 <putc_poll>
c0024c02:	83 c4 10             	add    $0x10,%esp
c0024c05:	eb 53                	jmp    c0024c5a <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0024c07:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024c0b:	75 33                	jne    c0024c40 <serial_putc+0x77>
c0024c0d:	83 ec 0c             	sub    $0xc,%esp
c0024c10:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024c15:	e8 84 1b 00 00       	call   c002679e <intq_full>
c0024c1a:	83 c4 10             	add    $0x10,%esp
c0024c1d:	84 c0                	test   %al,%al
c0024c1f:	74 1f                	je     c0024c40 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c0024c21:	83 ec 0c             	sub    $0xc,%esp
c0024c24:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024c29:	e8 be 1b 00 00       	call   c00267ec <intq_getc>
c0024c2e:	83 c4 10             	add    $0x10,%esp
c0024c31:	0f b6 c0             	movzbl %al,%eax
c0024c34:	83 ec 0c             	sub    $0xc,%esp
c0024c37:	50                   	push   %eax
c0024c38:	e8 e7 01 00 00       	call   c0024e24 <putc_poll>
c0024c3d:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0024c40:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024c44:	83 ec 08             	sub    $0x8,%esp
c0024c47:	50                   	push   %eax
c0024c48:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024c4d:	e8 7a 1c 00 00       	call   c00268cc <intq_putc>
c0024c52:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0024c55:	e8 53 01 00 00       	call   c0024dad <write_ier>
    }
  
  intr_set_level (old_level);
c0024c5a:	83 ec 0c             	sub    $0xc,%esp
c0024c5d:	ff 75 f4             	pushl  -0xc(%ebp)
c0024c60:	e8 06 c9 ff ff       	call   c002156b <intr_set_level>
c0024c65:	83 c4 10             	add    $0x10,%esp
}
c0024c68:	90                   	nop
c0024c69:	c9                   	leave  
c0024c6a:	c3                   	ret    

c0024c6b <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0024c6b:	55                   	push   %ebp
c0024c6c:	89 e5                	mov    %esp,%ebp
c0024c6e:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024c71:	e8 4d c9 ff ff       	call   c00215c3 <intr_disable>
c0024c76:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0024c79:	eb 1f                	jmp    c0024c9a <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c0024c7b:	83 ec 0c             	sub    $0xc,%esp
c0024c7e:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024c83:	e8 64 1b 00 00       	call   c00267ec <intq_getc>
c0024c88:	83 c4 10             	add    $0x10,%esp
c0024c8b:	0f b6 c0             	movzbl %al,%eax
c0024c8e:	83 ec 0c             	sub    $0xc,%esp
c0024c91:	50                   	push   %eax
c0024c92:	e8 8d 01 00 00       	call   c0024e24 <putc_poll>
c0024c97:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0024c9a:	83 ec 0c             	sub    $0xc,%esp
c0024c9d:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024ca2:	e8 b7 1a 00 00       	call   c002675e <intq_empty>
c0024ca7:	83 c4 10             	add    $0x10,%esp
c0024caa:	83 f0 01             	xor    $0x1,%eax
c0024cad:	84 c0                	test   %al,%al
c0024caf:	75 ca                	jne    c0024c7b <serial_flush+0x10>
  intr_set_level (old_level);
c0024cb1:	83 ec 0c             	sub    $0xc,%esp
c0024cb4:	ff 75 f4             	pushl  -0xc(%ebp)
c0024cb7:	e8 af c8 ff ff       	call   c002156b <intr_set_level>
c0024cbc:	83 c4 10             	add    $0x10,%esp
}
c0024cbf:	90                   	nop
c0024cc0:	c9                   	leave  
c0024cc1:	c3                   	ret    

c0024cc2 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c0024cc2:	55                   	push   %ebp
c0024cc3:	89 e5                	mov    %esp,%ebp
c0024cc5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024cc8:	e8 81 c8 ff ff       	call   c002154e <intr_get_level>
c0024ccd:	85 c0                	test   %eax,%eax
c0024ccf:	74 21                	je     c0024cf2 <serial_notify+0x30>
c0024cd1:	83 ec 0c             	sub    $0xc,%esp
c0024cd4:	68 35 0b 03 c0       	push   $0xc0030b35
c0024cd9:	68 f3 0a 03 c0       	push   $0xc0030af3
c0024cde:	68 90 0b 03 c0       	push   $0xc0030b90
c0024ce3:	68 96 00 00 00       	push   $0x96
c0024ce8:	68 0a 0b 03 c0       	push   $0xc0030b0a
c0024ced:	e8 7c 4a 00 00       	call   c002976e <debug_panic>
  if (mode == QUEUE)
c0024cf2:	a1 a0 a0 03 c0       	mov    0xc003a0a0,%eax
c0024cf7:	83 f8 02             	cmp    $0x2,%eax
c0024cfa:	75 05                	jne    c0024d01 <serial_notify+0x3f>
    write_ier ();
c0024cfc:	e8 ac 00 00 00       	call   c0024dad <write_ier>
}
c0024d01:	90                   	nop
c0024d02:	c9                   	leave  
c0024d03:	c3                   	ret    

c0024d04 <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0024d04:	55                   	push   %ebp
c0024d05:	89 e5                	mov    %esp,%ebp
c0024d07:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c0024d0a:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0024d11:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024d14:	99                   	cltd   
c0024d15:	f7 7d 08             	idivl  0x8(%ebp)
c0024d18:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c0024d1c:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0024d23:	7e 09                	jle    c0024d2e <set_serial+0x2a>
c0024d25:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c0024d2c:	7e 21                	jle    c0024d4f <set_serial+0x4b>
c0024d2e:	83 ec 0c             	sub    $0xc,%esp
c0024d31:	68 53 0b 03 c0       	push   $0xc0030b53
c0024d36:	68 f3 0a 03 c0       	push   $0xc0030af3
c0024d3b:	68 a0 0b 03 c0       	push   $0xc0030ba0
c0024d40:	68 a2 00 00 00       	push   $0xa2
c0024d45:	68 0a 0b 03 c0       	push   $0xc0030b0a
c0024d4a:	e8 1f 4a 00 00       	call   c002976e <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0024d4f:	83 ec 08             	sub    $0x8,%esp
c0024d52:	68 83 00 00 00       	push   $0x83
c0024d57:	68 fb 03 00 00       	push   $0x3fb
c0024d5c:	e8 40 fd ff ff       	call   c0024aa1 <outb>
c0024d61:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0024d64:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0024d68:	0f b6 c0             	movzbl %al,%eax
c0024d6b:	83 ec 08             	sub    $0x8,%esp
c0024d6e:	50                   	push   %eax
c0024d6f:	68 f8 03 00 00       	push   $0x3f8
c0024d74:	e8 28 fd ff ff       	call   c0024aa1 <outb>
c0024d79:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c0024d7c:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0024d80:	66 c1 e8 08          	shr    $0x8,%ax
c0024d84:	0f b6 c0             	movzbl %al,%eax
c0024d87:	83 ec 08             	sub    $0x8,%esp
c0024d8a:	50                   	push   %eax
c0024d8b:	68 f9 03 00 00       	push   $0x3f9
c0024d90:	e8 0c fd ff ff       	call   c0024aa1 <outb>
c0024d95:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c0024d98:	83 ec 08             	sub    $0x8,%esp
c0024d9b:	6a 03                	push   $0x3
c0024d9d:	68 fb 03 00 00       	push   $0x3fb
c0024da2:	e8 fa fc ff ff       	call   c0024aa1 <outb>
c0024da7:	83 c4 10             	add    $0x10,%esp
}
c0024daa:	90                   	nop
c0024dab:	c9                   	leave  
c0024dac:	c3                   	ret    

c0024dad <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024dad:	55                   	push   %ebp
c0024dae:	89 e5                	mov    %esp,%ebp
c0024db0:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c0024db3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0024db7:	e8 92 c7 ff ff       	call   c002154e <intr_get_level>
c0024dbc:	85 c0                	test   %eax,%eax
c0024dbe:	74 21                	je     c0024de1 <write_ier+0x34>
c0024dc0:	83 ec 0c             	sub    $0xc,%esp
c0024dc3:	68 35 0b 03 c0       	push   $0xc0030b35
c0024dc8:	68 f3 0a 03 c0       	push   $0xc0030af3
c0024dcd:	68 ac 0b 03 c0       	push   $0xc0030bac
c0024dd2:	68 b5 00 00 00       	push   $0xb5
c0024dd7:	68 0a 0b 03 c0       	push   $0xc0030b0a
c0024ddc:	e8 8d 49 00 00       	call   c002976e <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024de1:	83 ec 0c             	sub    $0xc,%esp
c0024de4:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024de9:	e8 70 19 00 00       	call   c002675e <intq_empty>
c0024dee:	83 c4 10             	add    $0x10,%esp
c0024df1:	83 f0 01             	xor    $0x1,%eax
c0024df4:	84 c0                	test   %al,%al
c0024df6:	74 04                	je     c0024dfc <write_ier+0x4f>
    ier |= IER_XMIT;
c0024df8:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024dfc:	e8 da 18 00 00       	call   c00266db <input_full>
c0024e01:	83 f0 01             	xor    $0x1,%eax
c0024e04:	84 c0                	test   %al,%al
c0024e06:	74 04                	je     c0024e0c <write_ier+0x5f>
    ier |= IER_RECV;
c0024e08:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c0024e0c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0024e10:	83 ec 08             	sub    $0x8,%esp
c0024e13:	50                   	push   %eax
c0024e14:	68 f9 03 00 00       	push   $0x3f9
c0024e19:	e8 83 fc ff ff       	call   c0024aa1 <outb>
c0024e1e:	83 c4 10             	add    $0x10,%esp
}
c0024e21:	90                   	nop
c0024e22:	c9                   	leave  
c0024e23:	c3                   	ret    

c0024e24 <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0024e24:	55                   	push   %ebp
c0024e25:	89 e5                	mov    %esp,%ebp
c0024e27:	83 ec 18             	sub    $0x18,%esp
c0024e2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e2d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0024e30:	e8 19 c7 ff ff       	call   c002154e <intr_get_level>
c0024e35:	85 c0                	test   %eax,%eax
c0024e37:	74 22                	je     c0024e5b <putc_poll+0x37>
c0024e39:	83 ec 0c             	sub    $0xc,%esp
c0024e3c:	68 35 0b 03 c0       	push   $0xc0030b35
c0024e41:	68 f3 0a 03 c0       	push   $0xc0030af3
c0024e46:	68 b8 0b 03 c0       	push   $0xc0030bb8
c0024e4b:	68 c9 00 00 00       	push   $0xc9
c0024e50:	68 0a 0b 03 c0       	push   $0xc0030b0a
c0024e55:	e8 14 49 00 00       	call   c002976e <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c0024e5a:	90                   	nop
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024e5b:	83 ec 0c             	sub    $0xc,%esp
c0024e5e:	68 fd 03 00 00       	push   $0x3fd
c0024e63:	e8 1e fc ff ff       	call   c0024a86 <inb>
c0024e68:	83 c4 10             	add    $0x10,%esp
c0024e6b:	0f b6 c0             	movzbl %al,%eax
c0024e6e:	83 e0 20             	and    $0x20,%eax
c0024e71:	85 c0                	test   %eax,%eax
c0024e73:	74 e5                	je     c0024e5a <putc_poll+0x36>
  outb (THR_REG, byte);
c0024e75:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0024e79:	83 ec 08             	sub    $0x8,%esp
c0024e7c:	50                   	push   %eax
c0024e7d:	68 f8 03 00 00       	push   $0x3f8
c0024e82:	e8 1a fc ff ff       	call   c0024aa1 <outb>
c0024e87:	83 c4 10             	add    $0x10,%esp
}
c0024e8a:	90                   	nop
c0024e8b:	c9                   	leave  
c0024e8c:	c3                   	ret    

c0024e8d <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024e8d:	55                   	push   %ebp
c0024e8e:	89 e5                	mov    %esp,%ebp
c0024e90:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c0024e93:	68 fa 03 00 00       	push   $0x3fa
c0024e98:	e8 e9 fb ff ff       	call   c0024a86 <inb>
c0024e9d:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024ea0:	eb 1c                	jmp    c0024ebe <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c0024ea2:	68 f8 03 00 00       	push   $0x3f8
c0024ea7:	e8 da fb ff ff       	call   c0024a86 <inb>
c0024eac:	83 c4 04             	add    $0x4,%esp
c0024eaf:	0f b6 c0             	movzbl %al,%eax
c0024eb2:	83 ec 0c             	sub    $0xc,%esp
c0024eb5:	50                   	push   %eax
c0024eb6:	e8 62 17 00 00       	call   c002661d <input_putc>
c0024ebb:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024ebe:	e8 18 18 00 00       	call   c00266db <input_full>
c0024ec3:	83 f0 01             	xor    $0x1,%eax
c0024ec6:	84 c0                	test   %al,%al
c0024ec8:	74 40                	je     c0024f0a <serial_interrupt+0x7d>
c0024eca:	83 ec 0c             	sub    $0xc,%esp
c0024ecd:	68 fd 03 00 00       	push   $0x3fd
c0024ed2:	e8 af fb ff ff       	call   c0024a86 <inb>
c0024ed7:	83 c4 10             	add    $0x10,%esp
c0024eda:	0f b6 c0             	movzbl %al,%eax
c0024edd:	83 e0 01             	and    $0x1,%eax
c0024ee0:	85 c0                	test   %eax,%eax
c0024ee2:	75 be                	jne    c0024ea2 <serial_interrupt+0x15>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024ee4:	eb 24                	jmp    c0024f0a <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0024ee6:	83 ec 0c             	sub    $0xc,%esp
c0024ee9:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024eee:	e8 f9 18 00 00       	call   c00267ec <intq_getc>
c0024ef3:	83 c4 10             	add    $0x10,%esp
c0024ef6:	0f b6 c0             	movzbl %al,%eax
c0024ef9:	83 ec 08             	sub    $0x8,%esp
c0024efc:	50                   	push   %eax
c0024efd:	68 f8 03 00 00       	push   $0x3f8
c0024f02:	e8 9a fb ff ff       	call   c0024aa1 <outb>
c0024f07:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024f0a:	83 ec 0c             	sub    $0xc,%esp
c0024f0d:	68 c0 a0 03 c0       	push   $0xc003a0c0
c0024f12:	e8 47 18 00 00       	call   c002675e <intq_empty>
c0024f17:	83 c4 10             	add    $0x10,%esp
c0024f1a:	83 f0 01             	xor    $0x1,%eax
c0024f1d:	84 c0                	test   %al,%al
c0024f1f:	74 1a                	je     c0024f3b <serial_interrupt+0xae>
c0024f21:	83 ec 0c             	sub    $0xc,%esp
c0024f24:	68 fd 03 00 00       	push   $0x3fd
c0024f29:	e8 58 fb ff ff       	call   c0024a86 <inb>
c0024f2e:	83 c4 10             	add    $0x10,%esp
c0024f31:	0f b6 c0             	movzbl %al,%eax
c0024f34:	83 e0 20             	and    $0x20,%eax
c0024f37:	85 c0                	test   %eax,%eax
c0024f39:	75 ab                	jne    c0024ee6 <serial_interrupt+0x59>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024f3b:	e8 6d fe ff ff       	call   c0024dad <write_ier>
}
c0024f40:	90                   	nop
c0024f41:	c9                   	leave  
c0024f42:	c3                   	ret    

c0024f43 <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0024f43:	55                   	push   %ebp
c0024f44:	89 e5                	mov    %esp,%ebp
c0024f46:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0024f49:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c0024f4d:	76 1e                	jbe    c0024f6d <block_type_name+0x2a>
c0024f4f:	83 ec 0c             	sub    $0xc,%esp
c0024f52:	68 c4 0b 03 c0       	push   $0xc0030bc4
c0024f57:	68 d5 0b 03 c0       	push   $0xc0030bd5
c0024f5c:	68 dc 0c 03 c0       	push   $0xc0030cdc
c0024f61:	6a 2f                	push   $0x2f
c0024f63:	68 ec 0b 03 c0       	push   $0xc0030bec
c0024f68:	e8 01 48 00 00       	call   c002976e <debug_panic>
  return block_type_names[type];
c0024f6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f70:	8b 04 85 fc 83 03 c0 	mov    -0x3ffc7c04(,%eax,4),%eax
}
c0024f77:	c9                   	leave  
c0024f78:	c3                   	ret    

c0024f79 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0024f79:	55                   	push   %ebp
c0024f7a:	89 e5                	mov    %esp,%ebp
c0024f7c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024f7f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024f83:	76 1e                	jbe    c0024fa3 <block_get_role+0x2a>
c0024f85:	83 ec 0c             	sub    $0xc,%esp
c0024f88:	68 02 0c 03 c0       	push   $0xc0030c02
c0024f8d:	68 d5 0b 03 c0       	push   $0xc0030bd5
c0024f92:	68 14 0d 03 c0       	push   $0xc0030d14
c0024f97:	6a 38                	push   $0x38
c0024f99:	68 ec 0b 03 c0       	push   $0xc0030bec
c0024f9e:	e8 cb 47 00 00       	call   c002976e <debug_panic>
  return block_by_role[role];
c0024fa3:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fa6:	8b 04 85 28 a1 03 c0 	mov    -0x3ffc5ed8(,%eax,4),%eax
}
c0024fad:	c9                   	leave  
c0024fae:	c3                   	ret    

c0024faf <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0024faf:	55                   	push   %ebp
c0024fb0:	89 e5                	mov    %esp,%ebp
c0024fb2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024fb5:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024fb9:	76 1e                	jbe    c0024fd9 <block_set_role+0x2a>
c0024fbb:	83 ec 0c             	sub    $0xc,%esp
c0024fbe:	68 02 0c 03 c0       	push   $0xc0030c02
c0024fc3:	68 d5 0b 03 c0       	push   $0xc0030bd5
c0024fc8:	68 24 0d 03 c0       	push   $0xc0030d24
c0024fcd:	6a 40                	push   $0x40
c0024fcf:	68 ec 0b 03 c0       	push   $0xc0030bec
c0024fd4:	e8 95 47 00 00       	call   c002976e <debug_panic>
  block_by_role[role] = block;
c0024fd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0024fdc:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024fdf:	89 14 85 28 a1 03 c0 	mov    %edx,-0x3ffc5ed8(,%eax,4)
}
c0024fe6:	90                   	nop
c0024fe7:	c9                   	leave  
c0024fe8:	c3                   	ret    

c0024fe9 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c0024fe9:	55                   	push   %ebp
c0024fea:	89 e5                	mov    %esp,%ebp
c0024fec:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024fef:	83 ec 0c             	sub    $0xc,%esp
c0024ff2:	68 ec 83 03 c0       	push   $0xc00383ec
c0024ff7:	e8 38 4a 00 00       	call   c0029a34 <list_begin>
c0024ffc:	83 c4 10             	add    $0x10,%esp
c0024fff:	83 ec 0c             	sub    $0xc,%esp
c0025002:	50                   	push   %eax
c0025003:	e8 6a 03 00 00       	call   c0025372 <list_elem_to_block>
c0025008:	83 c4 10             	add    $0x10,%esp
}
c002500b:	c9                   	leave  
c002500c:	c3                   	ret    

c002500d <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c002500d:	55                   	push   %ebp
c002500e:	89 e5                	mov    %esp,%ebp
c0025010:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0025013:	8b 45 08             	mov    0x8(%ebp),%eax
c0025016:	83 ec 0c             	sub    $0xc,%esp
c0025019:	50                   	push   %eax
c002501a:	e8 47 4a 00 00       	call   c0029a66 <list_next>
c002501f:	83 c4 10             	add    $0x10,%esp
c0025022:	83 ec 0c             	sub    $0xc,%esp
c0025025:	50                   	push   %eax
c0025026:	e8 47 03 00 00       	call   c0025372 <list_elem_to_block>
c002502b:	83 c4 10             	add    $0x10,%esp
}
c002502e:	c9                   	leave  
c002502f:	c3                   	ret    

c0025030 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0025030:	55                   	push   %ebp
c0025031:	89 e5                	mov    %esp,%ebp
c0025033:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0025036:	83 ec 0c             	sub    $0xc,%esp
c0025039:	68 ec 83 03 c0       	push   $0xc00383ec
c002503e:	e8 f1 49 00 00       	call   c0029a34 <list_begin>
c0025043:	83 c4 10             	add    $0x10,%esp
c0025046:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0025049:	eb 3b                	jmp    c0025086 <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c002504b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002504e:	83 c0 04             	add    $0x4,%eax
c0025051:	83 e8 04             	sub    $0x4,%eax
c0025054:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0025057:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002505a:	83 c0 08             	add    $0x8,%eax
c002505d:	83 ec 08             	sub    $0x8,%esp
c0025060:	50                   	push   %eax
c0025061:	ff 75 08             	pushl  0x8(%ebp)
c0025064:	e8 42 37 00 00       	call   c00287ab <strcmp>
c0025069:	83 c4 10             	add    $0x10,%esp
c002506c:	85 c0                	test   %eax,%eax
c002506e:	75 05                	jne    c0025075 <block_get_by_name+0x45>
        return block;
c0025070:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025073:	eb 2b                	jmp    c00250a0 <block_get_by_name+0x70>
       e = list_next (e))
c0025075:	83 ec 0c             	sub    $0xc,%esp
c0025078:	ff 75 f4             	pushl  -0xc(%ebp)
c002507b:	e8 e6 49 00 00       	call   c0029a66 <list_next>
c0025080:	83 c4 10             	add    $0x10,%esp
c0025083:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0025086:	83 ec 0c             	sub    $0xc,%esp
c0025089:	68 ec 83 03 c0       	push   $0xc00383ec
c002508e:	e8 1d 4a 00 00       	call   c0029ab0 <list_end>
c0025093:	83 c4 10             	add    $0x10,%esp
c0025096:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0025099:	75 b0                	jne    c002504b <block_get_by_name+0x1b>
    }

  return NULL;
c002509b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00250a0:	c9                   	leave  
c00250a1:	c3                   	ret    

c00250a2 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c00250a2:	55                   	push   %ebp
c00250a3:	89 e5                	mov    %esp,%ebp
c00250a5:	53                   	push   %ebx
c00250a6:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c00250a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00250ac:	8b 40 1c             	mov    0x1c(%eax),%eax
c00250af:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00250b2:	77 32                	ja     c00250e6 <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c00250b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00250b7:	8b 58 1c             	mov    0x1c(%eax),%ebx
c00250ba:	83 ec 0c             	sub    $0xc,%esp
c00250bd:	ff 75 08             	pushl  0x8(%ebp)
c00250c0:	e8 fd 00 00 00       	call   c00251c2 <block_name>
c00250c5:	83 c4 10             	add    $0x10,%esp
c00250c8:	83 ec 04             	sub    $0x4,%esp
c00250cb:	53                   	push   %ebx
c00250cc:	ff 75 0c             	pushl  0xc(%ebp)
c00250cf:	50                   	push   %eax
c00250d0:	68 18 0c 03 c0       	push   $0xc0030c18
c00250d5:	68 34 0d 03 c0       	push   $0xc0030d34
c00250da:	6a 70                	push   $0x70
c00250dc:	68 ec 0b 03 c0       	push   $0xc0030bec
c00250e1:	e8 88 46 00 00       	call   c002976e <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c00250e6:	90                   	nop
c00250e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00250ea:	c9                   	leave  
c00250eb:	c3                   	ret    

c00250ec <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c00250ec:	55                   	push   %ebp
c00250ed:	89 e5                	mov    %esp,%ebp
c00250ef:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c00250f2:	83 ec 08             	sub    $0x8,%esp
c00250f5:	ff 75 0c             	pushl  0xc(%ebp)
c00250f8:	ff 75 08             	pushl  0x8(%ebp)
c00250fb:	e8 a2 ff ff ff       	call   c00250a2 <check_sector>
c0025100:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0025103:	8b 45 08             	mov    0x8(%ebp),%eax
c0025106:	8b 40 20             	mov    0x20(%eax),%eax
c0025109:	8b 00                	mov    (%eax),%eax
c002510b:	8b 55 08             	mov    0x8(%ebp),%edx
c002510e:	8b 52 24             	mov    0x24(%edx),%edx
c0025111:	83 ec 04             	sub    $0x4,%esp
c0025114:	ff 75 10             	pushl  0x10(%ebp)
c0025117:	ff 75 0c             	pushl  0xc(%ebp)
c002511a:	52                   	push   %edx
c002511b:	ff d0                	call   *%eax
c002511d:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0025120:	8b 45 08             	mov    0x8(%ebp),%eax
c0025123:	8b 50 2c             	mov    0x2c(%eax),%edx
c0025126:	8b 40 28             	mov    0x28(%eax),%eax
c0025129:	83 c0 01             	add    $0x1,%eax
c002512c:	83 d2 00             	adc    $0x0,%edx
c002512f:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025132:	89 41 28             	mov    %eax,0x28(%ecx)
c0025135:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0025138:	90                   	nop
c0025139:	c9                   	leave  
c002513a:	c3                   	ret    

c002513b <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c002513b:	55                   	push   %ebp
c002513c:	89 e5                	mov    %esp,%ebp
c002513e:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0025141:	83 ec 08             	sub    $0x8,%esp
c0025144:	ff 75 0c             	pushl  0xc(%ebp)
c0025147:	ff 75 08             	pushl  0x8(%ebp)
c002514a:	e8 53 ff ff ff       	call   c00250a2 <check_sector>
c002514f:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0025152:	8b 45 08             	mov    0x8(%ebp),%eax
c0025155:	8b 40 18             	mov    0x18(%eax),%eax
c0025158:	83 f8 05             	cmp    $0x5,%eax
c002515b:	75 21                	jne    c002517e <block_write+0x43>
c002515d:	83 ec 0c             	sub    $0xc,%esp
c0025160:	68 4b 0c 03 c0       	push   $0xc0030c4b
c0025165:	68 d5 0b 03 c0       	push   $0xc0030bd5
c002516a:	68 44 0d 03 c0       	push   $0xc0030d44
c002516f:	68 89 00 00 00       	push   $0x89
c0025174:	68 ec 0b 03 c0       	push   $0xc0030bec
c0025179:	e8 f0 45 00 00       	call   c002976e <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c002517e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025181:	8b 40 20             	mov    0x20(%eax),%eax
c0025184:	8b 40 04             	mov    0x4(%eax),%eax
c0025187:	8b 55 08             	mov    0x8(%ebp),%edx
c002518a:	8b 52 24             	mov    0x24(%edx),%edx
c002518d:	83 ec 04             	sub    $0x4,%esp
c0025190:	ff 75 10             	pushl  0x10(%ebp)
c0025193:	ff 75 0c             	pushl  0xc(%ebp)
c0025196:	52                   	push   %edx
c0025197:	ff d0                	call   *%eax
c0025199:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c002519c:	8b 45 08             	mov    0x8(%ebp),%eax
c002519f:	8b 50 34             	mov    0x34(%eax),%edx
c00251a2:	8b 40 30             	mov    0x30(%eax),%eax
c00251a5:	83 c0 01             	add    $0x1,%eax
c00251a8:	83 d2 00             	adc    $0x0,%edx
c00251ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00251ae:	89 41 30             	mov    %eax,0x30(%ecx)
c00251b1:	89 51 34             	mov    %edx,0x34(%ecx)
}
c00251b4:	90                   	nop
c00251b5:	c9                   	leave  
c00251b6:	c3                   	ret    

c00251b7 <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c00251b7:	55                   	push   %ebp
c00251b8:	89 e5                	mov    %esp,%ebp
  return block->size;
c00251ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00251bd:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00251c0:	5d                   	pop    %ebp
c00251c1:	c3                   	ret    

c00251c2 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c00251c2:	55                   	push   %ebp
c00251c3:	89 e5                	mov    %esp,%ebp
  return block->name;
c00251c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00251c8:	83 c0 08             	add    $0x8,%eax
}
c00251cb:	5d                   	pop    %ebp
c00251cc:	c3                   	ret    

c00251cd <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c00251cd:	55                   	push   %ebp
c00251ce:	89 e5                	mov    %esp,%ebp
  return block->type;
c00251d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00251d3:	8b 40 18             	mov    0x18(%eax),%eax
}
c00251d6:	5d                   	pop    %ebp
c00251d7:	c3                   	ret    

c00251d8 <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c00251d8:	55                   	push   %ebp
c00251d9:	89 e5                	mov    %esp,%ebp
c00251db:	56                   	push   %esi
c00251dc:	53                   	push   %ebx
c00251dd:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c00251e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00251e7:	eb 60                	jmp    c0025249 <block_print_stats+0x71>
    {
      struct block *block = block_by_role[i];
c00251e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00251ec:	8b 04 85 28 a1 03 c0 	mov    -0x3ffc5ed8(,%eax,4),%eax
c00251f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c00251f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00251fa:	74 4a                	je     c0025246 <block_print_stats+0x6e>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c00251fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00251ff:	8b 50 34             	mov    0x34(%eax),%edx
c0025202:	8b 40 30             	mov    0x30(%eax),%eax
c0025205:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0025208:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002520b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002520e:	8b 58 28             	mov    0x28(%eax),%ebx
c0025211:	8b 70 2c             	mov    0x2c(%eax),%esi
c0025214:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025217:	8b 40 18             	mov    0x18(%eax),%eax
c002521a:	83 ec 0c             	sub    $0xc,%esp
c002521d:	50                   	push   %eax
c002521e:	e8 20 fd ff ff       	call   c0024f43 <block_type_name>
c0025223:	83 c4 10             	add    $0x10,%esp
                  block->name, block_type_name (block->type),
c0025226:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025229:	83 c2 08             	add    $0x8,%edx
          printf ("%s (%s): %llu reads, %llu writes\n",
c002522c:	83 ec 04             	sub    $0x4,%esp
c002522f:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025232:	ff 75 e0             	pushl  -0x20(%ebp)
c0025235:	56                   	push   %esi
c0025236:	53                   	push   %ebx
c0025237:	50                   	push   %eax
c0025238:	52                   	push   %edx
c0025239:	68 68 0c 03 c0       	push   $0xc0030c68
c002523e:	e8 6c 21 00 00       	call   c00273af <printf>
c0025243:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025246:	ff 45 f4             	incl   -0xc(%ebp)
c0025249:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002524d:	7e 9a                	jle    c00251e9 <block_print_stats+0x11>
                  block->read_cnt, block->write_cnt);
        }
    }
}
c002524f:	90                   	nop
c0025250:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025253:	5b                   	pop    %ebx
c0025254:	5e                   	pop    %esi
c0025255:	5d                   	pop    %ebp
c0025256:	c3                   	ret    

c0025257 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0025257:	55                   	push   %ebp
c0025258:	89 e5                	mov    %esp,%ebp
c002525a:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c002525d:	83 ec 0c             	sub    $0xc,%esp
c0025260:	6a 38                	push   $0x38
c0025262:	e8 2b e4 ff ff       	call   c0023692 <malloc>
c0025267:	83 c4 10             	add    $0x10,%esp
c002526a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c002526d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0025271:	75 19                	jne    c002528c <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c0025273:	68 8c 0c 03 c0       	push   $0xc0030c8c
c0025278:	68 50 0d 03 c0       	push   $0xc0030d50
c002527d:	68 c1 00 00 00       	push   $0xc1
c0025282:	68 ec 0b 03 c0       	push   $0xc0030bec
c0025287:	e8 e2 44 00 00       	call   c002976e <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c002528c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002528f:	83 ec 08             	sub    $0x8,%esp
c0025292:	50                   	push   %eax
c0025293:	68 ec 83 03 c0       	push   $0xc00383ec
c0025298:	e8 22 4b 00 00       	call   c0029dbf <list_push_back>
c002529d:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c00252a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252a3:	83 c0 08             	add    $0x8,%eax
c00252a6:	83 ec 04             	sub    $0x4,%esp
c00252a9:	6a 10                	push   $0x10
c00252ab:	ff 75 08             	pushl  0x8(%ebp)
c00252ae:	50                   	push   %eax
c00252af:	e8 a7 39 00 00       	call   c0028c5b <strlcpy>
c00252b4:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c00252b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252ba:	8b 55 0c             	mov    0xc(%ebp),%edx
c00252bd:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c00252c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252c3:	8b 55 14             	mov    0x14(%ebp),%edx
c00252c6:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c00252c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252cc:	8b 55 18             	mov    0x18(%ebp),%edx
c00252cf:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c00252d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252d5:	8b 55 1c             	mov    0x1c(%ebp),%edx
c00252d8:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c00252db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252de:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c00252e5:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c00252ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252ef:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c00252f6:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00252fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025300:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025303:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025306:	83 c2 08             	add    $0x8,%edx
c0025309:	83 ec 04             	sub    $0x4,%esp
c002530c:	50                   	push   %eax
c002530d:	52                   	push   %edx
c002530e:	68 c2 0c 03 c0       	push   $0xc0030cc2
c0025313:	e8 97 20 00 00       	call   c00273af <printf>
c0025318:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c002531b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002531e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025321:	ba 00 00 00 00       	mov    $0x0,%edx
c0025326:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c002532a:	c1 e0 09             	shl    $0x9,%eax
c002532d:	83 ec 08             	sub    $0x8,%esp
c0025330:	52                   	push   %edx
c0025331:	50                   	push   %eax
c0025332:	e8 8e 2d 00 00       	call   c00280c5 <print_human_readable_size>
c0025337:	83 c4 10             	add    $0x10,%esp
  printf (")");
c002533a:	83 ec 0c             	sub    $0xc,%esp
c002533d:	6a 29                	push   $0x29
c002533f:	e8 81 67 00 00       	call   c002bac5 <putchar>
c0025344:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c0025347:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002534b:	74 13                	je     c0025360 <block_register+0x109>
    printf (", %s", extra_info);
c002534d:	83 ec 08             	sub    $0x8,%esp
c0025350:	ff 75 10             	pushl  0x10(%ebp)
c0025353:	68 d4 0c 03 c0       	push   $0xc0030cd4
c0025358:	e8 52 20 00 00       	call   c00273af <printf>
c002535d:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025360:	83 ec 0c             	sub    $0xc,%esp
c0025363:	6a 0a                	push   $0xa
c0025365:	e8 5b 67 00 00       	call   c002bac5 <putchar>
c002536a:	83 c4 10             	add    $0x10,%esp

  return block;
c002536d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0025370:	c9                   	leave  
c0025371:	c3                   	ret    

c0025372 <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c0025372:	55                   	push   %ebp
c0025373:	89 e5                	mov    %esp,%ebp
c0025375:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c0025378:	83 ec 0c             	sub    $0xc,%esp
c002537b:	68 ec 83 03 c0       	push   $0xc00383ec
c0025380:	e8 2b 47 00 00       	call   c0029ab0 <list_end>
c0025385:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025388:	3b 45 08             	cmp    0x8(%ebp),%eax
c002538b:	74 0b                	je     c0025398 <list_elem_to_block+0x26>
          ? list_entry (list_elem, struct block, list_elem)
c002538d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025390:	83 c0 04             	add    $0x4,%eax
          : NULL);
c0025393:	83 e8 04             	sub    $0x4,%eax
c0025396:	eb 05                	jmp    c002539d <list_elem_to_block+0x2b>
c0025398:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002539d:	c9                   	leave  
c002539e:	c3                   	ret    

c002539f <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c002539f:	55                   	push   %ebp
c00253a0:	89 e5                	mov    %esp,%ebp
c00253a2:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c00253a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c00253ac:	8d 45 f4             	lea    -0xc(%ebp),%eax
c00253af:	50                   	push   %eax
c00253b0:	6a 00                	push   $0x0
c00253b2:	6a 00                	push   $0x0
c00253b4:	ff 75 08             	pushl  0x8(%ebp)
c00253b7:	e8 2c 00 00 00       	call   c00253e8 <read_partition_table>
c00253bc:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c00253bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00253c2:	85 c0                	test   %eax,%eax
c00253c4:	75 1f                	jne    c00253e5 <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c00253c6:	83 ec 0c             	sub    $0xc,%esp
c00253c9:	ff 75 08             	pushl  0x8(%ebp)
c00253cc:	e8 f1 fd ff ff       	call   c00251c2 <block_name>
c00253d1:	83 c4 10             	add    $0x10,%esp
c00253d4:	83 ec 08             	sub    $0x8,%esp
c00253d7:	50                   	push   %eax
c00253d8:	68 60 0d 03 c0       	push   $0xc0030d60
c00253dd:	e8 cd 1f 00 00       	call   c00273af <printf>
c00253e2:	83 c4 10             	add    $0x10,%esp
}
c00253e5:	90                   	nop
c00253e6:	c9                   	leave  
c00253e7:	c3                   	ret    

c00253e8 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c00253e8:	55                   	push   %ebp
c00253e9:	89 e5                	mov    %esp,%ebp
c00253eb:	53                   	push   %ebx
c00253ec:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c00253ef:	83 ec 0c             	sub    $0xc,%esp
c00253f2:	ff 75 08             	pushl  0x8(%ebp)
c00253f5:	e8 bd fd ff ff       	call   c00251b7 <block_size>
c00253fa:	83 c4 10             	add    $0x10,%esp
c00253fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025400:	77 27                	ja     c0025429 <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025402:	83 ec 0c             	sub    $0xc,%esp
c0025405:	ff 75 08             	pushl  0x8(%ebp)
c0025408:	e8 b5 fd ff ff       	call   c00251c2 <block_name>
c002540d:	83 c4 10             	add    $0x10,%esp
c0025410:	83 ec 04             	sub    $0x4,%esp
c0025413:	ff 75 0c             	pushl  0xc(%ebp)
c0025416:	50                   	push   %eax
c0025417:	68 84 0d 03 c0       	push   $0xc0030d84
c002541c:	e8 8e 1f 00 00       	call   c00273af <printf>
c0025421:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c0025424:	e9 d2 01 00 00       	jmp    c00255fb <read_partition_table+0x213>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c0025429:	83 ec 0c             	sub    $0xc,%esp
c002542c:	68 00 02 00 00       	push   $0x200
c0025431:	e8 5c e2 ff ff       	call   c0023692 <malloc>
c0025436:	83 c4 10             	add    $0x10,%esp
c0025439:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c002543c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025440:	75 16                	jne    c0025458 <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c0025442:	68 bc 0d 03 c0       	push   $0xc0030dbc
c0025447:	68 44 0f 03 c0       	push   $0xc0030f44
c002544c:	6a 5a                	push   $0x5a
c002544e:	68 eb 0d 03 c0       	push   $0xc0030deb
c0025453:	e8 16 43 00 00       	call   c002976e <debug_panic>
  block_read (block, 0, pt);
c0025458:	83 ec 04             	sub    $0x4,%esp
c002545b:	ff 75 f0             	pushl  -0x10(%ebp)
c002545e:	6a 00                	push   $0x0
c0025460:	ff 75 08             	pushl  0x8(%ebp)
c0025463:	e8 84 fc ff ff       	call   c00250ec <block_read>
c0025468:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c002546b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002546e:	66 8b 80 fe 01 00 00 	mov    0x1fe(%eax),%ax
c0025475:	66 3d 55 aa          	cmp    $0xaa55,%ax
c0025479:	74 5c                	je     c00254d7 <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c002547b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002547f:	75 21                	jne    c00254a2 <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c0025481:	83 ec 0c             	sub    $0xc,%esp
c0025484:	ff 75 08             	pushl  0x8(%ebp)
c0025487:	e8 36 fd ff ff       	call   c00251c2 <block_name>
c002548c:	83 c4 10             	add    $0x10,%esp
c002548f:	83 ec 08             	sub    $0x8,%esp
c0025492:	50                   	push   %eax
c0025493:	68 08 0e 03 c0       	push   $0xc0030e08
c0025498:	e8 12 1f 00 00       	call   c00273af <printf>
c002549d:	83 c4 10             	add    $0x10,%esp
c00254a0:	eb 22                	jmp    c00254c4 <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c00254a2:	83 ec 0c             	sub    $0xc,%esp
c00254a5:	ff 75 08             	pushl  0x8(%ebp)
c00254a8:	e8 15 fd ff ff       	call   c00251c2 <block_name>
c00254ad:	83 c4 10             	add    $0x10,%esp
c00254b0:	83 ec 04             	sub    $0x4,%esp
c00254b3:	ff 75 0c             	pushl  0xc(%ebp)
c00254b6:	50                   	push   %eax
c00254b7:	68 30 0e 03 c0       	push   $0xc0030e30
c00254bc:	e8 ee 1e 00 00       	call   c00273af <printf>
c00254c1:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c00254c4:	83 ec 0c             	sub    $0xc,%esp
c00254c7:	ff 75 f0             	pushl  -0x10(%ebp)
c00254ca:	e8 bd e4 ff ff       	call   c002398c <free>
c00254cf:	83 c4 10             	add    $0x10,%esp
      return;
c00254d2:	e9 24 01 00 00       	jmp    c00255fb <read_partition_table+0x213>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00254d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00254de:	e9 00 01 00 00       	jmp    c00255e3 <read_partition_table+0x1fb>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c00254e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00254e6:	83 c0 1b             	add    $0x1b,%eax
c00254e9:	c1 e0 04             	shl    $0x4,%eax
c00254ec:	89 c2                	mov    %eax,%edx
c00254ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00254f1:	01 d0                	add    %edx,%eax
c00254f3:	83 c0 0e             	add    $0xe,%eax
c00254f6:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c00254f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00254fc:	8b 40 0c             	mov    0xc(%eax),%eax
c00254ff:	85 c0                	test   %eax,%eax
c0025501:	0f 84 d9 00 00 00    	je     c00255e0 <read_partition_table+0x1f8>
c0025507:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002550a:	8a 40 04             	mov    0x4(%eax),%al
c002550d:	84 c0                	test   %al,%al
c002550f:	0f 84 cb 00 00 00    	je     c00255e0 <read_partition_table+0x1f8>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c0025515:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025518:	8a 40 04             	mov    0x4(%eax),%al
c002551b:	3c 05                	cmp    $0x5,%al
c002551d:	74 1e                	je     c002553d <read_partition_table+0x155>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c002551f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025522:	8a 40 04             	mov    0x4(%eax),%al
c0025525:	3c 0f                	cmp    $0xf,%al
c0025527:	74 14                	je     c002553d <read_partition_table+0x155>
               || e->type == 0x85    /* Linux extended partition. */
c0025529:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002552c:	8a 40 04             	mov    0x4(%eax),%al
c002552f:	3c 85                	cmp    $0x85,%al
c0025531:	74 0a                	je     c002553d <read_partition_table+0x155>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c0025533:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025536:	8a 40 04             	mov    0x4(%eax),%al
c0025539:	3c c5                	cmp    $0xc5,%al
c002553b:	75 65                	jne    c00255a2 <read_partition_table+0x1ba>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c002553d:	83 ec 0c             	sub    $0xc,%esp
c0025540:	ff 75 08             	pushl  0x8(%ebp)
c0025543:	e8 7a fc ff ff       	call   c00251c2 <block_name>
c0025548:	83 c4 10             	add    $0x10,%esp
c002554b:	83 ec 04             	sub    $0x4,%esp
c002554e:	ff 75 0c             	pushl  0xc(%ebp)
c0025551:	50                   	push   %eax
c0025552:	68 64 0e 03 c0       	push   $0xc0030e64
c0025557:	e8 53 1e 00 00       	call   c00273af <printf>
c002555c:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c002555f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0025563:	75 1e                	jne    c0025583 <read_partition_table+0x19b>
            read_partition_table (block, e->offset, e->offset, part_nr);
c0025565:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025568:	8b 50 08             	mov    0x8(%eax),%edx
c002556b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002556e:	8b 40 08             	mov    0x8(%eax),%eax
c0025571:	ff 75 14             	pushl  0x14(%ebp)
c0025574:	52                   	push   %edx
c0025575:	50                   	push   %eax
c0025576:	ff 75 08             	pushl  0x8(%ebp)
c0025579:	e8 6a fe ff ff       	call   c00253e8 <read_partition_table>
c002557e:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0025581:	eb 5d                	jmp    c00255e0 <read_partition_table+0x1f8>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c0025583:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025586:	8b 50 08             	mov    0x8(%eax),%edx
c0025589:	8b 45 10             	mov    0x10(%ebp),%eax
c002558c:	01 d0                	add    %edx,%eax
c002558e:	ff 75 14             	pushl  0x14(%ebp)
c0025591:	ff 75 10             	pushl  0x10(%ebp)
c0025594:	50                   	push   %eax
c0025595:	ff 75 08             	pushl  0x8(%ebp)
c0025598:	e8 4b fe ff ff       	call   c00253e8 <read_partition_table>
c002559d:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c00255a0:	eb 3e                	jmp    c00255e0 <read_partition_table+0x1f8>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c00255a2:	8b 45 14             	mov    0x14(%ebp),%eax
c00255a5:	8b 00                	mov    (%eax),%eax
c00255a7:	8d 50 01             	lea    0x1(%eax),%edx
c00255aa:	8b 45 14             	mov    0x14(%ebp),%eax
c00255ad:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c00255af:	8b 45 14             	mov    0x14(%ebp),%eax
c00255b2:	8b 08                	mov    (%eax),%ecx
c00255b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00255b7:	8b 50 0c             	mov    0xc(%eax),%edx
c00255ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00255bd:	8b 58 08             	mov    0x8(%eax),%ebx
c00255c0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00255c3:	01 c3                	add    %eax,%ebx
c00255c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00255c8:	8a 40 04             	mov    0x4(%eax),%al
c00255cb:	0f b6 c0             	movzbl %al,%eax
c00255ce:	83 ec 0c             	sub    $0xc,%esp
c00255d1:	51                   	push   %ecx
c00255d2:	52                   	push   %edx
c00255d3:	53                   	push   %ebx
c00255d4:	50                   	push   %eax
c00255d5:	ff 75 08             	pushl  0x8(%ebp)
c00255d8:	e8 23 00 00 00       	call   c0025600 <found_partition>
c00255dd:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00255e0:	ff 45 f4             	incl   -0xc(%ebp)
c00255e3:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c00255e7:	0f 86 f6 fe ff ff    	jbe    c00254e3 <read_partition_table+0xfb>
                           e->size, *part_nr);
        }
    }

  free (pt);
c00255ed:	83 ec 0c             	sub    $0xc,%esp
c00255f0:	ff 75 f0             	pushl  -0x10(%ebp)
c00255f3:	e8 94 e3 ff ff       	call   c002398c <free>
c00255f8:	83 c4 10             	add    $0x10,%esp
}
c00255fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00255fe:	c9                   	leave  
c00255ff:	c3                   	ret    

c0025600 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0025600:	55                   	push   %ebp
c0025601:	89 e5                	mov    %esp,%ebp
c0025603:	56                   	push   %esi
c0025604:	53                   	push   %ebx
c0025605:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c002560b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002560e:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c0025614:	83 ec 0c             	sub    $0xc,%esp
c0025617:	ff 75 08             	pushl  0x8(%ebp)
c002561a:	e8 98 fb ff ff       	call   c00251b7 <block_size>
c002561f:	83 c4 10             	add    $0x10,%esp
c0025622:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025625:	77 27                	ja     c002564e <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025627:	83 ec 0c             	sub    $0xc,%esp
c002562a:	ff 75 08             	pushl  0x8(%ebp)
c002562d:	e8 90 fb ff ff       	call   c00251c2 <block_name>
c0025632:	83 c4 10             	add    $0x10,%esp
c0025635:	ff 75 10             	pushl  0x10(%ebp)
c0025638:	ff 75 18             	pushl  0x18(%ebp)
c002563b:	50                   	push   %eax
c002563c:	68 8c 0e 03 c0       	push   $0xc0030e8c
c0025641:	e8 69 1d 00 00       	call   c00273af <printf>
c0025646:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025649:	e9 76 01 00 00       	jmp    c00257c4 <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
c002564e:	8b 55 10             	mov    0x10(%ebp),%edx
c0025651:	8b 45 14             	mov    0x14(%ebp),%eax
c0025654:	01 d0                	add    %edx,%eax
c0025656:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025659:	72 1b                	jb     c0025676 <found_partition+0x76>
c002565b:	8b 55 10             	mov    0x10(%ebp),%edx
c002565e:	8b 45 14             	mov    0x14(%ebp),%eax
c0025661:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0025664:	83 ec 0c             	sub    $0xc,%esp
c0025667:	ff 75 08             	pushl  0x8(%ebp)
c002566a:	e8 48 fb ff ff       	call   c00251b7 <block_size>
c002566f:	83 c4 10             	add    $0x10,%esp
c0025672:	39 c3                	cmp    %eax,%ebx
c0025674:	76 42                	jbe    c00256b8 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025676:	83 ec 0c             	sub    $0xc,%esp
c0025679:	ff 75 08             	pushl  0x8(%ebp)
c002567c:	e8 36 fb ff ff       	call   c00251b7 <block_size>
c0025681:	83 c4 10             	add    $0x10,%esp
c0025684:	89 c3                	mov    %eax,%ebx
c0025686:	8b 55 10             	mov    0x10(%ebp),%edx
c0025689:	8b 45 14             	mov    0x14(%ebp),%eax
c002568c:	8d 34 02             	lea    (%edx,%eax,1),%esi
c002568f:	83 ec 0c             	sub    $0xc,%esp
c0025692:	ff 75 08             	pushl  0x8(%ebp)
c0025695:	e8 28 fb ff ff       	call   c00251c2 <block_name>
c002569a:	83 c4 10             	add    $0x10,%esp
c002569d:	83 ec 0c             	sub    $0xc,%esp
c00256a0:	53                   	push   %ebx
c00256a1:	56                   	push   %esi
c00256a2:	ff 75 18             	pushl  0x18(%ebp)
c00256a5:	50                   	push   %eax
c00256a6:	68 c4 0e 03 c0       	push   $0xc0030ec4
c00256ab:	e8 ff 1c 00 00       	call   c00273af <printf>
c00256b0:	83 c4 20             	add    $0x20,%esp
}
c00256b3:	e9 0c 01 00 00       	jmp    c00257c4 <found_partition+0x1c4>
                              : part_type == 0x21 ? BLOCK_FILESYS
c00256b8:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c00256bf:	74 37                	je     c00256f8 <found_partition+0xf8>
c00256c1:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c00256c8:	74 27                	je     c00256f1 <found_partition+0xf1>
c00256ca:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c00256d1:	74 17                	je     c00256ea <found_partition+0xea>
c00256d3:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c00256da:	75 07                	jne    c00256e3 <found_partition+0xe3>
c00256dc:	b8 03 00 00 00       	mov    $0x3,%eax
c00256e1:	eb 1a                	jmp    c00256fd <found_partition+0xfd>
c00256e3:	b8 05 00 00 00       	mov    $0x5,%eax
c00256e8:	eb 13                	jmp    c00256fd <found_partition+0xfd>
c00256ea:	b8 02 00 00 00       	mov    $0x2,%eax
c00256ef:	eb 0c                	jmp    c00256fd <found_partition+0xfd>
c00256f1:	b8 01 00 00 00       	mov    $0x1,%eax
c00256f6:	eb 05                	jmp    c00256fd <found_partition+0xfd>
c00256f8:	b8 00 00 00 00       	mov    $0x0,%eax
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c00256fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
      p = malloc (sizeof *p);
c0025700:	83 ec 0c             	sub    $0xc,%esp
c0025703:	6a 08                	push   $0x8
c0025705:	e8 88 df ff ff       	call   c0023692 <malloc>
c002570a:	83 c4 10             	add    $0x10,%esp
c002570d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c0025710:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025714:	75 19                	jne    c002572f <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c0025716:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002571b:	68 5c 0f 03 c0       	push   $0xc0030f5c
c0025720:	68 b1 00 00 00       	push   $0xb1
c0025725:	68 eb 0d 03 c0       	push   $0xc0030deb
c002572a:	e8 3f 40 00 00       	call   c002976e <debug_panic>
      p->block = block;
c002572f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025732:	8b 55 08             	mov    0x8(%ebp),%edx
c0025735:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025737:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002573a:	8b 55 10             	mov    0x10(%ebp),%edx
c002573d:	89 50 04             	mov    %edx,0x4(%eax)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025740:	83 ec 0c             	sub    $0xc,%esp
c0025743:	ff 75 08             	pushl  0x8(%ebp)
c0025746:	e8 77 fa ff ff       	call   c00251c2 <block_name>
c002574b:	83 c4 10             	add    $0x10,%esp
c002574e:	83 ec 0c             	sub    $0xc,%esp
c0025751:	ff 75 18             	pushl  0x18(%ebp)
c0025754:	50                   	push   %eax
c0025755:	68 2b 0f 03 c0       	push   $0xc0030f2b
c002575a:	6a 10                	push   $0x10
c002575c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002575f:	50                   	push   %eax
c0025760:	e8 21 1c 00 00       	call   c0027386 <snprintf>
c0025765:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025768:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c002576f:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c0025776:	83 ec 0c             	sub    $0xc,%esp
c0025779:	50                   	push   %eax
c002577a:	e8 4d 00 00 00       	call   c00257cc <partition_type_name>
c002577f:	83 c4 10             	add    $0x10,%esp
c0025782:	83 ec 0c             	sub    $0xc,%esp
c0025785:	53                   	push   %ebx
c0025786:	50                   	push   %eax
c0025787:	68 30 0f 03 c0       	push   $0xc0030f30
c002578c:	68 80 00 00 00       	push   $0x80
c0025791:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025797:	50                   	push   %eax
c0025798:	e8 e9 1b 00 00       	call   c0027386 <snprintf>
c002579d:	83 c4 20             	add    $0x20,%esp
      block_register (name, type, extra_info, size, &partition_operations, p);
c00257a0:	83 ec 08             	sub    $0x8,%esp
c00257a3:	ff 75 f0             	pushl  -0x10(%ebp)
c00257a6:	68 20 84 03 c0       	push   $0xc0038420
c00257ab:	ff 75 14             	pushl  0x14(%ebp)
c00257ae:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c00257b4:	50                   	push   %eax
c00257b5:	ff 75 f4             	pushl  -0xc(%ebp)
c00257b8:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00257bb:	50                   	push   %eax
c00257bc:	e8 96 fa ff ff       	call   c0025257 <block_register>
c00257c1:	83 c4 20             	add    $0x20,%esp
}
c00257c4:	90                   	nop
c00257c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00257c8:	5b                   	pop    %ebx
c00257c9:	5e                   	pop    %esi
c00257ca:	5d                   	pop    %ebp
c00257cb:	c3                   	ret    

c00257cc <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c00257cc:	55                   	push   %ebp
c00257cd:	89 e5                	mov    %esp,%ebp
c00257cf:	83 ec 04             	sub    $0x4,%esp
c00257d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00257d5:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c00257d8:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00257dc:	8b 04 85 40 84 03 c0 	mov    -0x3ffc7bc0(,%eax,4),%eax
c00257e3:	85 c0                	test   %eax,%eax
c00257e5:	74 0d                	je     c00257f4 <partition_type_name+0x28>
c00257e7:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00257eb:	8b 04 85 40 84 03 c0 	mov    -0x3ffc7bc0(,%eax,4),%eax
c00257f2:	eb 05                	jmp    c00257f9 <partition_type_name+0x2d>
c00257f4:	b8 3a 0f 03 c0       	mov    $0xc0030f3a,%eax
}
c00257f9:	c9                   	leave  
c00257fa:	c3                   	ret    

c00257fb <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c00257fb:	55                   	push   %ebp
c00257fc:	89 e5                	mov    %esp,%ebp
c00257fe:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025801:	8b 45 08             	mov    0x8(%ebp),%eax
c0025804:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c0025807:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002580a:	8b 50 04             	mov    0x4(%eax),%edx
c002580d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025810:	01 c2                	add    %eax,%edx
c0025812:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025815:	8b 00                	mov    (%eax),%eax
c0025817:	83 ec 04             	sub    $0x4,%esp
c002581a:	ff 75 10             	pushl  0x10(%ebp)
c002581d:	52                   	push   %edx
c002581e:	50                   	push   %eax
c002581f:	e8 c8 f8 ff ff       	call   c00250ec <block_read>
c0025824:	83 c4 10             	add    $0x10,%esp
}
c0025827:	90                   	nop
c0025828:	c9                   	leave  
c0025829:	c3                   	ret    

c002582a <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c002582a:	55                   	push   %ebp
c002582b:	89 e5                	mov    %esp,%ebp
c002582d:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025830:	8b 45 08             	mov    0x8(%ebp),%eax
c0025833:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c0025836:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025839:	8b 50 04             	mov    0x4(%eax),%edx
c002583c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002583f:	01 c2                	add    %eax,%edx
c0025841:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025844:	8b 00                	mov    (%eax),%eax
c0025846:	83 ec 04             	sub    $0x4,%esp
c0025849:	ff 75 10             	pushl  0x10(%ebp)
c002584c:	52                   	push   %edx
c002584d:	50                   	push   %eax
c002584e:	e8 e8 f8 ff ff       	call   c002513b <block_write>
c0025853:	83 c4 10             	add    $0x10,%esp
}
c0025856:	90                   	nop
c0025857:	c9                   	leave  
c0025858:	c3                   	ret    

c0025859 <isspace>:
static inline int isspace (int c) {
c0025859:	55                   	push   %ebp
c002585a:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c002585c:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0025860:	74 1e                	je     c0025880 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0025862:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0025866:	74 18                	je     c0025880 <isspace+0x27>
c0025868:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c002586c:	74 12                	je     c0025880 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c002586e:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0025872:	74 0c                	je     c0025880 <isspace+0x27>
c0025874:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0025878:	74 06                	je     c0025880 <isspace+0x27>
c002587a:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c002587e:	75 07                	jne    c0025887 <isspace+0x2e>
c0025880:	b8 01 00 00 00       	mov    $0x1,%eax
c0025885:	eb 05                	jmp    c002588c <isspace+0x33>
c0025887:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002588c:	5d                   	pop    %ebp
c002588d:	c3                   	ret    

c002588e <inb>:
{
c002588e:	55                   	push   %ebp
c002588f:	89 e5                	mov    %esp,%ebp
c0025891:	83 ec 14             	sub    $0x14,%esp
c0025894:	8b 45 08             	mov    0x8(%ebp),%eax
c0025897:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002589b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002589e:	89 c2                	mov    %eax,%edx
c00258a0:	ec                   	in     (%dx),%al
c00258a1:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00258a4:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c00258a7:	c9                   	leave  
c00258a8:	c3                   	ret    

c00258a9 <insw>:
{
c00258a9:	55                   	push   %ebp
c00258aa:	89 e5                	mov    %esp,%ebp
c00258ac:	57                   	push   %edi
c00258ad:	53                   	push   %ebx
c00258ae:	83 ec 04             	sub    $0x4,%esp
c00258b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00258b4:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c00258b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00258bb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00258be:	8b 45 10             	mov    0x10(%ebp),%eax
c00258c1:	89 cb                	mov    %ecx,%ebx
c00258c3:	89 df                	mov    %ebx,%edi
c00258c5:	89 c1                	mov    %eax,%ecx
c00258c7:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c00258ca:	89 c8                	mov    %ecx,%eax
c00258cc:	89 fb                	mov    %edi,%ebx
c00258ce:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00258d1:	89 45 10             	mov    %eax,0x10(%ebp)
}
c00258d4:	90                   	nop
c00258d5:	83 c4 04             	add    $0x4,%esp
c00258d8:	5b                   	pop    %ebx
c00258d9:	5f                   	pop    %edi
c00258da:	5d                   	pop    %ebp
c00258db:	c3                   	ret    

c00258dc <outb>:
{
c00258dc:	55                   	push   %ebp
c00258dd:	89 e5                	mov    %esp,%ebp
c00258df:	83 ec 08             	sub    $0x8,%esp
c00258e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00258e5:	8b 55 0c             	mov    0xc(%ebp),%edx
c00258e8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00258ec:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00258ef:	8a 45 f8             	mov    -0x8(%ebp),%al
c00258f2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00258f5:	ee                   	out    %al,(%dx)
}
c00258f6:	90                   	nop
c00258f7:	c9                   	leave  
c00258f8:	c3                   	ret    

c00258f9 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c00258f9:	55                   	push   %ebp
c00258fa:	89 e5                	mov    %esp,%ebp
c00258fc:	56                   	push   %esi
c00258fd:	53                   	push   %ebx
c00258fe:	83 ec 04             	sub    $0x4,%esp
c0025901:	8b 45 08             	mov    0x8(%ebp),%eax
c0025904:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025908:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002590b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002590e:	8b 45 10             	mov    0x10(%ebp),%eax
c0025911:	89 cb                	mov    %ecx,%ebx
c0025913:	89 de                	mov    %ebx,%esi
c0025915:	89 c1                	mov    %eax,%ecx
c0025917:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c002591a:	89 c8                	mov    %ecx,%eax
c002591c:	89 f3                	mov    %esi,%ebx
c002591e:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025921:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0025924:	90                   	nop
c0025925:	83 c4 04             	add    $0x4,%esp
c0025928:	5b                   	pop    %ebx
c0025929:	5e                   	pop    %esi
c002592a:	5d                   	pop    %ebp
c002592b:	c3                   	ret    

c002592c <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c002592c:	55                   	push   %ebp
c002592d:	89 e5                	mov    %esp,%ebp
c002592f:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025932:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025939:	e9 ba 01 00 00       	jmp    c0025af8 <ide_init+0x1cc>
    {
      struct channel *c = &channels[chan_no];
c002593e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025941:	89 d0                	mov    %edx,%eax
c0025943:	c1 e0 02             	shl    $0x2,%eax
c0025946:	01 d0                	add    %edx,%eax
c0025948:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002594f:	01 d0                	add    %edx,%eax
c0025951:	c1 e0 02             	shl    $0x2,%eax
c0025954:	05 40 a1 03 c0       	add    $0xc003a140,%eax
c0025959:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c002595c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002595f:	ff 75 f4             	pushl  -0xc(%ebp)
c0025962:	68 30 14 03 c0       	push   $0xc0031430
c0025967:	6a 08                	push   $0x8
c0025969:	50                   	push   %eax
c002596a:	e8 17 1a 00 00       	call   c0027386 <snprintf>
c002596f:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c0025972:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025975:	85 c0                	test   %eax,%eax
c0025977:	74 07                	je     c0025980 <ide_init+0x54>
c0025979:	83 f8 01             	cmp    $0x1,%eax
c002597c:	74 14                	je     c0025992 <ide_init+0x66>
c002597e:	eb 24                	jmp    c00259a4 <ide_init+0x78>
        {
        case 0:
          c->reg_base = 0x1f0;
c0025980:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025983:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c0025989:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002598c:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c0025990:	eb 28                	jmp    c00259ba <ide_init+0x8e>
        case 1:
          c->reg_base = 0x170;
c0025992:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025995:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c002599b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002599e:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c00259a2:	eb 16                	jmp    c00259ba <ide_init+0x8e>
        default:
          NOT_REACHED ();
c00259a4:	68 38 14 03 c0       	push   $0xc0031438
c00259a9:	68 8c 15 03 c0       	push   $0xc003158c
c00259ae:	6a 7c                	push   $0x7c
c00259b0:	68 5a 14 03 c0       	push   $0xc003145a
c00259b5:	e8 b4 3d 00 00       	call   c002976e <debug_panic>
        }
      lock_init (&c->lock);
c00259ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259bd:	83 c0 0c             	add    $0xc,%eax
c00259c0:	83 ec 0c             	sub    $0xc,%esp
c00259c3:	50                   	push   %eax
c00259c4:	e8 b1 d2 ff ff       	call   c0022c7a <lock_init>
c00259c9:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c00259cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259cf:	c6 40 24 00          	movb   $0x0,0x24(%eax)
      sema_init (&c->completion_wait, 0);
c00259d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259d6:	83 c0 28             	add    $0x28,%eax
c00259d9:	83 ec 08             	sub    $0x8,%esp
c00259dc:	6a 00                	push   $0x0
c00259de:	50                   	push   %eax
c00259df:	e8 de cf ff ff       	call   c00229c2 <sema_init>
c00259e4:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c00259e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00259ee:	eb 5a                	jmp    c0025a4a <ide_init+0x11e>
        {
          struct ata_disk *d = &c->devices[dev_no];
c00259f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00259f3:	89 d0                	mov    %edx,%eax
c00259f5:	c1 e0 02             	shl    $0x2,%eax
c00259f8:	01 d0                	add    %edx,%eax
c00259fa:	c1 e0 02             	shl    $0x2,%eax
c00259fd:	8d 50 30             	lea    0x30(%eax),%edx
c0025a00:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025a03:	01 d0                	add    %edx,%eax
c0025a05:	83 c0 0c             	add    $0xc,%eax
c0025a08:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c0025a0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025a0e:	01 c0                	add    %eax,%eax
c0025a10:	89 c2                	mov    %eax,%edx
c0025a12:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025a15:	01 d0                	add    %edx,%eax
          snprintf (d->name, sizeof d->name,
c0025a17:	8d 50 61             	lea    0x61(%eax),%edx
c0025a1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025a1d:	52                   	push   %edx
c0025a1e:	68 6e 14 03 c0       	push   $0xc003146e
c0025a23:	6a 08                	push   $0x8
c0025a25:	50                   	push   %eax
c0025a26:	e8 5b 19 00 00       	call   c0027386 <snprintf>
c0025a2b:	83 c4 10             	add    $0x10,%esp
          d->channel = c;
c0025a2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025a31:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0025a34:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c0025a37:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025a3a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025a3d:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c0025a40:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025a43:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025a47:	ff 45 f0             	incl   -0x10(%ebp)
c0025a4a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025a4e:	7e a0                	jle    c00259f0 <ide_init+0xc4>
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025a50:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0025a53:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025a56:	8a 40 0a             	mov    0xa(%eax),%al
c0025a59:	0f b6 c0             	movzbl %al,%eax
c0025a5c:	83 ec 04             	sub    $0x4,%esp
c0025a5f:	52                   	push   %edx
c0025a60:	68 70 65 02 c0       	push   $0xc0026570
c0025a65:	50                   	push   %eax
c0025a66:	e8 77 bd ff ff       	call   c00217e2 <intr_register_ext>
c0025a6b:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c0025a6e:	83 ec 0c             	sub    $0xc,%esp
c0025a71:	ff 75 ec             	pushl  -0x14(%ebp)
c0025a74:	e8 8c 00 00 00       	call   c0025b05 <reset_channel>
c0025a79:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c0025a7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025a7f:	83 c0 3c             	add    $0x3c,%eax
c0025a82:	83 ec 0c             	sub    $0xc,%esp
c0025a85:	50                   	push   %eax
c0025a86:	e8 f8 02 00 00       	call   c0025d83 <check_device_type>
c0025a8b:	83 c4 10             	add    $0x10,%esp
c0025a8e:	84 c0                	test   %al,%al
c0025a90:	74 12                	je     c0025aa4 <ide_init+0x178>
        check_device_type (&c->devices[1]);
c0025a92:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025a95:	83 c0 50             	add    $0x50,%eax
c0025a98:	83 ec 0c             	sub    $0xc,%esp
c0025a9b:	50                   	push   %eax
c0025a9c:	e8 e2 02 00 00       	call   c0025d83 <check_device_type>
c0025aa1:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025aa4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025aab:	eb 42                	jmp    c0025aef <ide_init+0x1c3>
        if (c->devices[dev_no].is_ata)
c0025aad:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0025ab0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025ab3:	89 d0                	mov    %edx,%eax
c0025ab5:	c1 e0 02             	shl    $0x2,%eax
c0025ab8:	01 d0                	add    %edx,%eax
c0025aba:	c1 e0 02             	shl    $0x2,%eax
c0025abd:	01 c8                	add    %ecx,%eax
c0025abf:	83 c0 4c             	add    $0x4c,%eax
c0025ac2:	8a 00                	mov    (%eax),%al
c0025ac4:	84 c0                	test   %al,%al
c0025ac6:	74 24                	je     c0025aec <ide_init+0x1c0>
          identify_ata_device (&c->devices[dev_no]);
c0025ac8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025acb:	89 d0                	mov    %edx,%eax
c0025acd:	c1 e0 02             	shl    $0x2,%eax
c0025ad0:	01 d0                	add    %edx,%eax
c0025ad2:	c1 e0 02             	shl    $0x2,%eax
c0025ad5:	8d 50 30             	lea    0x30(%eax),%edx
c0025ad8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025adb:	01 d0                	add    %edx,%eax
c0025add:	83 c0 0c             	add    $0xc,%eax
c0025ae0:	83 ec 0c             	sub    $0xc,%esp
c0025ae3:	50                   	push   %eax
c0025ae4:	e8 8b 03 00 00       	call   c0025e74 <identify_ata_device>
c0025ae9:	83 c4 10             	add    $0x10,%esp
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025aec:	ff 45 f0             	incl   -0x10(%ebp)
c0025aef:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025af3:	7e b8                	jle    c0025aad <ide_init+0x181>
  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025af5:	ff 45 f4             	incl   -0xc(%ebp)
c0025af8:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025afc:	0f 86 3c fe ff ff    	jbe    c002593e <ide_init+0x12>
    }
}
c0025b02:	90                   	nop
c0025b03:	c9                   	leave  
c0025b04:	c3                   	ret    

c0025b05 <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c0025b05:	55                   	push   %ebp
c0025b06:	89 e5                	mov    %esp,%ebp
c0025b08:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025b0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025b12:	e9 22 01 00 00       	jmp    c0025c39 <reset_channel+0x134>
    {
      struct ata_disk *d = &c->devices[dev_no];
c0025b17:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025b1a:	89 d0                	mov    %edx,%eax
c0025b1c:	c1 e0 02             	shl    $0x2,%eax
c0025b1f:	01 d0                	add    %edx,%eax
c0025b21:	c1 e0 02             	shl    $0x2,%eax
c0025b24:	8d 50 30             	lea    0x30(%eax),%edx
c0025b27:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b2a:	01 d0                	add    %edx,%eax
c0025b2c:	83 c0 0c             	add    $0xc,%eax
c0025b2f:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c0025b32:	83 ec 0c             	sub    $0xc,%esp
c0025b35:	ff 75 ec             	pushl  -0x14(%ebp)
c0025b38:	e8 98 09 00 00       	call   c00264d5 <select_device>
c0025b3d:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025b40:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b43:	8b 40 08             	mov    0x8(%eax),%eax
c0025b46:	83 c0 02             	add    $0x2,%eax
c0025b49:	0f b7 c0             	movzwl %ax,%eax
c0025b4c:	83 ec 08             	sub    $0x8,%esp
c0025b4f:	6a 55                	push   $0x55
c0025b51:	50                   	push   %eax
c0025b52:	e8 85 fd ff ff       	call   c00258dc <outb>
c0025b57:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025b5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b5d:	8b 40 08             	mov    0x8(%eax),%eax
c0025b60:	83 c0 03             	add    $0x3,%eax
c0025b63:	0f b7 c0             	movzwl %ax,%eax
c0025b66:	83 ec 08             	sub    $0x8,%esp
c0025b69:	68 aa 00 00 00       	push   $0xaa
c0025b6e:	50                   	push   %eax
c0025b6f:	e8 68 fd ff ff       	call   c00258dc <outb>
c0025b74:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0025b77:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b7a:	8b 40 08             	mov    0x8(%eax),%eax
c0025b7d:	83 c0 02             	add    $0x2,%eax
c0025b80:	0f b7 c0             	movzwl %ax,%eax
c0025b83:	83 ec 08             	sub    $0x8,%esp
c0025b86:	68 aa 00 00 00       	push   $0xaa
c0025b8b:	50                   	push   %eax
c0025b8c:	e8 4b fd ff ff       	call   c00258dc <outb>
c0025b91:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0025b94:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b97:	8b 40 08             	mov    0x8(%eax),%eax
c0025b9a:	83 c0 03             	add    $0x3,%eax
c0025b9d:	0f b7 c0             	movzwl %ax,%eax
c0025ba0:	83 ec 08             	sub    $0x8,%esp
c0025ba3:	6a 55                	push   $0x55
c0025ba5:	50                   	push   %eax
c0025ba6:	e8 31 fd ff ff       	call   c00258dc <outb>
c0025bab:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025bae:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bb1:	8b 40 08             	mov    0x8(%eax),%eax
c0025bb4:	83 c0 02             	add    $0x2,%eax
c0025bb7:	0f b7 c0             	movzwl %ax,%eax
c0025bba:	83 ec 08             	sub    $0x8,%esp
c0025bbd:	6a 55                	push   $0x55
c0025bbf:	50                   	push   %eax
c0025bc0:	e8 17 fd ff ff       	call   c00258dc <outb>
c0025bc5:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025bc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bcb:	8b 40 08             	mov    0x8(%eax),%eax
c0025bce:	83 c0 03             	add    $0x3,%eax
c0025bd1:	0f b7 c0             	movzwl %ax,%eax
c0025bd4:	83 ec 08             	sub    $0x8,%esp
c0025bd7:	68 aa 00 00 00       	push   $0xaa
c0025bdc:	50                   	push   %eax
c0025bdd:	e8 fa fc ff ff       	call   c00258dc <outb>
c0025be2:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025be5:	8b 45 08             	mov    0x8(%ebp),%eax
c0025be8:	8b 40 08             	mov    0x8(%eax),%eax
c0025beb:	83 c0 02             	add    $0x2,%eax
c0025bee:	0f b7 c0             	movzwl %ax,%eax
c0025bf1:	83 ec 0c             	sub    $0xc,%esp
c0025bf4:	50                   	push   %eax
c0025bf5:	e8 94 fc ff ff       	call   c002588e <inb>
c0025bfa:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c0025bfd:	3c 55                	cmp    $0x55,%al
c0025bff:	75 23                	jne    c0025c24 <reset_channel+0x11f>
c0025c01:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c04:	8b 40 08             	mov    0x8(%eax),%eax
c0025c07:	83 c0 03             	add    $0x3,%eax
c0025c0a:	0f b7 c0             	movzwl %ax,%eax
c0025c0d:	83 ec 0c             	sub    $0xc,%esp
c0025c10:	50                   	push   %eax
c0025c11:	e8 78 fc ff ff       	call   c002588e <inb>
c0025c16:	83 c4 10             	add    $0x10,%esp
c0025c19:	3c aa                	cmp    $0xaa,%al
c0025c1b:	75 07                	jne    c0025c24 <reset_channel+0x11f>
c0025c1d:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c22:	eb 05                	jmp    c0025c29 <reset_channel+0x124>
c0025c24:	b8 00 00 00 00       	mov    $0x0,%eax
c0025c29:	83 e0 01             	and    $0x1,%eax
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0025c2c:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c0025c2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025c32:	01 ca                	add    %ecx,%edx
c0025c34:	88 02                	mov    %al,(%edx)
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025c36:	ff 45 f4             	incl   -0xc(%ebp)
c0025c39:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025c3d:	0f 8e d4 fe ff ff    	jle    c0025b17 <reset_channel+0x12>
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0025c43:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c46:	8b 40 08             	mov    0x8(%eax),%eax
c0025c49:	05 06 02 00 00       	add    $0x206,%eax
c0025c4e:	0f b7 c0             	movzwl %ax,%eax
c0025c51:	83 ec 08             	sub    $0x8,%esp
c0025c54:	6a 00                	push   $0x0
c0025c56:	50                   	push   %eax
c0025c57:	e8 80 fc ff ff       	call   c00258dc <outb>
c0025c5c:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025c5f:	83 ec 08             	sub    $0x8,%esp
c0025c62:	6a 00                	push   $0x0
c0025c64:	6a 0a                	push   $0xa
c0025c66:	e8 56 e3 ff ff       	call   c0023fc1 <timer_usleep>
c0025c6b:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c0025c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c71:	8b 40 08             	mov    0x8(%eax),%eax
c0025c74:	05 06 02 00 00       	add    $0x206,%eax
c0025c79:	0f b7 c0             	movzwl %ax,%eax
c0025c7c:	83 ec 08             	sub    $0x8,%esp
c0025c7f:	6a 04                	push   $0x4
c0025c81:	50                   	push   %eax
c0025c82:	e8 55 fc ff ff       	call   c00258dc <outb>
c0025c87:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025c8a:	83 ec 08             	sub    $0x8,%esp
c0025c8d:	6a 00                	push   $0x0
c0025c8f:	6a 0a                	push   $0xa
c0025c91:	e8 2b e3 ff ff       	call   c0023fc1 <timer_usleep>
c0025c96:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c0025c99:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c9c:	8b 40 08             	mov    0x8(%eax),%eax
c0025c9f:	05 06 02 00 00       	add    $0x206,%eax
c0025ca4:	0f b7 c0             	movzwl %ax,%eax
c0025ca7:	83 ec 08             	sub    $0x8,%esp
c0025caa:	6a 00                	push   $0x0
c0025cac:	50                   	push   %eax
c0025cad:	e8 2a fc ff ff       	call   c00258dc <outb>
c0025cb2:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0025cb5:	83 ec 08             	sub    $0x8,%esp
c0025cb8:	6a 00                	push   $0x0
c0025cba:	68 96 00 00 00       	push   $0x96
c0025cbf:	e8 d2 e2 ff ff       	call   c0023f96 <timer_msleep>
c0025cc4:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0025cc7:	8a 45 ea             	mov    -0x16(%ebp),%al
c0025cca:	84 c0                	test   %al,%al
c0025ccc:	74 24                	je     c0025cf2 <reset_channel+0x1ed>
    {
      select_device (&c->devices[0]);
c0025cce:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cd1:	83 c0 3c             	add    $0x3c,%eax
c0025cd4:	83 ec 0c             	sub    $0xc,%esp
c0025cd7:	50                   	push   %eax
c0025cd8:	e8 f8 07 00 00       	call   c00264d5 <select_device>
c0025cdd:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0025ce0:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ce3:	83 c0 3c             	add    $0x3c,%eax
c0025ce6:	83 ec 0c             	sub    $0xc,%esp
c0025ce9:	50                   	push   %eax
c0025cea:	e8 1d 07 00 00       	call   c002640c <wait_while_busy>
c0025cef:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0025cf2:	8a 45 eb             	mov    -0x15(%ebp),%al
c0025cf5:	84 c0                	test   %al,%al
c0025cf7:	0f 84 83 00 00 00    	je     c0025d80 <reset_channel+0x27b>
    {
      int i;

      select_device (&c->devices[1]);
c0025cfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d00:	83 c0 50             	add    $0x50,%eax
c0025d03:	83 ec 0c             	sub    $0xc,%esp
c0025d06:	50                   	push   %eax
c0025d07:	e8 c9 07 00 00       	call   c00264d5 <select_device>
c0025d0c:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025d0f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025d16:	eb 4a                	jmp    c0025d62 <reset_channel+0x25d>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025d18:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d1b:	8b 40 08             	mov    0x8(%eax),%eax
c0025d1e:	83 c0 02             	add    $0x2,%eax
c0025d21:	0f b7 c0             	movzwl %ax,%eax
c0025d24:	83 ec 0c             	sub    $0xc,%esp
c0025d27:	50                   	push   %eax
c0025d28:	e8 61 fb ff ff       	call   c002588e <inb>
c0025d2d:	83 c4 10             	add    $0x10,%esp
c0025d30:	3c 01                	cmp    $0x1,%al
c0025d32:	75 1c                	jne    c0025d50 <reset_channel+0x24b>
c0025d34:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d37:	8b 40 08             	mov    0x8(%eax),%eax
c0025d3a:	83 c0 03             	add    $0x3,%eax
c0025d3d:	0f b7 c0             	movzwl %ax,%eax
c0025d40:	83 ec 0c             	sub    $0xc,%esp
c0025d43:	50                   	push   %eax
c0025d44:	e8 45 fb ff ff       	call   c002588e <inb>
c0025d49:	83 c4 10             	add    $0x10,%esp
c0025d4c:	3c 01                	cmp    $0x1,%al
c0025d4e:	74 1d                	je     c0025d6d <reset_channel+0x268>
            break;
          timer_msleep (10);
c0025d50:	83 ec 08             	sub    $0x8,%esp
c0025d53:	6a 00                	push   $0x0
c0025d55:	6a 0a                	push   $0xa
c0025d57:	e8 3a e2 ff ff       	call   c0023f96 <timer_msleep>
c0025d5c:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025d5f:	ff 45 f0             	incl   -0x10(%ebp)
c0025d62:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c0025d69:	7e ad                	jle    c0025d18 <reset_channel+0x213>
c0025d6b:	eb 01                	jmp    c0025d6e <reset_channel+0x269>
            break;
c0025d6d:	90                   	nop
        }
      wait_while_busy (&c->devices[1]);
c0025d6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d71:	83 c0 50             	add    $0x50,%eax
c0025d74:	83 ec 0c             	sub    $0xc,%esp
c0025d77:	50                   	push   %eax
c0025d78:	e8 8f 06 00 00       	call   c002640c <wait_while_busy>
c0025d7d:	83 c4 10             	add    $0x10,%esp
    }
}
c0025d80:	90                   	nop
c0025d81:	c9                   	leave  
c0025d82:	c3                   	ret    

c0025d83 <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0025d83:	55                   	push   %ebp
c0025d84:	89 e5                	mov    %esp,%ebp
c0025d86:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025d89:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d8c:	8b 40 08             	mov    0x8(%eax),%eax
c0025d8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0025d92:	83 ec 0c             	sub    $0xc,%esp
c0025d95:	ff 75 08             	pushl  0x8(%ebp)
c0025d98:	e8 38 07 00 00       	call   c00264d5 <select_device>
c0025d9d:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0025da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025da3:	8b 40 08             	mov    0x8(%eax),%eax
c0025da6:	40                   	inc    %eax
c0025da7:	0f b7 c0             	movzwl %ax,%eax
c0025daa:	83 ec 0c             	sub    $0xc,%esp
c0025dad:	50                   	push   %eax
c0025dae:	e8 db fa ff ff       	call   c002588e <inb>
c0025db3:	83 c4 10             	add    $0x10,%esp
c0025db6:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c0025db9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025dbc:	8b 40 08             	mov    0x8(%eax),%eax
c0025dbf:	83 c0 04             	add    $0x4,%eax
c0025dc2:	0f b7 c0             	movzwl %ax,%eax
c0025dc5:	83 ec 0c             	sub    $0xc,%esp
c0025dc8:	50                   	push   %eax
c0025dc9:	e8 c0 fa ff ff       	call   c002588e <inb>
c0025dce:	83 c4 10             	add    $0x10,%esp
c0025dd1:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0025dd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025dd7:	8b 40 08             	mov    0x8(%eax),%eax
c0025dda:	83 c0 05             	add    $0x5,%eax
c0025ddd:	0f b7 c0             	movzwl %ax,%eax
c0025de0:	83 ec 0c             	sub    $0xc,%esp
c0025de3:	50                   	push   %eax
c0025de4:	e8 a5 fa ff ff       	call   c002588e <inb>
c0025de9:	83 c4 10             	add    $0x10,%esp
c0025dec:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c0025def:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025df2:	8b 40 08             	mov    0x8(%eax),%eax
c0025df5:	83 c0 07             	add    $0x7,%eax
c0025df8:	0f b7 c0             	movzwl %ax,%eax
c0025dfb:	83 ec 0c             	sub    $0xc,%esp
c0025dfe:	50                   	push   %eax
c0025dff:	e8 8a fa ff ff       	call   c002588e <inb>
c0025e04:	83 c4 10             	add    $0x10,%esp
c0025e07:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025e0a:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c0025e0e:	74 11                	je     c0025e21 <check_device_type+0x9e>
c0025e10:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025e14:	75 1d                	jne    c0025e33 <check_device_type+0xb0>
c0025e16:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e19:	8b 40 0c             	mov    0xc(%eax),%eax
c0025e1c:	83 f8 01             	cmp    $0x1,%eax
c0025e1f:	74 12                	je     c0025e33 <check_device_type+0xb0>
      || (status & STA_DRDY) == 0
c0025e21:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025e25:	83 e0 40             	and    $0x40,%eax
c0025e28:	85 c0                	test   %eax,%eax
c0025e2a:	74 07                	je     c0025e33 <check_device_type+0xb0>
      || (status & STA_BSY) != 0)
c0025e2c:	8a 45 f0             	mov    -0x10(%ebp),%al
c0025e2f:	84 c0                	test   %al,%al
c0025e31:	79 10                	jns    c0025e43 <check_device_type+0xc0>
    {
      d->is_ata = false;
c0025e33:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e36:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0025e3a:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025e3e:	0f 95 c0             	setne  %al
c0025e41:	eb 2f                	jmp    c0025e72 <check_device_type+0xef>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025e43:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0025e47:	75 06                	jne    c0025e4f <check_device_type+0xcc>
c0025e49:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0025e4d:	74 0c                	je     c0025e5b <check_device_type+0xd8>
c0025e4f:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0025e53:	75 0d                	jne    c0025e62 <check_device_type+0xdf>
c0025e55:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0025e59:	75 07                	jne    c0025e62 <check_device_type+0xdf>
c0025e5b:	b8 01 00 00 00       	mov    $0x1,%eax
c0025e60:	eb 05                	jmp    c0025e67 <check_device_type+0xe4>
c0025e62:	b8 00 00 00 00       	mov    $0x0,%eax
c0025e67:	83 e0 01             	and    $0x1,%eax
c0025e6a:	8b 55 08             	mov    0x8(%ebp),%edx
c0025e6d:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c0025e70:	b0 01                	mov    $0x1,%al
    }
}
c0025e72:	c9                   	leave  
c0025e73:	c3                   	ret    

c0025e74 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0025e74:	55                   	push   %ebp
c0025e75:	89 e5                	mov    %esp,%ebp
c0025e77:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c0025e7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e80:	8b 40 08             	mov    0x8(%eax),%eax
c0025e83:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0025e86:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e89:	8a 40 10             	mov    0x10(%eax),%al
c0025e8c:	84 c0                	test   %al,%al
c0025e8e:	75 21                	jne    c0025eb1 <identify_ata_device+0x3d>
c0025e90:	83 ec 0c             	sub    $0xc,%esp
c0025e93:	68 73 14 03 c0       	push   $0xc0031473
c0025e98:	68 7d 14 03 c0       	push   $0xc003147d
c0025e9d:	68 98 15 03 c0       	push   $0xc0031598
c0025ea2:	68 0d 01 00 00       	push   $0x10d
c0025ea7:	68 5a 14 03 c0       	push   $0xc003145a
c0025eac:	e8 bd 38 00 00       	call   c002976e <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0025eb1:	83 ec 0c             	sub    $0xc,%esp
c0025eb4:	ff 75 08             	pushl  0x8(%ebp)
c0025eb7:	e8 81 06 00 00       	call   c002653d <select_device_wait>
c0025ebc:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025ebf:	83 ec 08             	sub    $0x8,%esp
c0025ec2:	68 ec 00 00 00       	push   $0xec
c0025ec7:	ff 75 f4             	pushl  -0xc(%ebp)
c0025eca:	e8 38 04 00 00       	call   c0026307 <issue_pio_command>
c0025ecf:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025ed2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ed5:	83 c0 28             	add    $0x28,%eax
c0025ed8:	83 ec 0c             	sub    $0xc,%esp
c0025edb:	50                   	push   %eax
c0025edc:	e8 28 cb ff ff       	call   c0022a09 <sema_down>
c0025ee1:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025ee4:	83 ec 0c             	sub    $0xc,%esp
c0025ee7:	ff 75 08             	pushl  0x8(%ebp)
c0025eea:	e8 1d 05 00 00       	call   c002640c <wait_while_busy>
c0025eef:	83 c4 10             	add    $0x10,%esp
c0025ef2:	83 f0 01             	xor    $0x1,%eax
c0025ef5:	84 c0                	test   %al,%al
c0025ef7:	74 0c                	je     c0025f05 <identify_ata_device+0x91>
    {
      d->is_ata = false;
c0025ef9:	8b 45 08             	mov    0x8(%ebp),%eax
c0025efc:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025f00:	e9 fb 00 00 00       	jmp    c0026000 <identify_ata_device+0x18c>
    }
  input_sector (c, id);
c0025f05:	83 ec 08             	sub    $0x8,%esp
c0025f08:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025f0e:	50                   	push   %eax
c0025f0f:	ff 75 f4             	pushl  -0xc(%ebp)
c0025f12:	e8 4e 04 00 00       	call   c0026365 <input_sector>
c0025f17:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0025f1a:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025f20:	83 c0 78             	add    $0x78,%eax
c0025f23:	8b 00                	mov    (%eax),%eax
c0025f25:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0025f28:	83 ec 08             	sub    $0x8,%esp
c0025f2b:	6a 14                	push   $0x14
c0025f2d:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025f33:	83 c0 14             	add    $0x14,%eax
c0025f36:	50                   	push   %eax
c0025f37:	e8 c6 00 00 00       	call   c0026002 <descramble_ata_string>
c0025f3c:	83 c4 10             	add    $0x10,%esp
c0025f3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025f42:	83 ec 08             	sub    $0x8,%esp
c0025f45:	6a 28                	push   $0x28
c0025f47:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025f4d:	83 c0 36             	add    $0x36,%eax
c0025f50:	50                   	push   %eax
c0025f51:	e8 ac 00 00 00       	call   c0026002 <descramble_ata_string>
c0025f56:	83 c4 10             	add    $0x10,%esp
c0025f59:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c0025f5c:	83 ec 0c             	sub    $0xc,%esp
c0025f5f:	ff 75 e8             	pushl  -0x18(%ebp)
c0025f62:	ff 75 ec             	pushl  -0x14(%ebp)
c0025f65:	68 94 14 03 c0       	push   $0xc0031494
c0025f6a:	68 80 00 00 00       	push   $0x80
c0025f6f:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0025f75:	50                   	push   %eax
c0025f76:	e8 0b 14 00 00       	call   c0027386 <snprintf>
c0025f7b:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025f7e:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c0025f85:	76 45                	jbe    c0025fcc <identify_ata_device+0x158>
    {
      printf ("%s: ignoring ", d->name);
c0025f87:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f8a:	83 ec 08             	sub    $0x8,%esp
c0025f8d:	50                   	push   %eax
c0025f8e:	68 ac 14 03 c0       	push   $0xc00314ac
c0025f93:	e8 17 14 00 00       	call   c00273af <printf>
c0025f98:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c0025f9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f9e:	c1 e0 09             	shl    $0x9,%eax
c0025fa1:	ba 00 00 00 00       	mov    $0x0,%edx
c0025fa6:	83 ec 08             	sub    $0x8,%esp
c0025fa9:	52                   	push   %edx
c0025faa:	50                   	push   %eax
c0025fab:	e8 15 21 00 00       	call   c00280c5 <print_human_readable_size>
c0025fb0:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c0025fb3:	83 ec 0c             	sub    $0xc,%esp
c0025fb6:	68 ba 14 03 c0       	push   $0xc00314ba
c0025fbb:	e8 80 5a 00 00       	call   c002ba40 <puts>
c0025fc0:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0025fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fc6:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025fca:	eb 34                	jmp    c0026000 <identify_ata_device+0x18c>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025fcc:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fcf:	83 ec 08             	sub    $0x8,%esp
c0025fd2:	ff 75 08             	pushl  0x8(%ebp)
c0025fd5:	68 40 88 03 c0       	push   $0xc0038840
c0025fda:	ff 75 f0             	pushl  -0x10(%ebp)
c0025fdd:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0025fe3:	52                   	push   %edx
c0025fe4:	6a 04                	push   $0x4
c0025fe6:	50                   	push   %eax
c0025fe7:	e8 6b f2 ff ff       	call   c0025257 <block_register>
c0025fec:	83 c4 20             	add    $0x20,%esp
c0025fef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0025ff2:	83 ec 0c             	sub    $0xc,%esp
c0025ff5:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025ff8:	e8 a2 f3 ff ff       	call   c002539f <partition_scan>
c0025ffd:	83 c4 10             	add    $0x10,%esp
}
c0026000:	c9                   	leave  
c0026001:	c3                   	ret    

c0026002 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0026002:	55                   	push   %ebp
c0026003:	89 e5                	mov    %esp,%ebp
c0026005:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0026008:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002600f:	eb 38                	jmp    c0026049 <descramble_ata_string+0x47>
    {
      char tmp = string[i];
c0026011:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026014:	8b 45 08             	mov    0x8(%ebp),%eax
c0026017:	01 d0                	add    %edx,%eax
c0026019:	8a 00                	mov    (%eax),%al
c002601b:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c002601e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026021:	8b 45 08             	mov    0x8(%ebp),%eax
c0026024:	01 c2                	add    %eax,%edx
c0026026:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026029:	8d 48 01             	lea    0x1(%eax),%ecx
c002602c:	8b 45 08             	mov    0x8(%ebp),%eax
c002602f:	01 c8                	add    %ecx,%eax
c0026031:	8a 00                	mov    (%eax),%al
c0026033:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0026035:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026038:	8d 50 01             	lea    0x1(%eax),%edx
c002603b:	8b 45 08             	mov    0x8(%ebp),%eax
c002603e:	01 c2                	add    %eax,%edx
c0026040:	8a 45 fb             	mov    -0x5(%ebp),%al
c0026043:	88 02                	mov    %al,(%edx)
  for (i = 0; i + 1 < size; i += 2)
c0026045:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0026049:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002604c:	40                   	inc    %eax
c002604d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026050:	7c bf                	jl     c0026011 <descramble_ata_string+0xf>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0026052:	ff 4d 0c             	decl   0xc(%ebp)
c0026055:	eb 2b                	jmp    c0026082 <descramble_ata_string+0x80>
    {
      int c = string[size - 1];
c0026057:	8b 45 0c             	mov    0xc(%ebp),%eax
c002605a:	8d 50 ff             	lea    -0x1(%eax),%edx
c002605d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026060:	01 d0                	add    %edx,%eax
c0026062:	8a 00                	mov    (%eax),%al
c0026064:	0f be c0             	movsbl %al,%eax
c0026067:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c002606a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002606e:	74 0f                	je     c002607f <descramble_ata_string+0x7d>
c0026070:	ff 75 f4             	pushl  -0xc(%ebp)
c0026073:	e8 e1 f7 ff ff       	call   c0025859 <isspace>
c0026078:	83 c4 04             	add    $0x4,%esp
c002607b:	85 c0                	test   %eax,%eax
c002607d:	74 0b                	je     c002608a <descramble_ata_string+0x88>
  for (size--; size > 0; size--)
c002607f:	ff 4d 0c             	decl   0xc(%ebp)
c0026082:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0026086:	7f cf                	jg     c0026057 <descramble_ata_string+0x55>
c0026088:	eb 01                	jmp    c002608b <descramble_ata_string+0x89>
        break; 
c002608a:	90                   	nop
    }
  string[size] = '\0';
c002608b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002608e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026091:	01 d0                	add    %edx,%eax
c0026093:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0026096:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0026099:	c9                   	leave  
c002609a:	c3                   	ret    

c002609b <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c002609b:	55                   	push   %ebp
c002609c:	89 e5                	mov    %esp,%ebp
c002609e:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c00260a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00260a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c00260a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260aa:	8b 40 08             	mov    0x8(%eax),%eax
c00260ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c00260b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00260b3:	83 c0 0c             	add    $0xc,%eax
c00260b6:	83 ec 0c             	sub    $0xc,%esp
c00260b9:	50                   	push   %eax
c00260ba:	e8 08 cc ff ff       	call   c0022cc7 <lock_acquire>
c00260bf:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c00260c2:	83 ec 08             	sub    $0x8,%esp
c00260c5:	ff 75 0c             	pushl  0xc(%ebp)
c00260c8:	ff 75 f4             	pushl  -0xc(%ebp)
c00260cb:	e8 3b 01 00 00       	call   c002620b <select_sector>
c00260d0:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c00260d3:	83 ec 08             	sub    $0x8,%esp
c00260d6:	6a 20                	push   $0x20
c00260d8:	ff 75 f0             	pushl  -0x10(%ebp)
c00260db:	e8 27 02 00 00       	call   c0026307 <issue_pio_command>
c00260e0:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c00260e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00260e6:	83 c0 28             	add    $0x28,%eax
c00260e9:	83 ec 0c             	sub    $0xc,%esp
c00260ec:	50                   	push   %eax
c00260ed:	e8 17 c9 ff ff       	call   c0022a09 <sema_down>
c00260f2:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c00260f5:	83 ec 0c             	sub    $0xc,%esp
c00260f8:	ff 75 f4             	pushl  -0xc(%ebp)
c00260fb:	e8 0c 03 00 00       	call   c002640c <wait_while_busy>
c0026100:	83 c4 10             	add    $0x10,%esp
c0026103:	83 f0 01             	xor    $0x1,%eax
c0026106:	84 c0                	test   %al,%al
c0026108:	74 23                	je     c002612d <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c002610a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002610d:	83 ec 08             	sub    $0x8,%esp
c0026110:	ff 75 0c             	pushl  0xc(%ebp)
c0026113:	50                   	push   %eax
c0026114:	68 cc 14 03 c0       	push   $0xc00314cc
c0026119:	68 ac 15 03 c0       	push   $0xc00315ac
c002611e:	68 62 01 00 00       	push   $0x162
c0026123:	68 5a 14 03 c0       	push   $0xc003145a
c0026128:	e8 41 36 00 00       	call   c002976e <debug_panic>
  input_sector (c, buffer);
c002612d:	83 ec 08             	sub    $0x8,%esp
c0026130:	ff 75 10             	pushl  0x10(%ebp)
c0026133:	ff 75 f0             	pushl  -0x10(%ebp)
c0026136:	e8 2a 02 00 00       	call   c0026365 <input_sector>
c002613b:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c002613e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026141:	83 c0 0c             	add    $0xc,%eax
c0026144:	83 ec 0c             	sub    $0xc,%esp
c0026147:	50                   	push   %eax
c0026148:	e8 ba cc ff ff       	call   c0022e07 <lock_release>
c002614d:	83 c4 10             	add    $0x10,%esp
}
c0026150:	90                   	nop
c0026151:	c9                   	leave  
c0026152:	c3                   	ret    

c0026153 <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0026153:	55                   	push   %ebp
c0026154:	89 e5                	mov    %esp,%ebp
c0026156:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0026159:	8b 45 08             	mov    0x8(%ebp),%eax
c002615c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c002615f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026162:	8b 40 08             	mov    0x8(%eax),%eax
c0026165:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0026168:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002616b:	83 c0 0c             	add    $0xc,%eax
c002616e:	83 ec 0c             	sub    $0xc,%esp
c0026171:	50                   	push   %eax
c0026172:	e8 50 cb ff ff       	call   c0022cc7 <lock_acquire>
c0026177:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c002617a:	83 ec 08             	sub    $0x8,%esp
c002617d:	ff 75 0c             	pushl  0xc(%ebp)
c0026180:	ff 75 f4             	pushl  -0xc(%ebp)
c0026183:	e8 83 00 00 00       	call   c002620b <select_sector>
c0026188:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c002618b:	83 ec 08             	sub    $0x8,%esp
c002618e:	6a 30                	push   $0x30
c0026190:	ff 75 f0             	pushl  -0x10(%ebp)
c0026193:	e8 6f 01 00 00       	call   c0026307 <issue_pio_command>
c0026198:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c002619b:	83 ec 0c             	sub    $0xc,%esp
c002619e:	ff 75 f4             	pushl  -0xc(%ebp)
c00261a1:	e8 66 02 00 00       	call   c002640c <wait_while_busy>
c00261a6:	83 c4 10             	add    $0x10,%esp
c00261a9:	83 f0 01             	xor    $0x1,%eax
c00261ac:	84 c0                	test   %al,%al
c00261ae:	74 23                	je     c00261d3 <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c00261b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261b3:	83 ec 08             	sub    $0x8,%esp
c00261b6:	ff 75 0c             	pushl  0xc(%ebp)
c00261b9:	50                   	push   %eax
c00261ba:	68 ec 14 03 c0       	push   $0xc00314ec
c00261bf:	68 b8 15 03 c0       	push   $0xc00315b8
c00261c4:	68 75 01 00 00       	push   $0x175
c00261c9:	68 5a 14 03 c0       	push   $0xc003145a
c00261ce:	e8 9b 35 00 00       	call   c002976e <debug_panic>
  output_sector (c, buffer);
c00261d3:	83 ec 08             	sub    $0x8,%esp
c00261d6:	ff 75 10             	pushl  0x10(%ebp)
c00261d9:	ff 75 f0             	pushl  -0x10(%ebp)
c00261dc:	e8 a4 01 00 00       	call   c0026385 <output_sector>
c00261e1:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c00261e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00261e7:	83 c0 28             	add    $0x28,%eax
c00261ea:	83 ec 0c             	sub    $0xc,%esp
c00261ed:	50                   	push   %eax
c00261ee:	e8 16 c8 ff ff       	call   c0022a09 <sema_down>
c00261f3:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c00261f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00261f9:	83 c0 0c             	add    $0xc,%eax
c00261fc:	83 ec 0c             	sub    $0xc,%esp
c00261ff:	50                   	push   %eax
c0026200:	e8 02 cc ff ff       	call   c0022e07 <lock_release>
c0026205:	83 c4 10             	add    $0x10,%esp
}
c0026208:	90                   	nop
c0026209:	c9                   	leave  
c002620a:	c3                   	ret    

c002620b <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c002620b:	55                   	push   %ebp
c002620c:	89 e5                	mov    %esp,%ebp
c002620e:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026211:	8b 45 08             	mov    0x8(%ebp),%eax
c0026214:	8b 40 08             	mov    0x8(%eax),%eax
c0026217:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c002621a:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c0026221:	76 21                	jbe    c0026244 <select_sector+0x39>
c0026223:	83 ec 0c             	sub    $0xc,%esp
c0026226:	68 0d 15 03 c0       	push   $0xc003150d
c002622b:	68 7d 14 03 c0       	push   $0xc003147d
c0026230:	68 c4 15 03 c0       	push   $0xc00315c4
c0026235:	68 89 01 00 00       	push   $0x189
c002623a:	68 5a 14 03 c0       	push   $0xc003145a
c002623f:	e8 2a 35 00 00       	call   c002976e <debug_panic>
  
  select_device_wait (d);
c0026244:	83 ec 0c             	sub    $0xc,%esp
c0026247:	ff 75 08             	pushl  0x8(%ebp)
c002624a:	e8 ee 02 00 00       	call   c002653d <select_device_wait>
c002624f:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c0026252:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026255:	8b 40 08             	mov    0x8(%eax),%eax
c0026258:	83 c0 02             	add    $0x2,%eax
c002625b:	0f b7 c0             	movzwl %ax,%eax
c002625e:	83 ec 08             	sub    $0x8,%esp
c0026261:	6a 01                	push   $0x1
c0026263:	50                   	push   %eax
c0026264:	e8 73 f6 ff ff       	call   c00258dc <outb>
c0026269:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c002626c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002626f:	0f b6 d0             	movzbl %al,%edx
c0026272:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026275:	8b 40 08             	mov    0x8(%eax),%eax
c0026278:	83 c0 03             	add    $0x3,%eax
c002627b:	0f b7 c0             	movzwl %ax,%eax
c002627e:	83 ec 08             	sub    $0x8,%esp
c0026281:	52                   	push   %edx
c0026282:	50                   	push   %eax
c0026283:	e8 54 f6 ff ff       	call   c00258dc <outb>
c0026288:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c002628b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002628e:	c1 e8 08             	shr    $0x8,%eax
c0026291:	0f b6 d0             	movzbl %al,%edx
c0026294:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026297:	8b 40 08             	mov    0x8(%eax),%eax
c002629a:	83 c0 04             	add    $0x4,%eax
c002629d:	0f b7 c0             	movzwl %ax,%eax
c00262a0:	83 ec 08             	sub    $0x8,%esp
c00262a3:	52                   	push   %edx
c00262a4:	50                   	push   %eax
c00262a5:	e8 32 f6 ff ff       	call   c00258dc <outb>
c00262aa:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c00262ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00262b0:	c1 e8 10             	shr    $0x10,%eax
c00262b3:	0f b6 d0             	movzbl %al,%edx
c00262b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00262b9:	8b 40 08             	mov    0x8(%eax),%eax
c00262bc:	83 c0 05             	add    $0x5,%eax
c00262bf:	0f b7 c0             	movzwl %ax,%eax
c00262c2:	83 ec 08             	sub    $0x8,%esp
c00262c5:	52                   	push   %edx
c00262c6:	50                   	push   %eax
c00262c7:	e8 10 f6 ff ff       	call   c00258dc <outb>
c00262cc:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00262cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00262d2:	8b 40 0c             	mov    0xc(%eax),%eax
c00262d5:	83 f8 01             	cmp    $0x1,%eax
c00262d8:	75 04                	jne    c00262de <select_sector+0xd3>
c00262da:	b0 f0                	mov    $0xf0,%al
c00262dc:	eb 02                	jmp    c00262e0 <select_sector+0xd5>
c00262de:	b0 e0                	mov    $0xe0,%al
c00262e0:	8b 55 0c             	mov    0xc(%ebp),%edx
c00262e3:	c1 ea 18             	shr    $0x18,%edx
c00262e6:	09 d0                	or     %edx,%eax
  outb (reg_device (c),
c00262e8:	0f b6 d0             	movzbl %al,%edx
c00262eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00262ee:	8b 40 08             	mov    0x8(%eax),%eax
c00262f1:	83 c0 06             	add    $0x6,%eax
c00262f4:	0f b7 c0             	movzwl %ax,%eax
c00262f7:	83 ec 08             	sub    $0x8,%esp
c00262fa:	52                   	push   %edx
c00262fb:	50                   	push   %eax
c00262fc:	e8 db f5 ff ff       	call   c00258dc <outb>
c0026301:	83 c4 10             	add    $0x10,%esp
}
c0026304:	90                   	nop
c0026305:	c9                   	leave  
c0026306:	c3                   	ret    

c0026307 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c0026307:	55                   	push   %ebp
c0026308:	89 e5                	mov    %esp,%ebp
c002630a:	83 ec 18             	sub    $0x18,%esp
c002630d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026310:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c0026313:	e8 36 b2 ff ff       	call   c002154e <intr_get_level>
c0026318:	83 f8 01             	cmp    $0x1,%eax
c002631b:	74 21                	je     c002633e <issue_pio_command+0x37>
c002631d:	83 ec 0c             	sub    $0xc,%esp
c0026320:	68 22 15 03 c0       	push   $0xc0031522
c0026325:	68 7d 14 03 c0       	push   $0xc003147d
c002632a:	68 d4 15 03 c0       	push   $0xc00315d4
c002632f:	68 9b 01 00 00       	push   $0x19b
c0026334:	68 5a 14 03 c0       	push   $0xc003145a
c0026339:	e8 30 34 00 00       	call   c002976e <debug_panic>

  c->expecting_interrupt = true;
c002633e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026341:	c6 40 24 01          	movb   $0x1,0x24(%eax)
  outb (reg_command (c), command);
c0026345:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0026349:	8b 45 08             	mov    0x8(%ebp),%eax
c002634c:	8b 40 08             	mov    0x8(%eax),%eax
c002634f:	83 c0 07             	add    $0x7,%eax
c0026352:	0f b7 c0             	movzwl %ax,%eax
c0026355:	83 ec 08             	sub    $0x8,%esp
c0026358:	52                   	push   %edx
c0026359:	50                   	push   %eax
c002635a:	e8 7d f5 ff ff       	call   c00258dc <outb>
c002635f:	83 c4 10             	add    $0x10,%esp
}
c0026362:	90                   	nop
c0026363:	c9                   	leave  
c0026364:	c3                   	ret    

c0026365 <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c0026365:	55                   	push   %ebp
c0026366:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026368:	8b 45 08             	mov    0x8(%ebp),%eax
c002636b:	8b 40 08             	mov    0x8(%eax),%eax
c002636e:	0f b7 c0             	movzwl %ax,%eax
c0026371:	68 00 01 00 00       	push   $0x100
c0026376:	ff 75 0c             	pushl  0xc(%ebp)
c0026379:	50                   	push   %eax
c002637a:	e8 2a f5 ff ff       	call   c00258a9 <insw>
c002637f:	83 c4 0c             	add    $0xc,%esp
}
c0026382:	90                   	nop
c0026383:	c9                   	leave  
c0026384:	c3                   	ret    

c0026385 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c0026385:	55                   	push   %ebp
c0026386:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026388:	8b 45 08             	mov    0x8(%ebp),%eax
c002638b:	8b 40 08             	mov    0x8(%eax),%eax
c002638e:	0f b7 c0             	movzwl %ax,%eax
c0026391:	68 00 01 00 00       	push   $0x100
c0026396:	ff 75 0c             	pushl  0xc(%ebp)
c0026399:	50                   	push   %eax
c002639a:	e8 5a f5 ff ff       	call   c00258f9 <outsw>
c002639f:	83 c4 0c             	add    $0xc,%esp
}
c00263a2:	90                   	nop
c00263a3:	c9                   	leave  
c00263a4:	c3                   	ret    

c00263a5 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c00263a5:	55                   	push   %ebp
c00263a6:	89 e5                	mov    %esp,%ebp
c00263a8:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c00263ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00263b2:	eb 36                	jmp    c00263ea <wait_until_idle+0x45>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c00263b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00263b7:	8b 40 08             	mov    0x8(%eax),%eax
c00263ba:	8b 40 08             	mov    0x8(%eax),%eax
c00263bd:	83 c0 07             	add    $0x7,%eax
c00263c0:	0f b7 c0             	movzwl %ax,%eax
c00263c3:	50                   	push   %eax
c00263c4:	e8 c5 f4 ff ff       	call   c002588e <inb>
c00263c9:	83 c4 04             	add    $0x4,%esp
c00263cc:	0f b6 c0             	movzbl %al,%eax
c00263cf:	25 88 00 00 00       	and    $0x88,%eax
c00263d4:	85 c0                	test   %eax,%eax
c00263d6:	74 31                	je     c0026409 <wait_until_idle+0x64>
        return;
      timer_usleep (10);
c00263d8:	83 ec 08             	sub    $0x8,%esp
c00263db:	6a 00                	push   $0x0
c00263dd:	6a 0a                	push   $0xa
c00263df:	e8 dd db ff ff       	call   c0023fc1 <timer_usleep>
c00263e4:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 1000; i++) 
c00263e7:	ff 45 f4             	incl   -0xc(%ebp)
c00263ea:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c00263f1:	7e c1                	jle    c00263b4 <wait_until_idle+0xf>
    }

  printf ("%s: idle timeout\n", d->name);
c00263f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00263f6:	83 ec 08             	sub    $0x8,%esp
c00263f9:	50                   	push   %eax
c00263fa:	68 3f 15 03 c0       	push   $0xc003153f
c00263ff:	e8 ab 0f 00 00       	call   c00273af <printf>
c0026404:	83 c4 10             	add    $0x10,%esp
c0026407:	eb 01                	jmp    c002640a <wait_until_idle+0x65>
        return;
c0026409:	90                   	nop
}
c002640a:	c9                   	leave  
c002640b:	c3                   	ret    

c002640c <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c002640c:	55                   	push   %ebp
c002640d:	89 e5                	mov    %esp,%ebp
c002640f:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026412:	8b 45 08             	mov    0x8(%ebp),%eax
c0026415:	8b 40 08             	mov    0x8(%eax),%eax
c0026418:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c002641b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026422:	e9 8d 00 00 00       	jmp    c00264b4 <wait_while_busy+0xa8>
    {
      if (i == 700)
c0026427:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c002642e:	75 14                	jne    c0026444 <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c0026430:	8b 45 08             	mov    0x8(%ebp),%eax
c0026433:	83 ec 08             	sub    $0x8,%esp
c0026436:	50                   	push   %eax
c0026437:	68 51 15 03 c0       	push   $0xc0031551
c002643c:	e8 6e 0f 00 00       	call   c00273af <printf>
c0026441:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c0026444:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026447:	8b 40 08             	mov    0x8(%eax),%eax
c002644a:	05 06 02 00 00       	add    $0x206,%eax
c002644f:	0f b7 c0             	movzwl %ax,%eax
c0026452:	83 ec 0c             	sub    $0xc,%esp
c0026455:	50                   	push   %eax
c0026456:	e8 33 f4 ff ff       	call   c002588e <inb>
c002645b:	83 c4 10             	add    $0x10,%esp
c002645e:	84 c0                	test   %al,%al
c0026460:	78 40                	js     c00264a2 <wait_while_busy+0x96>
        {
          if (i >= 700)
c0026462:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c0026469:	7e 10                	jle    c002647b <wait_while_busy+0x6f>
            printf ("ok\n");
c002646b:	83 ec 0c             	sub    $0xc,%esp
c002646e:	68 66 15 03 c0       	push   $0xc0031566
c0026473:	e8 c8 55 00 00       	call   c002ba40 <puts>
c0026478:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c002647b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002647e:	8b 40 08             	mov    0x8(%eax),%eax
c0026481:	05 06 02 00 00       	add    $0x206,%eax
c0026486:	0f b7 c0             	movzwl %ax,%eax
c0026489:	83 ec 0c             	sub    $0xc,%esp
c002648c:	50                   	push   %eax
c002648d:	e8 fc f3 ff ff       	call   c002588e <inb>
c0026492:	83 c4 10             	add    $0x10,%esp
c0026495:	0f b6 c0             	movzbl %al,%eax
c0026498:	83 e0 08             	and    $0x8,%eax
c002649b:	85 c0                	test   %eax,%eax
c002649d:	0f 95 c0             	setne  %al
c00264a0:	eb 31                	jmp    c00264d3 <wait_while_busy+0xc7>
        }
      timer_msleep (10);
c00264a2:	83 ec 08             	sub    $0x8,%esp
c00264a5:	6a 00                	push   $0x0
c00264a7:	6a 0a                	push   $0xa
c00264a9:	e8 e8 da ff ff       	call   c0023f96 <timer_msleep>
c00264ae:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 3000; i++)
c00264b1:	ff 45 f4             	incl   -0xc(%ebp)
c00264b4:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c00264bb:	0f 8e 66 ff ff ff    	jle    c0026427 <wait_while_busy+0x1b>
    }

  printf ("failed\n");
c00264c1:	83 ec 0c             	sub    $0xc,%esp
c00264c4:	68 69 15 03 c0       	push   $0xc0031569
c00264c9:	e8 72 55 00 00       	call   c002ba40 <puts>
c00264ce:	83 c4 10             	add    $0x10,%esp
  return false;
c00264d1:	b0 00                	mov    $0x0,%al
}
c00264d3:	c9                   	leave  
c00264d4:	c3                   	ret    

c00264d5 <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c00264d5:	55                   	push   %ebp
c00264d6:	89 e5                	mov    %esp,%ebp
c00264d8:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00264db:	8b 45 08             	mov    0x8(%ebp),%eax
c00264de:	8b 40 08             	mov    0x8(%eax),%eax
c00264e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c00264e4:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c00264e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00264eb:	8b 40 0c             	mov    0xc(%eax),%eax
c00264ee:	83 f8 01             	cmp    $0x1,%eax
c00264f1:	75 04                	jne    c00264f7 <select_device+0x22>
    dev |= DEV_DEV;
c00264f3:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c00264f7:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00264fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00264fe:	8b 40 08             	mov    0x8(%eax),%eax
c0026501:	83 c0 06             	add    $0x6,%eax
c0026504:	0f b7 c0             	movzwl %ax,%eax
c0026507:	52                   	push   %edx
c0026508:	50                   	push   %eax
c0026509:	e8 ce f3 ff ff       	call   c00258dc <outb>
c002650e:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c0026511:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026514:	8b 40 08             	mov    0x8(%eax),%eax
c0026517:	05 06 02 00 00       	add    $0x206,%eax
c002651c:	0f b7 c0             	movzwl %ax,%eax
c002651f:	50                   	push   %eax
c0026520:	e8 69 f3 ff ff       	call   c002588e <inb>
c0026525:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0026528:	83 ec 08             	sub    $0x8,%esp
c002652b:	6a 00                	push   $0x0
c002652d:	68 90 01 00 00       	push   $0x190
c0026532:	e8 b5 da ff ff       	call   c0023fec <timer_nsleep>
c0026537:	83 c4 10             	add    $0x10,%esp
}
c002653a:	90                   	nop
c002653b:	c9                   	leave  
c002653c:	c3                   	ret    

c002653d <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c002653d:	55                   	push   %ebp
c002653e:	89 e5                	mov    %esp,%ebp
c0026540:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c0026543:	83 ec 0c             	sub    $0xc,%esp
c0026546:	ff 75 08             	pushl  0x8(%ebp)
c0026549:	e8 57 fe ff ff       	call   c00263a5 <wait_until_idle>
c002654e:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c0026551:	83 ec 0c             	sub    $0xc,%esp
c0026554:	ff 75 08             	pushl  0x8(%ebp)
c0026557:	e8 79 ff ff ff       	call   c00264d5 <select_device>
c002655c:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c002655f:	83 ec 0c             	sub    $0xc,%esp
c0026562:	ff 75 08             	pushl  0x8(%ebp)
c0026565:	e8 3b fe ff ff       	call   c00263a5 <wait_until_idle>
c002656a:	83 c4 10             	add    $0x10,%esp
}
c002656d:	90                   	nop
c002656e:	c9                   	leave  
c002656f:	c3                   	ret    

c0026570 <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0026570:	55                   	push   %ebp
c0026571:	89 e5                	mov    %esp,%ebp
c0026573:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026576:	c7 45 f4 40 a1 03 c0 	movl   $0xc003a140,-0xc(%ebp)
c002657d:	eb 60                	jmp    c00265df <interrupt_handler+0x6f>
    if (f->vec_no == c->irq)
c002657f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026582:	8b 50 30             	mov    0x30(%eax),%edx
c0026585:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026588:	8a 40 0a             	mov    0xa(%eax),%al
c002658b:	0f b6 c0             	movzbl %al,%eax
c002658e:	39 c2                	cmp    %eax,%edx
c0026590:	75 49                	jne    c00265db <interrupt_handler+0x6b>
      {
        if (c->expecting_interrupt) 
c0026592:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026595:	8a 40 24             	mov    0x24(%eax),%al
c0026598:	84 c0                	test   %al,%al
c002659a:	74 29                	je     c00265c5 <interrupt_handler+0x55>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c002659c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002659f:	8b 40 08             	mov    0x8(%eax),%eax
c00265a2:	83 c0 07             	add    $0x7,%eax
c00265a5:	0f b7 c0             	movzwl %ax,%eax
c00265a8:	50                   	push   %eax
c00265a9:	e8 e0 f2 ff ff       	call   c002588e <inb>
c00265ae:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c00265b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00265b4:	83 c0 28             	add    $0x28,%eax
c00265b7:	83 ec 0c             	sub    $0xc,%esp
c00265ba:	50                   	push   %eax
c00265bb:	e8 53 c5 ff ff       	call   c0022b13 <sema_up>
c00265c0:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c00265c3:	eb 3d                	jmp    c0026602 <interrupt_handler+0x92>
          printf ("%s: unexpected interrupt\n", c->name);
c00265c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00265c8:	83 ec 08             	sub    $0x8,%esp
c00265cb:	50                   	push   %eax
c00265cc:	68 70 15 03 c0       	push   $0xc0031570
c00265d1:	e8 d9 0d 00 00       	call   c00273af <printf>
c00265d6:	83 c4 10             	add    $0x10,%esp
        return;
c00265d9:	eb 27                	jmp    c0026602 <interrupt_handler+0x92>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00265db:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
c00265df:	b8 08 a2 03 c0       	mov    $0xc003a208,%eax
c00265e4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00265e7:	72 96                	jb     c002657f <interrupt_handler+0xf>
      }

  NOT_REACHED ();
c00265e9:	68 38 14 03 c0       	push   $0xc0031438
c00265ee:	68 e8 15 03 c0       	push   $0xc00315e8
c00265f3:	68 0c 02 00 00       	push   $0x20c
c00265f8:	68 5a 14 03 c0       	push   $0xc003145a
c00265fd:	e8 6c 31 00 00       	call   c002976e <debug_panic>
}
c0026602:	c9                   	leave  
c0026603:	c3                   	ret    

c0026604 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0026604:	55                   	push   %ebp
c0026605:	89 e5                	mov    %esp,%ebp
c0026607:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c002660a:	83 ec 0c             	sub    $0xc,%esp
c002660d:	68 20 a2 03 c0       	push   $0xc003a220
c0026612:	e8 03 01 00 00       	call   c002671a <intq_init>
c0026617:	83 c4 10             	add    $0x10,%esp
}
c002661a:	90                   	nop
c002661b:	c9                   	leave  
c002661c:	c3                   	ret    

c002661d <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c002661d:	55                   	push   %ebp
c002661e:	89 e5                	mov    %esp,%ebp
c0026620:	83 ec 18             	sub    $0x18,%esp
c0026623:	8b 45 08             	mov    0x8(%ebp),%eax
c0026626:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026629:	e8 20 af ff ff       	call   c002154e <intr_get_level>
c002662e:	85 c0                	test   %eax,%eax
c0026630:	74 1e                	je     c0026650 <input_putc+0x33>
c0026632:	83 ec 0c             	sub    $0xc,%esp
c0026635:	68 fc 15 03 c0       	push   $0xc00315fc
c002663a:	68 1a 16 03 c0       	push   $0xc003161a
c002663f:	68 5c 16 03 c0       	push   $0xc003165c
c0026644:	6a 15                	push   $0x15
c0026646:	68 31 16 03 c0       	push   $0xc0031631
c002664b:	e8 1e 31 00 00       	call   c002976e <debug_panic>
  ASSERT (!intq_full (&buffer));
c0026650:	83 ec 0c             	sub    $0xc,%esp
c0026653:	68 20 a2 03 c0       	push   $0xc003a220
c0026658:	e8 41 01 00 00       	call   c002679e <intq_full>
c002665d:	83 c4 10             	add    $0x10,%esp
c0026660:	83 f0 01             	xor    $0x1,%eax
c0026663:	84 c0                	test   %al,%al
c0026665:	75 1e                	jne    c0026685 <input_putc+0x68>
c0026667:	83 ec 0c             	sub    $0xc,%esp
c002666a:	68 47 16 03 c0       	push   $0xc0031647
c002666f:	68 1a 16 03 c0       	push   $0xc003161a
c0026674:	68 5c 16 03 c0       	push   $0xc003165c
c0026679:	6a 16                	push   $0x16
c002667b:	68 31 16 03 c0       	push   $0xc0031631
c0026680:	e8 e9 30 00 00       	call   c002976e <debug_panic>

  intq_putc (&buffer, key);
c0026685:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026689:	83 ec 08             	sub    $0x8,%esp
c002668c:	50                   	push   %eax
c002668d:	68 20 a2 03 c0       	push   $0xc003a220
c0026692:	e8 35 02 00 00       	call   c00268cc <intq_putc>
c0026697:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c002669a:	e8 23 e6 ff ff       	call   c0024cc2 <serial_notify>
}
c002669f:	90                   	nop
c00266a0:	c9                   	leave  
c00266a1:	c3                   	ret    

c00266a2 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c00266a2:	55                   	push   %ebp
c00266a3:	89 e5                	mov    %esp,%ebp
c00266a5:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c00266a8:	e8 16 af ff ff       	call   c00215c3 <intr_disable>
c00266ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c00266b0:	83 ec 0c             	sub    $0xc,%esp
c00266b3:	68 20 a2 03 c0       	push   $0xc003a220
c00266b8:	e8 2f 01 00 00       	call   c00267ec <intq_getc>
c00266bd:	83 c4 10             	add    $0x10,%esp
c00266c0:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c00266c3:	e8 fa e5 ff ff       	call   c0024cc2 <serial_notify>
  intr_set_level (old_level);
c00266c8:	83 ec 0c             	sub    $0xc,%esp
c00266cb:	ff 75 f4             	pushl  -0xc(%ebp)
c00266ce:	e8 98 ae ff ff       	call   c002156b <intr_set_level>
c00266d3:	83 c4 10             	add    $0x10,%esp
  
  return key;
c00266d6:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c00266d9:	c9                   	leave  
c00266da:	c3                   	ret    

c00266db <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c00266db:	55                   	push   %ebp
c00266dc:	89 e5                	mov    %esp,%ebp
c00266de:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00266e1:	e8 68 ae ff ff       	call   c002154e <intr_get_level>
c00266e6:	85 c0                	test   %eax,%eax
c00266e8:	74 1e                	je     c0026708 <input_full+0x2d>
c00266ea:	83 ec 0c             	sub    $0xc,%esp
c00266ed:	68 fc 15 03 c0       	push   $0xc00315fc
c00266f2:	68 1a 16 03 c0       	push   $0xc003161a
c00266f7:	68 68 16 03 c0       	push   $0xc0031668
c00266fc:	6a 32                	push   $0x32
c00266fe:	68 31 16 03 c0       	push   $0xc0031631
c0026703:	e8 66 30 00 00       	call   c002976e <debug_panic>
  return intq_full (&buffer);
c0026708:	83 ec 0c             	sub    $0xc,%esp
c002670b:	68 20 a2 03 c0       	push   $0xc003a220
c0026710:	e8 89 00 00 00       	call   c002679e <intq_full>
c0026715:	83 c4 10             	add    $0x10,%esp
}
c0026718:	c9                   	leave  
c0026719:	c3                   	ret    

c002671a <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c002671a:	55                   	push   %ebp
c002671b:	89 e5                	mov    %esp,%ebp
c002671d:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c0026720:	8b 45 08             	mov    0x8(%ebp),%eax
c0026723:	83 ec 0c             	sub    $0xc,%esp
c0026726:	50                   	push   %eax
c0026727:	e8 4e c5 ff ff       	call   c0022c7a <lock_init>
c002672c:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c002672f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026732:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c0026739:	8b 45 08             	mov    0x8(%ebp),%eax
c002673c:	8b 50 1c             	mov    0x1c(%eax),%edx
c002673f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026742:	89 50 18             	mov    %edx,0x18(%eax)
  q->head = q->tail = 0;
c0026745:	8b 45 08             	mov    0x8(%ebp),%eax
c0026748:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
c002674f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026752:	8b 50 64             	mov    0x64(%eax),%edx
c0026755:	8b 45 08             	mov    0x8(%ebp),%eax
c0026758:	89 50 60             	mov    %edx,0x60(%eax)
}
c002675b:	90                   	nop
c002675c:	c9                   	leave  
c002675d:	c3                   	ret    

c002675e <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c002675e:	55                   	push   %ebp
c002675f:	89 e5                	mov    %esp,%ebp
c0026761:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026764:	e8 e5 ad ff ff       	call   c002154e <intr_get_level>
c0026769:	85 c0                	test   %eax,%eax
c002676b:	74 1e                	je     c002678b <intq_empty+0x2d>
c002676d:	83 ec 0c             	sub    $0xc,%esp
c0026770:	68 74 16 03 c0       	push   $0xc0031674
c0026775:	68 92 16 03 c0       	push   $0xc0031692
c002677a:	68 88 17 03 c0       	push   $0xc0031788
c002677f:	6a 16                	push   $0x16
c0026781:	68 a9 16 03 c0       	push   $0xc00316a9
c0026786:	e8 e3 2f 00 00       	call   c002976e <debug_panic>
  return q->head == q->tail;
c002678b:	8b 45 08             	mov    0x8(%ebp),%eax
c002678e:	8b 50 60             	mov    0x60(%eax),%edx
c0026791:	8b 45 08             	mov    0x8(%ebp),%eax
c0026794:	8b 40 64             	mov    0x64(%eax),%eax
c0026797:	39 c2                	cmp    %eax,%edx
c0026799:	0f 94 c0             	sete   %al
}
c002679c:	c9                   	leave  
c002679d:	c3                   	ret    

c002679e <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c002679e:	55                   	push   %ebp
c002679f:	89 e5                	mov    %esp,%ebp
c00267a1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00267a4:	e8 a5 ad ff ff       	call   c002154e <intr_get_level>
c00267a9:	85 c0                	test   %eax,%eax
c00267ab:	74 1e                	je     c00267cb <intq_full+0x2d>
c00267ad:	83 ec 0c             	sub    $0xc,%esp
c00267b0:	68 74 16 03 c0       	push   $0xc0031674
c00267b5:	68 92 16 03 c0       	push   $0xc0031692
c00267ba:	68 94 17 03 c0       	push   $0xc0031794
c00267bf:	6a 1e                	push   $0x1e
c00267c1:	68 a9 16 03 c0       	push   $0xc00316a9
c00267c6:	e8 a3 2f 00 00       	call   c002976e <debug_panic>
  return next (q->head) == q->tail;
c00267cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00267ce:	8b 40 60             	mov    0x60(%eax),%eax
c00267d1:	83 ec 0c             	sub    $0xc,%esp
c00267d4:	50                   	push   %eax
c00267d5:	e8 d6 01 00 00       	call   c00269b0 <next>
c00267da:	83 c4 10             	add    $0x10,%esp
c00267dd:	89 c2                	mov    %eax,%edx
c00267df:	8b 45 08             	mov    0x8(%ebp),%eax
c00267e2:	8b 40 64             	mov    0x64(%eax),%eax
c00267e5:	39 c2                	cmp    %eax,%edx
c00267e7:	0f 94 c0             	sete   %al
}
c00267ea:	c9                   	leave  
c00267eb:	c3                   	ret    

c00267ec <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c00267ec:	55                   	push   %ebp
c00267ed:	89 e5                	mov    %esp,%ebp
c00267ef:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c00267f2:	e8 57 ad ff ff       	call   c002154e <intr_get_level>
c00267f7:	85 c0                	test   %eax,%eax
c00267f9:	74 7b                	je     c0026876 <intq_getc+0x8a>
c00267fb:	83 ec 0c             	sub    $0xc,%esp
c00267fe:	68 74 16 03 c0       	push   $0xc0031674
c0026803:	68 92 16 03 c0       	push   $0xc0031692
c0026808:	68 a0 17 03 c0       	push   $0xc00317a0
c002680d:	6a 2a                	push   $0x2a
c002680f:	68 a9 16 03 c0       	push   $0xc00316a9
c0026814:	e8 55 2f 00 00       	call   c002976e <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c0026819:	e8 72 b0 ff ff       	call   c0021890 <intr_context>
c002681e:	83 f0 01             	xor    $0x1,%eax
c0026821:	84 c0                	test   %al,%al
c0026823:	75 1e                	jne    c0026843 <intq_getc+0x57>
c0026825:	83 ec 0c             	sub    $0xc,%esp
c0026828:	68 be 16 03 c0       	push   $0xc00316be
c002682d:	68 92 16 03 c0       	push   $0xc0031692
c0026832:	68 a0 17 03 c0       	push   $0xc00317a0
c0026837:	6a 2d                	push   $0x2d
c0026839:	68 a9 16 03 c0       	push   $0xc00316a9
c002683e:	e8 2b 2f 00 00       	call   c002976e <debug_panic>
      lock_acquire (&q->lock);
c0026843:	8b 45 08             	mov    0x8(%ebp),%eax
c0026846:	83 ec 0c             	sub    $0xc,%esp
c0026849:	50                   	push   %eax
c002684a:	e8 78 c4 ff ff       	call   c0022cc7 <lock_acquire>
c002684f:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c0026852:	8b 45 08             	mov    0x8(%ebp),%eax
c0026855:	83 c0 1c             	add    $0x1c,%eax
c0026858:	83 ec 08             	sub    $0x8,%esp
c002685b:	50                   	push   %eax
c002685c:	ff 75 08             	pushl  0x8(%ebp)
c002685f:	e8 63 01 00 00       	call   c00269c7 <wait>
c0026864:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026867:	8b 45 08             	mov    0x8(%ebp),%eax
c002686a:	83 ec 0c             	sub    $0xc,%esp
c002686d:	50                   	push   %eax
c002686e:	e8 94 c5 ff ff       	call   c0022e07 <lock_release>
c0026873:	83 c4 10             	add    $0x10,%esp
  while (intq_empty (q)) 
c0026876:	83 ec 0c             	sub    $0xc,%esp
c0026879:	ff 75 08             	pushl  0x8(%ebp)
c002687c:	e8 dd fe ff ff       	call   c002675e <intq_empty>
c0026881:	83 c4 10             	add    $0x10,%esp
c0026884:	84 c0                	test   %al,%al
c0026886:	75 91                	jne    c0026819 <intq_getc+0x2d>
    }
  
  byte = q->buf[q->tail];
c0026888:	8b 45 08             	mov    0x8(%ebp),%eax
c002688b:	8b 40 64             	mov    0x64(%eax),%eax
c002688e:	8b 55 08             	mov    0x8(%ebp),%edx
c0026891:	8a 44 02 20          	mov    0x20(%edx,%eax,1),%al
c0026895:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0026898:	8b 45 08             	mov    0x8(%ebp),%eax
c002689b:	8b 40 64             	mov    0x64(%eax),%eax
c002689e:	83 ec 0c             	sub    $0xc,%esp
c00268a1:	50                   	push   %eax
c00268a2:	e8 09 01 00 00       	call   c00269b0 <next>
c00268a7:	83 c4 10             	add    $0x10,%esp
c00268aa:	89 c2                	mov    %eax,%edx
c00268ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00268af:	89 50 64             	mov    %edx,0x64(%eax)
  signal (q, &q->not_full);
c00268b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00268b5:	83 c0 18             	add    $0x18,%eax
c00268b8:	83 ec 08             	sub    $0x8,%esp
c00268bb:	50                   	push   %eax
c00268bc:	ff 75 08             	pushl  0x8(%ebp)
c00268bf:	e8 c6 01 00 00       	call   c0026a8a <signal>
c00268c4:	83 c4 10             	add    $0x10,%esp
  return byte;
c00268c7:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c00268ca:	c9                   	leave  
c00268cb:	c3                   	ret    

c00268cc <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c00268cc:	55                   	push   %ebp
c00268cd:	89 e5                	mov    %esp,%ebp
c00268cf:	83 ec 18             	sub    $0x18,%esp
c00268d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268d5:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00268d8:	e8 71 ac ff ff       	call   c002154e <intr_get_level>
c00268dd:	85 c0                	test   %eax,%eax
c00268df:	74 7b                	je     c002695c <intq_putc+0x90>
c00268e1:	83 ec 0c             	sub    $0xc,%esp
c00268e4:	68 74 16 03 c0       	push   $0xc0031674
c00268e9:	68 92 16 03 c0       	push   $0xc0031692
c00268ee:	68 ac 17 03 c0       	push   $0xc00317ac
c00268f3:	6a 3f                	push   $0x3f
c00268f5:	68 a9 16 03 c0       	push   $0xc00316a9
c00268fa:	e8 6f 2e 00 00       	call   c002976e <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c00268ff:	e8 8c af ff ff       	call   c0021890 <intr_context>
c0026904:	83 f0 01             	xor    $0x1,%eax
c0026907:	84 c0                	test   %al,%al
c0026909:	75 1e                	jne    c0026929 <intq_putc+0x5d>
c002690b:	83 ec 0c             	sub    $0xc,%esp
c002690e:	68 be 16 03 c0       	push   $0xc00316be
c0026913:	68 92 16 03 c0       	push   $0xc0031692
c0026918:	68 ac 17 03 c0       	push   $0xc00317ac
c002691d:	6a 42                	push   $0x42
c002691f:	68 a9 16 03 c0       	push   $0xc00316a9
c0026924:	e8 45 2e 00 00       	call   c002976e <debug_panic>
      lock_acquire (&q->lock);
c0026929:	8b 45 08             	mov    0x8(%ebp),%eax
c002692c:	83 ec 0c             	sub    $0xc,%esp
c002692f:	50                   	push   %eax
c0026930:	e8 92 c3 ff ff       	call   c0022cc7 <lock_acquire>
c0026935:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c0026938:	8b 45 08             	mov    0x8(%ebp),%eax
c002693b:	83 c0 18             	add    $0x18,%eax
c002693e:	83 ec 08             	sub    $0x8,%esp
c0026941:	50                   	push   %eax
c0026942:	ff 75 08             	pushl  0x8(%ebp)
c0026945:	e8 7d 00 00 00       	call   c00269c7 <wait>
c002694a:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c002694d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026950:	83 ec 0c             	sub    $0xc,%esp
c0026953:	50                   	push   %eax
c0026954:	e8 ae c4 ff ff       	call   c0022e07 <lock_release>
c0026959:	83 c4 10             	add    $0x10,%esp
  while (intq_full (q))
c002695c:	83 ec 0c             	sub    $0xc,%esp
c002695f:	ff 75 08             	pushl  0x8(%ebp)
c0026962:	e8 37 fe ff ff       	call   c002679e <intq_full>
c0026967:	83 c4 10             	add    $0x10,%esp
c002696a:	84 c0                	test   %al,%al
c002696c:	75 91                	jne    c00268ff <intq_putc+0x33>
    }

  q->buf[q->head] = byte;
c002696e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026971:	8b 40 60             	mov    0x60(%eax),%eax
c0026974:	8b 55 08             	mov    0x8(%ebp),%edx
c0026977:	8a 4d f4             	mov    -0xc(%ebp),%cl
c002697a:	88 4c 02 20          	mov    %cl,0x20(%edx,%eax,1)
  q->head = next (q->head);
c002697e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026981:	8b 40 60             	mov    0x60(%eax),%eax
c0026984:	83 ec 0c             	sub    $0xc,%esp
c0026987:	50                   	push   %eax
c0026988:	e8 23 00 00 00       	call   c00269b0 <next>
c002698d:	83 c4 10             	add    $0x10,%esp
c0026990:	89 c2                	mov    %eax,%edx
c0026992:	8b 45 08             	mov    0x8(%ebp),%eax
c0026995:	89 50 60             	mov    %edx,0x60(%eax)
  signal (q, &q->not_empty);
c0026998:	8b 45 08             	mov    0x8(%ebp),%eax
c002699b:	83 c0 1c             	add    $0x1c,%eax
c002699e:	83 ec 08             	sub    $0x8,%esp
c00269a1:	50                   	push   %eax
c00269a2:	ff 75 08             	pushl  0x8(%ebp)
c00269a5:	e8 e0 00 00 00       	call   c0026a8a <signal>
c00269aa:	83 c4 10             	add    $0x10,%esp
}
c00269ad:	90                   	nop
c00269ae:	c9                   	leave  
c00269af:	c3                   	ret    

c00269b0 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c00269b0:	55                   	push   %ebp
c00269b1:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c00269b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00269b6:	40                   	inc    %eax
c00269b7:	25 3f 00 00 80       	and    $0x8000003f,%eax
c00269bc:	85 c0                	test   %eax,%eax
c00269be:	79 05                	jns    c00269c5 <next+0x15>
c00269c0:	48                   	dec    %eax
c00269c1:	83 c8 c0             	or     $0xffffffc0,%eax
c00269c4:	40                   	inc    %eax
}
c00269c5:	5d                   	pop    %ebp
c00269c6:	c3                   	ret    

c00269c7 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c00269c7:	55                   	push   %ebp
c00269c8:	89 e5                	mov    %esp,%ebp
c00269ca:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c00269cd:	e8 be ae ff ff       	call   c0021890 <intr_context>
c00269d2:	83 f0 01             	xor    $0x1,%eax
c00269d5:	84 c0                	test   %al,%al
c00269d7:	75 1e                	jne    c00269f7 <wait+0x30>
c00269d9:	83 ec 0c             	sub    $0xc,%esp
c00269dc:	68 be 16 03 c0       	push   $0xc00316be
c00269e1:	68 92 16 03 c0       	push   $0xc0031692
c00269e6:	68 b8 17 03 c0       	push   $0xc00317b8
c00269eb:	6a 59                	push   $0x59
c00269ed:	68 a9 16 03 c0       	push   $0xc00316a9
c00269f2:	e8 77 2d 00 00       	call   c002976e <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00269f7:	e8 52 ab ff ff       	call   c002154e <intr_get_level>
c00269fc:	85 c0                	test   %eax,%eax
c00269fe:	74 1e                	je     c0026a1e <wait+0x57>
c0026a00:	83 ec 0c             	sub    $0xc,%esp
c0026a03:	68 74 16 03 c0       	push   $0xc0031674
c0026a08:	68 92 16 03 c0       	push   $0xc0031692
c0026a0d:	68 b8 17 03 c0       	push   $0xc00317b8
c0026a12:	6a 5a                	push   $0x5a
c0026a14:	68 a9 16 03 c0       	push   $0xc00316a9
c0026a19:	e8 50 2d 00 00       	call   c002976e <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0026a1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a21:	83 c0 1c             	add    $0x1c,%eax
c0026a24:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026a27:	75 12                	jne    c0026a3b <wait+0x74>
c0026a29:	83 ec 0c             	sub    $0xc,%esp
c0026a2c:	ff 75 08             	pushl  0x8(%ebp)
c0026a2f:	e8 2a fd ff ff       	call   c002675e <intq_empty>
c0026a34:	83 c4 10             	add    $0x10,%esp
c0026a37:	84 c0                	test   %al,%al
c0026a39:	75 3b                	jne    c0026a76 <wait+0xaf>
c0026a3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a3e:	83 c0 18             	add    $0x18,%eax
c0026a41:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026a44:	75 12                	jne    c0026a58 <wait+0x91>
c0026a46:	83 ec 0c             	sub    $0xc,%esp
c0026a49:	ff 75 08             	pushl  0x8(%ebp)
c0026a4c:	e8 4d fd ff ff       	call   c002679e <intq_full>
c0026a51:	83 c4 10             	add    $0x10,%esp
c0026a54:	84 c0                	test   %al,%al
c0026a56:	75 1e                	jne    c0026a76 <wait+0xaf>
c0026a58:	83 ec 0c             	sub    $0xc,%esp
c0026a5b:	68 d0 16 03 c0       	push   $0xc00316d0
c0026a60:	68 92 16 03 c0       	push   $0xc0031692
c0026a65:	68 b8 17 03 c0       	push   $0xc00317b8
c0026a6a:	6a 5c                	push   $0x5c
c0026a6c:	68 a9 16 03 c0       	push   $0xc00316a9
c0026a71:	e8 f8 2c 00 00       	call   c002976e <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0026a76:	e8 e5 a3 ff ff       	call   c0020e60 <thread_current>
c0026a7b:	89 c2                	mov    %eax,%edx
c0026a7d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026a80:	89 10                	mov    %edx,(%eax)
  thread_block ();
c0026a82:	e8 b9 a2 ff ff       	call   c0020d40 <thread_block>
}
c0026a87:	90                   	nop
c0026a88:	c9                   	leave  
c0026a89:	c3                   	ret    

c0026a8a <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026a8a:	55                   	push   %ebp
c0026a8b:	89 e5                	mov    %esp,%ebp
c0026a8d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026a90:	e8 b9 aa ff ff       	call   c002154e <intr_get_level>
c0026a95:	85 c0                	test   %eax,%eax
c0026a97:	74 1e                	je     c0026ab7 <signal+0x2d>
c0026a99:	83 ec 0c             	sub    $0xc,%esp
c0026a9c:	68 74 16 03 c0       	push   $0xc0031674
c0026aa1:	68 92 16 03 c0       	push   $0xc0031692
c0026aa6:	68 c0 17 03 c0       	push   $0xc00317c0
c0026aab:	6a 69                	push   $0x69
c0026aad:	68 a9 16 03 c0       	push   $0xc00316a9
c0026ab2:	e8 b7 2c 00 00       	call   c002976e <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026ab7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026aba:	83 c0 1c             	add    $0x1c,%eax
c0026abd:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026ac0:	75 15                	jne    c0026ad7 <signal+0x4d>
c0026ac2:	83 ec 0c             	sub    $0xc,%esp
c0026ac5:	ff 75 08             	pushl  0x8(%ebp)
c0026ac8:	e8 91 fc ff ff       	call   c002675e <intq_empty>
c0026acd:	83 c4 10             	add    $0x10,%esp
c0026ad0:	83 f0 01             	xor    $0x1,%eax
c0026ad3:	84 c0                	test   %al,%al
c0026ad5:	75 3e                	jne    c0026b15 <signal+0x8b>
c0026ad7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ada:	83 c0 18             	add    $0x18,%eax
c0026add:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026ae0:	75 15                	jne    c0026af7 <signal+0x6d>
c0026ae2:	83 ec 0c             	sub    $0xc,%esp
c0026ae5:	ff 75 08             	pushl  0x8(%ebp)
c0026ae8:	e8 b1 fc ff ff       	call   c002679e <intq_full>
c0026aed:	83 c4 10             	add    $0x10,%esp
c0026af0:	83 f0 01             	xor    $0x1,%eax
c0026af3:	84 c0                	test   %al,%al
c0026af5:	75 1e                	jne    c0026b15 <signal+0x8b>
c0026af7:	83 ec 0c             	sub    $0xc,%esp
c0026afa:	68 2c 17 03 c0       	push   $0xc003172c
c0026aff:	68 92 16 03 c0       	push   $0xc0031692
c0026b04:	68 c0 17 03 c0       	push   $0xc00317c0
c0026b09:	6a 6b                	push   $0x6b
c0026b0b:	68 a9 16 03 c0       	push   $0xc00316a9
c0026b10:	e8 59 2c 00 00       	call   c002976e <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026b15:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026b18:	8b 00                	mov    (%eax),%eax
c0026b1a:	85 c0                	test   %eax,%eax
c0026b1c:	74 1a                	je     c0026b38 <signal+0xae>
    {
      thread_unblock (*waiter);
c0026b1e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026b21:	8b 00                	mov    (%eax),%eax
c0026b23:	83 ec 0c             	sub    $0xc,%esp
c0026b26:	50                   	push   %eax
c0026b27:	e8 85 a2 ff ff       	call   c0020db1 <thread_unblock>
c0026b2c:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c0026b2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026b32:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0026b38:	90                   	nop
c0026b39:	c9                   	leave  
c0026b3a:	c3                   	ret    

c0026b3b <inb>:
{
c0026b3b:	55                   	push   %ebp
c0026b3c:	89 e5                	mov    %esp,%ebp
c0026b3e:	83 ec 14             	sub    $0x14,%esp
c0026b41:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b44:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b48:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026b4b:	89 c2                	mov    %eax,%edx
c0026b4d:	ec                   	in     (%dx),%al
c0026b4e:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026b51:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026b54:	c9                   	leave  
c0026b55:	c3                   	ret    

c0026b56 <outb>:
{
c0026b56:	55                   	push   %ebp
c0026b57:	89 e5                	mov    %esp,%ebp
c0026b59:	83 ec 08             	sub    $0x8,%esp
c0026b5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b5f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026b62:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026b66:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026b69:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026b6c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026b6f:	ee                   	out    %al,(%dx)
}
c0026b70:	90                   	nop
c0026b71:	c9                   	leave  
c0026b72:	c3                   	ret    

c0026b73 <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026b73:	55                   	push   %ebp
c0026b74:	89 e5                	mov    %esp,%ebp
c0026b76:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c0026b79:	83 ec 0c             	sub    $0xc,%esp
c0026b7c:	6a 00                	push   $0x0
c0026b7e:	e8 01 02 00 00       	call   c0026d84 <cmos_read>
c0026b83:	83 c4 10             	add    $0x10,%esp
c0026b86:	0f b6 c0             	movzbl %al,%eax
c0026b89:	83 ec 0c             	sub    $0xc,%esp
c0026b8c:	50                   	push   %eax
c0026b8d:	e8 c7 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026b92:	83 c4 10             	add    $0x10,%esp
c0026b95:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0026b98:	83 ec 0c             	sub    $0xc,%esp
c0026b9b:	6a 02                	push   $0x2
c0026b9d:	e8 e2 01 00 00       	call   c0026d84 <cmos_read>
c0026ba2:	83 c4 10             	add    $0x10,%esp
c0026ba5:	0f b6 c0             	movzbl %al,%eax
c0026ba8:	83 ec 0c             	sub    $0xc,%esp
c0026bab:	50                   	push   %eax
c0026bac:	e8 a8 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026bb1:	83 c4 10             	add    $0x10,%esp
c0026bb4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0026bb7:	83 ec 0c             	sub    $0xc,%esp
c0026bba:	6a 04                	push   $0x4
c0026bbc:	e8 c3 01 00 00       	call   c0026d84 <cmos_read>
c0026bc1:	83 c4 10             	add    $0x10,%esp
c0026bc4:	0f b6 c0             	movzbl %al,%eax
c0026bc7:	83 ec 0c             	sub    $0xc,%esp
c0026bca:	50                   	push   %eax
c0026bcb:	e8 89 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026bd0:	83 c4 10             	add    $0x10,%esp
c0026bd3:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c0026bd6:	83 ec 0c             	sub    $0xc,%esp
c0026bd9:	6a 07                	push   $0x7
c0026bdb:	e8 a4 01 00 00       	call   c0026d84 <cmos_read>
c0026be0:	83 c4 10             	add    $0x10,%esp
c0026be3:	0f b6 c0             	movzbl %al,%eax
c0026be6:	83 ec 0c             	sub    $0xc,%esp
c0026be9:	50                   	push   %eax
c0026bea:	e8 6a 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026bef:	83 c4 10             	add    $0x10,%esp
c0026bf2:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c0026bf5:	83 ec 0c             	sub    $0xc,%esp
c0026bf8:	6a 08                	push   $0x8
c0026bfa:	e8 85 01 00 00       	call   c0026d84 <cmos_read>
c0026bff:	83 c4 10             	add    $0x10,%esp
c0026c02:	0f b6 c0             	movzbl %al,%eax
c0026c05:	83 ec 0c             	sub    $0xc,%esp
c0026c08:	50                   	push   %eax
c0026c09:	e8 4b 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026c0e:	83 c4 10             	add    $0x10,%esp
c0026c11:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c0026c14:	83 ec 0c             	sub    $0xc,%esp
c0026c17:	6a 09                	push   $0x9
c0026c19:	e8 66 01 00 00       	call   c0026d84 <cmos_read>
c0026c1e:	83 c4 10             	add    $0x10,%esp
c0026c21:	0f b6 c0             	movzbl %al,%eax
c0026c24:	83 ec 0c             	sub    $0xc,%esp
c0026c27:	50                   	push   %eax
c0026c28:	e8 2c 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026c2d:	83 c4 10             	add    $0x10,%esp
c0026c30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c0026c33:	83 ec 0c             	sub    $0xc,%esp
c0026c36:	6a 00                	push   $0x0
c0026c38:	e8 47 01 00 00       	call   c0026d84 <cmos_read>
c0026c3d:	83 c4 10             	add    $0x10,%esp
c0026c40:	0f b6 c0             	movzbl %al,%eax
c0026c43:	83 ec 0c             	sub    $0xc,%esp
c0026c46:	50                   	push   %eax
c0026c47:	e8 0d 01 00 00       	call   c0026d59 <bcd_to_bin>
c0026c4c:	83 c4 10             	add    $0x10,%esp
c0026c4f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0026c52:	0f 85 21 ff ff ff    	jne    c0026b79 <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0026c58:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c0026c5c:	7f 04                	jg     c0026c62 <rtc_get_time+0xef>
    year += 100;
c0026c5e:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0026c62:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026c66:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026c69:	89 d0                	mov    %edx,%eax
c0026c6b:	c1 e0 03             	shl    $0x3,%eax
c0026c6e:	01 d0                	add    %edx,%eax
c0026c70:	c1 e0 03             	shl    $0x3,%eax
c0026c73:	01 d0                	add    %edx,%eax
c0026c75:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0026c7c:	01 c2                	add    %eax,%edx
c0026c7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026c81:	48                   	dec    %eax
c0026c82:	85 c0                	test   %eax,%eax
c0026c84:	79 03                	jns    c0026c89 <rtc_get_time+0x116>
c0026c86:	83 c0 03             	add    $0x3,%eax
c0026c89:	c1 f8 02             	sar    $0x2,%eax
c0026c8c:	01 c2                	add    %eax,%edx
c0026c8e:	89 d0                	mov    %edx,%eax
c0026c90:	c1 e0 02             	shl    $0x2,%eax
c0026c93:	01 d0                	add    %edx,%eax
c0026c95:	c1 e0 02             	shl    $0x2,%eax
c0026c98:	01 d0                	add    %edx,%eax
c0026c9a:	c1 e0 03             	shl    $0x3,%eax
c0026c9d:	01 d0                	add    %edx,%eax
c0026c9f:	c1 e0 02             	shl    $0x2,%eax
c0026ca2:	29 d0                	sub    %edx,%eax
c0026ca4:	c1 e0 07             	shl    $0x7,%eax
c0026ca7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026caa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0026cb1:	eb 2a                	jmp    c0026cdd <rtc_get_time+0x16a>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026cb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026cb6:	48                   	dec    %eax
c0026cb7:	8b 14 85 e0 17 03 c0 	mov    -0x3ffce820(,%eax,4),%edx
c0026cbe:	89 d0                	mov    %edx,%eax
c0026cc0:	c1 e0 02             	shl    $0x2,%eax
c0026cc3:	01 d0                	add    %edx,%eax
c0026cc5:	c1 e0 02             	shl    $0x2,%eax
c0026cc8:	01 d0                	add    %edx,%eax
c0026cca:	c1 e0 03             	shl    $0x3,%eax
c0026ccd:	01 d0                	add    %edx,%eax
c0026ccf:	c1 e0 02             	shl    $0x2,%eax
c0026cd2:	29 d0                	sub    %edx,%eax
c0026cd4:	c1 e0 07             	shl    $0x7,%eax
c0026cd7:	01 45 f0             	add    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026cda:	ff 45 ec             	incl   -0x14(%ebp)
c0026cdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026ce0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0026ce3:	7e ce                	jle    c0026cb3 <rtc_get_time+0x140>
  if (mon > 2 && year % 4 == 0)
c0026ce5:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0026ce9:	7e 11                	jle    c0026cfc <rtc_get_time+0x189>
c0026ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026cee:	83 e0 03             	and    $0x3,%eax
c0026cf1:	85 c0                	test   %eax,%eax
c0026cf3:	75 07                	jne    c0026cfc <rtc_get_time+0x189>
    time += 24 * 60 * 60;
c0026cf5:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c0026cfc:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0026cff:	8d 50 ff             	lea    -0x1(%eax),%edx
c0026d02:	89 d0                	mov    %edx,%eax
c0026d04:	c1 e0 02             	shl    $0x2,%eax
c0026d07:	01 d0                	add    %edx,%eax
c0026d09:	c1 e0 02             	shl    $0x2,%eax
c0026d0c:	01 d0                	add    %edx,%eax
c0026d0e:	c1 e0 03             	shl    $0x3,%eax
c0026d11:	01 d0                	add    %edx,%eax
c0026d13:	c1 e0 02             	shl    $0x2,%eax
c0026d16:	29 d0                	sub    %edx,%eax
c0026d18:	c1 e0 07             	shl    $0x7,%eax
c0026d1b:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c0026d1e:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0026d21:	89 d0                	mov    %edx,%eax
c0026d23:	01 c0                	add    %eax,%eax
c0026d25:	01 d0                	add    %edx,%eax
c0026d27:	01 c0                	add    %eax,%eax
c0026d29:	01 d0                	add    %edx,%eax
c0026d2b:	c1 e0 05             	shl    $0x5,%eax
c0026d2e:	01 d0                	add    %edx,%eax
c0026d30:	c1 e0 04             	shl    $0x4,%eax
c0026d33:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0026d36:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0026d39:	89 d0                	mov    %edx,%eax
c0026d3b:	01 c0                	add    %eax,%eax
c0026d3d:	01 d0                	add    %edx,%eax
c0026d3f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0026d46:	01 d0                	add    %edx,%eax
c0026d48:	c1 e0 02             	shl    $0x2,%eax
c0026d4b:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c0026d4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0026d51:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0026d54:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0026d57:	c9                   	leave  
c0026d58:	c3                   	ret    

c0026d59 <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0026d59:	55                   	push   %ebp
c0026d5a:	89 e5                	mov    %esp,%ebp
c0026d5c:	83 ec 04             	sub    $0x4,%esp
c0026d5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d62:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0026d65:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026d69:	83 e0 0f             	and    $0xf,%eax
c0026d6c:	89 c1                	mov    %eax,%ecx
c0026d6e:	8a 45 fc             	mov    -0x4(%ebp),%al
c0026d71:	c0 e8 04             	shr    $0x4,%al
c0026d74:	0f b6 d0             	movzbl %al,%edx
c0026d77:	89 d0                	mov    %edx,%eax
c0026d79:	c1 e0 02             	shl    $0x2,%eax
c0026d7c:	01 d0                	add    %edx,%eax
c0026d7e:	01 c0                	add    %eax,%eax
c0026d80:	01 c8                	add    %ecx,%eax
}
c0026d82:	c9                   	leave  
c0026d83:	c3                   	ret    

c0026d84 <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0026d84:	55                   	push   %ebp
c0026d85:	89 e5                	mov    %esp,%ebp
c0026d87:	83 ec 04             	sub    $0x4,%esp
c0026d8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d8d:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0026d90:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026d94:	50                   	push   %eax
c0026d95:	6a 70                	push   $0x70
c0026d97:	e8 ba fd ff ff       	call   c0026b56 <outb>
c0026d9c:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0026d9f:	6a 71                	push   $0x71
c0026da1:	e8 95 fd ff ff       	call   c0026b3b <inb>
c0026da6:	83 c4 04             	add    $0x4,%esp
}
c0026da9:	c9                   	leave  
c0026daa:	c3                   	ret    

c0026dab <inb>:
{
c0026dab:	55                   	push   %ebp
c0026dac:	89 e5                	mov    %esp,%ebp
c0026dae:	83 ec 14             	sub    $0x14,%esp
c0026db1:	8b 45 08             	mov    0x8(%ebp),%eax
c0026db4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026dbb:	89 c2                	mov    %eax,%edx
c0026dbd:	ec                   	in     (%dx),%al
c0026dbe:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026dc1:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026dc4:	c9                   	leave  
c0026dc5:	c3                   	ret    

c0026dc6 <outb>:
{
c0026dc6:	55                   	push   %ebp
c0026dc7:	89 e5                	mov    %esp,%ebp
c0026dc9:	83 ec 08             	sub    $0x8,%esp
c0026dcc:	8b 45 08             	mov    0x8(%ebp),%eax
c0026dcf:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026dd2:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026dd6:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026dd9:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026ddc:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026ddf:	ee                   	out    %al,(%dx)
}
c0026de0:	90                   	nop
c0026de1:	c9                   	leave  
c0026de2:	c3                   	ret    

c0026de3 <outw>:
{
c0026de3:	55                   	push   %ebp
c0026de4:	89 e5                	mov    %esp,%ebp
c0026de6:	83 ec 08             	sub    $0x8,%esp
c0026de9:	8b 55 08             	mov    0x8(%ebp),%edx
c0026dec:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026def:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026df3:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026df7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0026dfa:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026dfd:	66 ef                	out    %ax,(%dx)
}
c0026dff:	90                   	nop
c0026e00:	c9                   	leave  
c0026e01:	c3                   	ret    

c0026e02 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0026e02:	55                   	push   %ebp
c0026e03:	89 e5                	mov    %esp,%ebp
c0026e05:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0026e08:	a1 88 a2 03 c0       	mov    0xc003a288,%eax
c0026e0d:	83 f8 01             	cmp    $0x1,%eax
c0026e10:	74 07                	je     c0026e19 <shutdown+0x17>
c0026e12:	83 f8 02             	cmp    $0x2,%eax
c0026e15:	74 07                	je     c0026e1e <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0026e17:	eb 0a                	jmp    c0026e23 <shutdown+0x21>
      shutdown_power_off ();
c0026e19:	e8 9c 00 00 00       	call   c0026eba <shutdown_power_off>
      shutdown_reboot ();
c0026e1e:	e8 11 00 00 00       	call   c0026e34 <shutdown_reboot>
    }
}
c0026e23:	90                   	nop
c0026e24:	c9                   	leave  
c0026e25:	c3                   	ret    

c0026e26 <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0026e26:	55                   	push   %ebp
c0026e27:	89 e5                	mov    %esp,%ebp
  how = type;
c0026e29:	8b 45 08             	mov    0x8(%ebp),%eax
c0026e2c:	a3 88 a2 03 c0       	mov    %eax,0xc003a288
}
c0026e31:	90                   	nop
c0026e32:	5d                   	pop    %ebp
c0026e33:	c3                   	ret    

c0026e34 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026e34:	55                   	push   %ebp
c0026e35:	89 e5                	mov    %esp,%ebp
c0026e37:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0026e3a:	83 ec 0c             	sub    $0xc,%esp
c0026e3d:	68 10 18 03 c0       	push   $0xc0031810
c0026e42:	e8 f9 4b 00 00       	call   c002ba40 <puts>
c0026e47:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026e4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026e51:	eb 29                	jmp    c0026e7c <shutdown_reboot+0x48>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026e53:	83 ec 0c             	sub    $0xc,%esp
c0026e56:	6a 64                	push   $0x64
c0026e58:	e8 4e ff ff ff       	call   c0026dab <inb>
c0026e5d:	83 c4 10             	add    $0x10,%esp
c0026e60:	0f b6 c0             	movzbl %al,%eax
c0026e63:	83 e0 02             	and    $0x2,%eax
c0026e66:	85 c0                	test   %eax,%eax
c0026e68:	74 1d                	je     c0026e87 <shutdown_reboot+0x53>
            break;
          timer_udelay (2);
c0026e6a:	83 ec 08             	sub    $0x8,%esp
c0026e6d:	6a 00                	push   $0x0
c0026e6f:	6a 02                	push   $0x2
c0026e71:	e8 cc d1 ff ff       	call   c0024042 <timer_udelay>
c0026e76:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 0x10000; i++)
c0026e79:	ff 45 f4             	incl   -0xc(%ebp)
c0026e7c:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0026e83:	7e ce                	jle    c0026e53 <shutdown_reboot+0x1f>
c0026e85:	eb 01                	jmp    c0026e88 <shutdown_reboot+0x54>
            break;
c0026e87:	90                   	nop
        }

      timer_udelay (50);
c0026e88:	83 ec 08             	sub    $0x8,%esp
c0026e8b:	6a 00                	push   $0x0
c0026e8d:	6a 32                	push   $0x32
c0026e8f:	e8 ae d1 ff ff       	call   c0024042 <timer_udelay>
c0026e94:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c0026e97:	83 ec 08             	sub    $0x8,%esp
c0026e9a:	68 fe 00 00 00       	push   $0xfe
c0026e9f:	6a 64                	push   $0x64
c0026ea1:	e8 20 ff ff ff       	call   c0026dc6 <outb>
c0026ea6:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c0026ea9:	83 ec 08             	sub    $0x8,%esp
c0026eac:	6a 00                	push   $0x0
c0026eae:	6a 32                	push   $0x32
c0026eb0:	e8 8d d1 ff ff       	call   c0024042 <timer_udelay>
c0026eb5:	83 c4 10             	add    $0x10,%esp
    {
c0026eb8:	eb 90                	jmp    c0026e4a <shutdown_reboot+0x16>

c0026eba <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026eba:	55                   	push   %ebp
c0026ebb:	89 e5                	mov    %esp,%ebp
c0026ebd:	57                   	push   %edi
c0026ebe:	56                   	push   %esi
c0026ebf:	53                   	push   %ebx
c0026ec0:	83 ec 1c             	sub    $0x1c,%esp
  const char s[] = "Shutdown";
c0026ec3:	8d 45 db             	lea    -0x25(%ebp),%eax
c0026ec6:	bb 3e 18 03 c0       	mov    $0xc003183e,%ebx
c0026ecb:	ba 09 00 00 00       	mov    $0x9,%edx
c0026ed0:	89 c7                	mov    %eax,%edi
c0026ed2:	89 de                	mov    %ebx,%esi
c0026ed4:	89 d1                	mov    %edx,%ecx
c0026ed6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  const char *p;

#ifdef FILESYS
  filesys_done ();
c0026ed8:	e8 d1 6b 00 00       	call   c002daae <filesys_done>
#endif

  print_stats ();
c0026edd:	e8 7d 00 00 00       	call   c0026f5f <print_stats>

  printf ("Powering off...\n");
c0026ee2:	83 ec 0c             	sub    $0xc,%esp
c0026ee5:	68 1d 18 03 c0       	push   $0xc003181d
c0026eea:	e8 51 4b 00 00       	call   c002ba40 <puts>
c0026eef:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0026ef2:	e8 74 dd ff ff       	call   c0024c6b <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c0026ef7:	83 ec 08             	sub    $0x8,%esp
c0026efa:	68 00 20 00 00       	push   $0x2000
c0026eff:	68 04 b0 00 00       	push   $0xb004
c0026f04:	e8 da fe ff ff       	call   c0026de3 <outw>
c0026f09:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026f0c:	8d 45 db             	lea    -0x25(%ebp),%eax
c0026f0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0026f12:	eb 1c                	jmp    c0026f30 <shutdown_power_off+0x76>
    outb (0x8900, *p);
c0026f14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026f17:	8a 00                	mov    (%eax),%al
c0026f19:	0f b6 c0             	movzbl %al,%eax
c0026f1c:	83 ec 08             	sub    $0x8,%esp
c0026f1f:	50                   	push   %eax
c0026f20:	68 00 89 00 00       	push   $0x8900
c0026f25:	e8 9c fe ff ff       	call   c0026dc6 <outb>
c0026f2a:	83 c4 10             	add    $0x10,%esp
  for (p = s; *p != '\0'; p++)
c0026f2d:	ff 45 e4             	incl   -0x1c(%ebp)
c0026f30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026f33:	8a 00                	mov    (%eax),%al
c0026f35:	84 c0                	test   %al,%al
c0026f37:	75 db                	jne    c0026f14 <shutdown_power_off+0x5a>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0026f39:	83 ec 08             	sub    $0x8,%esp
c0026f3c:	6a 31                	push   $0x31
c0026f3e:	68 01 05 00 00       	push   $0x501
c0026f43:	e8 7e fe ff ff       	call   c0026dc6 <outb>
c0026f48:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0026f4b:	fa                   	cli    
c0026f4c:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0026f4d:	83 ec 0c             	sub    $0xc,%esp
c0026f50:	68 2d 18 03 c0       	push   $0xc003182d
c0026f55:	e8 e6 4a 00 00       	call   c002ba40 <puts>
c0026f5a:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0026f5d:	eb fe                	jmp    c0026f5d <shutdown_power_off+0xa3>

c0026f5f <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c0026f5f:	55                   	push   %ebp
c0026f60:	89 e5                	mov    %esp,%ebp
c0026f62:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0026f65:	e8 2e d1 ff ff       	call   c0024098 <timer_print_stats>
  thread_print_stats ();
c0026f6a:	e8 8d 9c ff ff       	call   c0020bfc <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
c0026f6f:	e8 64 e2 ff ff       	call   c00251d8 <block_print_stats>
#endif
  console_print_stats ();
c0026f74:	e8 9b 49 00 00       	call   c002b914 <console_print_stats>
  kbd_print_stats ();
c0026f79:	e8 28 d4 ff ff       	call   c00243a6 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
c0026f7e:	e8 6e 5f 00 00       	call   c002cef1 <exception_print_stats>
#endif
}
c0026f83:	90                   	nop
c0026f84:	c9                   	leave  
c0026f85:	c3                   	ret    

c0026f86 <inb>:
{
c0026f86:	55                   	push   %ebp
c0026f87:	89 e5                	mov    %esp,%ebp
c0026f89:	83 ec 14             	sub    $0x14,%esp
c0026f8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f8f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026f93:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026f96:	89 c2                	mov    %eax,%edx
c0026f98:	ec                   	in     (%dx),%al
c0026f99:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026f9c:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026f9f:	c9                   	leave  
c0026fa0:	c3                   	ret    

c0026fa1 <outb>:
{
c0026fa1:	55                   	push   %ebp
c0026fa2:	89 e5                	mov    %esp,%ebp
c0026fa4:	83 ec 08             	sub    $0x8,%esp
c0026fa7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026faa:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026fad:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026fb1:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026fb4:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026fb7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026fba:	ee                   	out    %al,(%dx)
}
c0026fbb:	90                   	nop
c0026fbc:	c9                   	leave  
c0026fbd:	c3                   	ret    

c0026fbe <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0026fbe:	55                   	push   %ebp
c0026fbf:	89 e5                	mov    %esp,%ebp
c0026fc1:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c0026fc4:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c0026fc8:	7e 54                	jle    c002701e <speaker_on+0x60>
c0026fca:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0026fd1:	7f 4b                	jg     c002701e <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0026fd3:	e8 eb a5 ff ff       	call   c00215c3 <intr_disable>
c0026fd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c0026fdb:	83 ec 04             	sub    $0x4,%esp
c0026fde:	ff 75 08             	pushl  0x8(%ebp)
c0026fe1:	6a 03                	push   $0x3
c0026fe3:	6a 02                	push   $0x2
c0026fe5:	e8 9b cc ff ff       	call   c0023c85 <pit_configure_channel>
c0026fea:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026fed:	83 ec 0c             	sub    $0xc,%esp
c0026ff0:	6a 61                	push   $0x61
c0026ff2:	e8 8f ff ff ff       	call   c0026f86 <inb>
c0026ff7:	83 c4 10             	add    $0x10,%esp
c0026ffa:	83 c8 03             	or     $0x3,%eax
c0026ffd:	0f b6 c0             	movzbl %al,%eax
c0027000:	83 ec 08             	sub    $0x8,%esp
c0027003:	50                   	push   %eax
c0027004:	6a 61                	push   $0x61
c0027006:	e8 96 ff ff ff       	call   c0026fa1 <outb>
c002700b:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c002700e:	83 ec 0c             	sub    $0xc,%esp
c0027011:	ff 75 f4             	pushl  -0xc(%ebp)
c0027014:	e8 52 a5 ff ff       	call   c002156b <intr_set_level>
c0027019:	83 c4 10             	add    $0x10,%esp
    {
c002701c:	eb 05                	jmp    c0027023 <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c002701e:	e8 03 00 00 00       	call   c0027026 <speaker_off>
    }
}
c0027023:	90                   	nop
c0027024:	c9                   	leave  
c0027025:	c3                   	ret    

c0027026 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0027026:	55                   	push   %ebp
c0027027:	89 e5                	mov    %esp,%ebp
c0027029:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c002702c:	e8 92 a5 ff ff       	call   c00215c3 <intr_disable>
c0027031:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0027034:	83 ec 0c             	sub    $0xc,%esp
c0027037:	6a 61                	push   $0x61
c0027039:	e8 48 ff ff ff       	call   c0026f86 <inb>
c002703e:	83 c4 10             	add    $0x10,%esp
c0027041:	0f b6 c0             	movzbl %al,%eax
c0027044:	25 fc 00 00 00       	and    $0xfc,%eax
c0027049:	83 ec 08             	sub    $0x8,%esp
c002704c:	50                   	push   %eax
c002704d:	6a 61                	push   $0x61
c002704f:	e8 4d ff ff ff       	call   c0026fa1 <outb>
c0027054:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0027057:	83 ec 0c             	sub    $0xc,%esp
c002705a:	ff 75 f4             	pushl  -0xc(%ebp)
c002705d:	e8 09 a5 ff ff       	call   c002156b <intr_set_level>
c0027062:	83 c4 10             	add    $0x10,%esp
}
c0027065:	90                   	nop
c0027066:	c9                   	leave  
c0027067:	c3                   	ret    

c0027068 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0027068:	55                   	push   %ebp
c0027069:	89 e5                	mov    %esp,%ebp
c002706b:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c002706e:	e8 db a4 ff ff       	call   c002154e <intr_get_level>
c0027073:	83 f8 01             	cmp    $0x1,%eax
c0027076:	75 27                	jne    c002709f <speaker_beep+0x37>
    {
      speaker_on (440);
c0027078:	83 ec 0c             	sub    $0xc,%esp
c002707b:	68 b8 01 00 00       	push   $0x1b8
c0027080:	e8 39 ff ff ff       	call   c0026fbe <speaker_on>
c0027085:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0027088:	83 ec 08             	sub    $0x8,%esp
c002708b:	6a 00                	push   $0x0
c002708d:	68 fa 00 00 00       	push   $0xfa
c0027092:	e8 ff ce ff ff       	call   c0023f96 <timer_msleep>
c0027097:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c002709a:	e8 87 ff ff ff       	call   c0027026 <speaker_off>
    }
}
c002709f:	90                   	nop
c00270a0:	c9                   	leave  
c00270a1:	c3                   	ret    

c00270a2 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c00270a2:	55                   	push   %ebp
c00270a3:	89 e5                	mov    %esp,%ebp
c00270a5:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c00270a8:	8b 45 04             	mov    0x4(%ebp),%eax
c00270ab:	83 ec 08             	sub    $0x8,%esp
c00270ae:	50                   	push   %eax
c00270af:	68 48 18 03 c0       	push   $0xc0031848
c00270b4:	e8 f6 02 00 00       	call   c00273af <printf>
c00270b9:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c00270bc:	8b 45 00             	mov    0x0(%ebp),%eax
c00270bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00270c2:	eb 21                	jmp    c00270e5 <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c00270c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270c7:	83 c0 04             	add    $0x4,%eax
c00270ca:	8b 00                	mov    (%eax),%eax
c00270cc:	83 ec 08             	sub    $0x8,%esp
c00270cf:	50                   	push   %eax
c00270d0:	68 57 18 03 c0       	push   $0xc0031857
c00270d5:	e8 d5 02 00 00       	call   c00273af <printf>
c00270da:	83 c4 10             	add    $0x10,%esp
       frame = frame[0]) 
c00270dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270e0:	8b 00                	mov    (%eax),%eax
c00270e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c00270e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  for (frame = __builtin_frame_address (1);
c00270e8:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c00270ed:	76 09                	jbe    c00270f8 <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c00270ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270f2:	8b 00                	mov    (%eax),%eax
c00270f4:	85 c0                	test   %eax,%eax
c00270f6:	75 cc                	jne    c00270c4 <debug_backtrace+0x22>
  printf (".\n");
c00270f8:	83 ec 0c             	sub    $0xc,%esp
c00270fb:	68 5b 18 03 c0       	push   $0xc003185b
c0027100:	e8 3b 49 00 00       	call   c002ba40 <puts>
c0027105:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0027108:	a0 8c a2 03 c0       	mov    0xc003a28c,%al
c002710d:	83 f0 01             	xor    $0x1,%eax
c0027110:	84 c0                	test   %al,%al
c0027112:	74 17                	je     c002712b <debug_backtrace+0x89>
    {
      explained = true;
c0027114:	c6 05 8c a2 03 c0 01 	movb   $0x1,0xc003a28c
      printf ("The `backtrace' program can make call stacks useful.\n"
c002711b:	83 ec 0c             	sub    $0xc,%esp
c002711e:	68 60 18 03 c0       	push   $0xc0031860
c0027123:	e8 18 49 00 00       	call   c002ba40 <puts>
c0027128:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c002712b:	90                   	nop
c002712c:	c9                   	leave  
c002712d:	c3                   	ret    

c002712e <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c002712e:	55                   	push   %ebp
c002712f:	89 e5                	mov    %esp,%ebp
c0027131:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c0027134:	8b 45 08             	mov    0x8(%ebp),%eax
c0027137:	8a 00                	mov    (%eax),%al
c0027139:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c002713c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002713f:	8a 10                	mov    (%eax),%dl
c0027141:	8b 45 08             	mov    0x8(%ebp),%eax
c0027144:	88 10                	mov    %dl,(%eax)
  *b = t;
c0027146:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027149:	8a 55 ff             	mov    -0x1(%ebp),%dl
c002714c:	88 10                	mov    %dl,(%eax)
}
c002714e:	90                   	nop
c002714f:	c9                   	leave  
c0027150:	c3                   	ret    

c0027151 <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0027151:	55                   	push   %ebp
c0027152:	89 e5                	mov    %esp,%ebp
c0027154:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c0027157:	8d 45 08             	lea    0x8(%ebp),%eax
c002715a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c002715d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0027164:	eb 12                	jmp    c0027178 <random_init+0x27>
    s[i] = i;
c0027166:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027169:	88 c2                	mov    %al,%dl
c002716b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002716e:	05 a0 a2 03 c0       	add    $0xc003a2a0,%eax
c0027173:	88 10                	mov    %dl,(%eax)
  for (i = 0; i < 256; i++) 
c0027175:	ff 45 fc             	incl   -0x4(%ebp)
c0027178:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c002717f:	7e e5                	jle    c0027166 <random_init+0x15>
  for (i = j = 0; i < 256; i++) 
c0027181:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c0027185:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002718c:	eb 3d                	jmp    c00271cb <random_init+0x7a>
    {
      j += s[i] + seedp[i % sizeof seed];
c002718e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027191:	05 a0 a2 03 c0       	add    $0xc003a2a0,%eax
c0027196:	8a 10                	mov    (%eax),%dl
c0027198:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002719b:	83 e0 03             	and    $0x3,%eax
c002719e:	89 c1                	mov    %eax,%ecx
c00271a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00271a3:	01 c8                	add    %ecx,%eax
c00271a5:	8a 00                	mov    (%eax),%al
c00271a7:	01 d0                	add    %edx,%eax
c00271a9:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c00271ac:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c00271b0:	8d 90 a0 a2 03 c0    	lea    -0x3ffc5d60(%eax),%edx
c00271b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00271b9:	05 a0 a2 03 c0       	add    $0xc003a2a0,%eax
c00271be:	52                   	push   %edx
c00271bf:	50                   	push   %eax
c00271c0:	e8 69 ff ff ff       	call   c002712e <swap_byte>
c00271c5:	83 c4 08             	add    $0x8,%esp
  for (i = j = 0; i < 256; i++) 
c00271c8:	ff 45 fc             	incl   -0x4(%ebp)
c00271cb:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c00271d2:	7e ba                	jle    c002718e <random_init+0x3d>
    }

  s_i = s_j = 0;
c00271d4:	c6 05 a1 a3 03 c0 00 	movb   $0x0,0xc003a3a1
c00271db:	a0 a1 a3 03 c0       	mov    0xc003a3a1,%al
c00271e0:	a2 a0 a3 03 c0       	mov    %al,0xc003a3a0
  inited = true;
c00271e5:	c6 05 a2 a3 03 c0 01 	movb   $0x1,0xc003a3a2
}
c00271ec:	90                   	nop
c00271ed:	c9                   	leave  
c00271ee:	c3                   	ret    

c00271ef <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c00271ef:	55                   	push   %ebp
c00271f0:	89 e5                	mov    %esp,%ebp
c00271f2:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c00271f5:	a0 a2 a3 03 c0       	mov    0xc003a3a2,%al
c00271fa:	83 f0 01             	xor    $0x1,%eax
c00271fd:	84 c0                	test   %al,%al
c00271ff:	74 0a                	je     c002720b <random_bytes+0x1c>
    random_init (0);
c0027201:	6a 00                	push   $0x0
c0027203:	e8 49 ff ff ff       	call   c0027151 <random_init>
c0027208:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c002720b:	8b 45 08             	mov    0x8(%ebp),%eax
c002720e:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0027211:	eb 7d                	jmp    c0027290 <random_bytes+0xa1>
    {
      uint8_t s_k;
      
      s_i++;
c0027213:	a0 a0 a3 03 c0       	mov    0xc003a3a0,%al
c0027218:	40                   	inc    %eax
c0027219:	a2 a0 a3 03 c0       	mov    %al,0xc003a3a0
      s_j += s[s_i];
c002721e:	a0 a0 a3 03 c0       	mov    0xc003a3a0,%al
c0027223:	0f b6 c0             	movzbl %al,%eax
c0027226:	8a 90 a0 a2 03 c0    	mov    -0x3ffc5d60(%eax),%dl
c002722c:	a0 a1 a3 03 c0       	mov    0xc003a3a1,%al
c0027231:	01 d0                	add    %edx,%eax
c0027233:	a2 a1 a3 03 c0       	mov    %al,0xc003a3a1
      swap_byte (s + s_i, s + s_j);
c0027238:	a0 a1 a3 03 c0       	mov    0xc003a3a1,%al
c002723d:	0f b6 c0             	movzbl %al,%eax
c0027240:	8d 90 a0 a2 03 c0    	lea    -0x3ffc5d60(%eax),%edx
c0027246:	a0 a0 a3 03 c0       	mov    0xc003a3a0,%al
c002724b:	0f b6 c0             	movzbl %al,%eax
c002724e:	05 a0 a2 03 c0       	add    $0xc003a2a0,%eax
c0027253:	52                   	push   %edx
c0027254:	50                   	push   %eax
c0027255:	e8 d4 fe ff ff       	call   c002712e <swap_byte>
c002725a:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c002725d:	a0 a0 a3 03 c0       	mov    0xc003a3a0,%al
c0027262:	0f b6 c0             	movzbl %al,%eax
c0027265:	8a 90 a0 a2 03 c0    	mov    -0x3ffc5d60(%eax),%dl
c002726b:	a0 a1 a3 03 c0       	mov    0xc003a3a1,%al
c0027270:	0f b6 c0             	movzbl %al,%eax
c0027273:	8a 80 a0 a2 03 c0    	mov    -0x3ffc5d60(%eax),%al
c0027279:	01 d0                	add    %edx,%eax
c002727b:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c002727e:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0027282:	8a 90 a0 a2 03 c0    	mov    -0x3ffc5d60(%eax),%dl
c0027288:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002728b:	88 10                	mov    %dl,(%eax)
  for (buf = buf_; size-- > 0; buf++)
c002728d:	ff 45 fc             	incl   -0x4(%ebp)
c0027290:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027293:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027296:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027299:	85 c0                	test   %eax,%eax
c002729b:	0f 85 72 ff ff ff    	jne    c0027213 <random_bytes+0x24>
    }
}
c00272a1:	90                   	nop
c00272a2:	c9                   	leave  
c00272a3:	c3                   	ret    

c00272a4 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c00272a4:	55                   	push   %ebp
c00272a5:	89 e5                	mov    %esp,%ebp
c00272a7:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c00272aa:	6a 04                	push   $0x4
c00272ac:	8d 45 fc             	lea    -0x4(%ebp),%eax
c00272af:	50                   	push   %eax
c00272b0:	e8 3a ff ff ff       	call   c00271ef <random_bytes>
c00272b5:	83 c4 08             	add    $0x8,%esp
  return ul;
c00272b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00272bb:	c9                   	leave  
c00272bc:	c3                   	ret    

c00272bd <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00272bd:	55                   	push   %ebp
c00272be:	89 e5                	mov    %esp,%ebp
c00272c0:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c00272c4:	7e 0d                	jle    c00272d3 <isdigit+0x16>
c00272c6:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c00272ca:	7f 07                	jg     c00272d3 <isdigit+0x16>
c00272cc:	b8 01 00 00 00       	mov    $0x1,%eax
c00272d1:	eb 05                	jmp    c00272d8 <isdigit+0x1b>
c00272d3:	b8 00 00 00 00       	mov    $0x0,%eax
c00272d8:	5d                   	pop    %ebp
c00272d9:	c3                   	ret    

c00272da <isprint>:
static inline int isprint (int c) { return c >= 32 && c < 127; }
c00272da:	55                   	push   %ebp
c00272db:	89 e5                	mov    %esp,%ebp
c00272dd:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c00272e1:	7e 0d                	jle    c00272f0 <isprint+0x16>
c00272e3:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c00272e7:	7f 07                	jg     c00272f0 <isprint+0x16>
c00272e9:	b8 01 00 00 00       	mov    $0x1,%eax
c00272ee:	eb 05                	jmp    c00272f5 <isprint+0x1b>
c00272f0:	b8 00 00 00 00       	mov    $0x0,%eax
c00272f5:	5d                   	pop    %ebp
c00272f6:	c3                   	ret    

c00272f7 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c00272f7:	55                   	push   %ebp
c00272f8:	89 e5                	mov    %esp,%ebp
c00272fa:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c00272fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0027300:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c0027303:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c002730a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002730e:	74 06                	je     c0027316 <vsnprintf+0x1f>
c0027310:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027313:	48                   	dec    %eax
c0027314:	eb 05                	jmp    c002731b <vsnprintf+0x24>
c0027316:	b8 00 00 00 00       	mov    $0x0,%eax
c002731b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c002731e:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0027321:	50                   	push   %eax
c0027322:	68 46 73 02 c0       	push   $0xc0027346
c0027327:	ff 75 14             	pushl  0x14(%ebp)
c002732a:	ff 75 10             	pushl  0x10(%ebp)
c002732d:	e8 a3 00 00 00       	call   c00273d5 <__vprintf>
c0027332:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c0027335:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027339:	74 06                	je     c0027341 <vsnprintf+0x4a>
    *aux.p = '\0';
c002733b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002733e:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c0027341:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0027344:	c9                   	leave  
c0027345:	c3                   	ret    

c0027346 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027346:	55                   	push   %ebp
c0027347:	89 e5                	mov    %esp,%ebp
c0027349:	83 ec 14             	sub    $0x14,%esp
c002734c:	8b 45 08             	mov    0x8(%ebp),%eax
c002734f:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c0027352:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027355:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0027358:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002735b:	8b 40 04             	mov    0x4(%eax),%eax
c002735e:	8d 48 01             	lea    0x1(%eax),%ecx
c0027361:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027364:	89 4a 04             	mov    %ecx,0x4(%edx)
c0027367:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002736a:	8b 52 08             	mov    0x8(%edx),%edx
c002736d:	39 d0                	cmp    %edx,%eax
c002736f:	7d 12                	jge    c0027383 <vsnprintf_helper+0x3d>
    *aux->p++ = ch;
c0027371:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027374:	8b 00                	mov    (%eax),%eax
c0027376:	8d 48 01             	lea    0x1(%eax),%ecx
c0027379:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002737c:	89 0a                	mov    %ecx,(%edx)
c002737e:	8a 55 ec             	mov    -0x14(%ebp),%dl
c0027381:	88 10                	mov    %dl,(%eax)
}
c0027383:	90                   	nop
c0027384:	c9                   	leave  
c0027385:	c3                   	ret    

c0027386 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c0027386:	55                   	push   %ebp
c0027387:	89 e5                	mov    %esp,%ebp
c0027389:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c002738c:	8d 45 14             	lea    0x14(%ebp),%eax
c002738f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c0027392:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027395:	50                   	push   %eax
c0027396:	ff 75 10             	pushl  0x10(%ebp)
c0027399:	ff 75 0c             	pushl  0xc(%ebp)
c002739c:	ff 75 08             	pushl  0x8(%ebp)
c002739f:	e8 53 ff ff ff       	call   c00272f7 <vsnprintf>
c00273a4:	83 c4 10             	add    $0x10,%esp
c00273a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c00273aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00273ad:	c9                   	leave  
c00273ae:	c3                   	ret    

c00273af <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c00273af:	55                   	push   %ebp
c00273b0:	89 e5                	mov    %esp,%ebp
c00273b2:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c00273b5:	8d 45 0c             	lea    0xc(%ebp),%eax
c00273b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c00273bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00273be:	83 ec 08             	sub    $0x8,%esp
c00273c1:	50                   	push   %eax
c00273c2:	ff 75 08             	pushl  0x8(%ebp)
c00273c5:	e8 43 46 00 00       	call   c002ba0d <vprintf>
c00273ca:	83 c4 10             	add    $0x10,%esp
c00273cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c00273d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00273d3:	c9                   	leave  
c00273d4:	c3                   	ret    

c00273d5 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c00273d5:	55                   	push   %ebp
c00273d6:	89 e5                	mov    %esp,%ebp
c00273d8:	53                   	push   %ebx
c00273d9:	83 ec 34             	sub    $0x34,%esp
  for (; *format != '\0'; format++)
c00273dc:	e9 25 04 00 00       	jmp    c0027806 <__vprintf+0x431>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c00273e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00273e4:	8a 00                	mov    (%eax),%al
c00273e6:	3c 25                	cmp    $0x25,%al
c00273e8:	74 1c                	je     c0027406 <__vprintf+0x31>
        {
          output (*format, aux);
c00273ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00273ed:	8a 00                	mov    (%eax),%al
c00273ef:	0f be c0             	movsbl %al,%eax
c00273f2:	83 ec 08             	sub    $0x8,%esp
c00273f5:	ff 75 14             	pushl  0x14(%ebp)
c00273f8:	50                   	push   %eax
c00273f9:	8b 45 10             	mov    0x10(%ebp),%eax
c00273fc:	ff d0                	call   *%eax
c00273fe:	83 c4 10             	add    $0x10,%esp
          continue;
c0027401:	e9 fd 03 00 00       	jmp    c0027803 <__vprintf+0x42e>
        }
      format++;
c0027406:	ff 45 08             	incl   0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c0027409:	8b 45 08             	mov    0x8(%ebp),%eax
c002740c:	8a 00                	mov    (%eax),%al
c002740e:	3c 25                	cmp    $0x25,%al
c0027410:	75 15                	jne    c0027427 <__vprintf+0x52>
        {
          output ('%', aux);
c0027412:	83 ec 08             	sub    $0x8,%esp
c0027415:	ff 75 14             	pushl  0x14(%ebp)
c0027418:	6a 25                	push   $0x25
c002741a:	8b 45 10             	mov    0x10(%ebp),%eax
c002741d:	ff d0                	call   *%eax
c002741f:	83 c4 10             	add    $0x10,%esp
          continue;
c0027422:	e9 dc 03 00 00       	jmp    c0027803 <__vprintf+0x42e>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c0027427:	83 ec 04             	sub    $0x4,%esp
c002742a:	8d 45 0c             	lea    0xc(%ebp),%eax
c002742d:	50                   	push   %eax
c002742e:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027431:	50                   	push   %eax
c0027432:	ff 75 08             	pushl  0x8(%ebp)
c0027435:	e8 df 03 00 00       	call   c0027819 <parse_conversion>
c002743a:	83 c4 10             	add    $0x10,%esp
c002743d:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c0027440:	8b 45 08             	mov    0x8(%ebp),%eax
c0027443:	8a 00                	mov    (%eax),%al
c0027445:	0f be c0             	movsbl %al,%eax
c0027448:	83 e8 45             	sub    $0x45,%eax
c002744b:	83 f8 33             	cmp    $0x33,%eax
c002744e:	0f 87 92 03 00 00    	ja     c00277e6 <__vprintf+0x411>
c0027454:	8b 04 85 e4 19 03 c0 	mov    -0x3ffce61c(,%eax,4),%eax
c002745b:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c002745d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027460:	83 f8 08             	cmp    $0x8,%eax
c0027463:	0f 87 d8 00 00 00    	ja     c0027541 <__vprintf+0x16c>
c0027469:	8b 04 85 b4 1a 03 c0 	mov    -0x3ffce54c(,%eax,4),%eax
c0027470:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c0027472:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027475:	8d 50 04             	lea    0x4(%eax),%edx
c0027478:	89 55 0c             	mov    %edx,0xc(%ebp)
c002747b:	8b 00                	mov    (%eax),%eax
c002747d:	0f be c0             	movsbl %al,%eax
c0027480:	99                   	cltd   
c0027481:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027484:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027487:	e9 cf 00 00 00       	jmp    c002755b <__vprintf+0x186>
              case SHORT:
                value = (short) va_arg (args, int);
c002748c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002748f:	8d 50 04             	lea    0x4(%eax),%edx
c0027492:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027495:	8b 00                	mov    (%eax),%eax
c0027497:	98                   	cwtl   
c0027498:	99                   	cltd   
c0027499:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002749c:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c002749f:	e9 b7 00 00 00       	jmp    c002755b <__vprintf+0x186>
              case INT:
                value = va_arg (args, int);
c00274a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274a7:	8d 50 04             	lea    0x4(%eax),%edx
c00274aa:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274ad:	8b 00                	mov    (%eax),%eax
c00274af:	99                   	cltd   
c00274b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00274b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00274b6:	e9 a0 00 00 00       	jmp    c002755b <__vprintf+0x186>
              case INTMAX:
                value = va_arg (args, intmax_t);
c00274bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274be:	8d 50 08             	lea    0x8(%eax),%edx
c00274c1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274c4:	8b 50 04             	mov    0x4(%eax),%edx
c00274c7:	8b 00                	mov    (%eax),%eax
c00274c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00274cc:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00274cf:	e9 87 00 00 00       	jmp    c002755b <__vprintf+0x186>
              case LONG:
                value = va_arg (args, long);
c00274d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274d7:	8d 50 04             	lea    0x4(%eax),%edx
c00274da:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274dd:	8b 00                	mov    (%eax),%eax
c00274df:	99                   	cltd   
c00274e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00274e3:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00274e6:	eb 73                	jmp    c002755b <__vprintf+0x186>
              case LONGLONG:
                value = va_arg (args, long long);
c00274e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274eb:	8d 50 08             	lea    0x8(%eax),%edx
c00274ee:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274f1:	8b 50 04             	mov    0x4(%eax),%edx
c00274f4:	8b 00                	mov    (%eax),%eax
c00274f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00274f9:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00274fc:	eb 5d                	jmp    c002755b <__vprintf+0x186>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00274fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027501:	8d 50 04             	lea    0x4(%eax),%edx
c0027504:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027507:	8b 00                	mov    (%eax),%eax
c0027509:	99                   	cltd   
c002750a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002750d:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027510:	eb 49                	jmp    c002755b <__vprintf+0x186>
              case SIZET:
                value = va_arg (args, size_t);
c0027512:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027515:	8d 50 04             	lea    0x4(%eax),%edx
c0027518:	89 55 0c             	mov    %edx,0xc(%ebp)
c002751b:	8b 00                	mov    (%eax),%eax
c002751d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027520:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                if (value > SIZE_MAX / 2)
c0027527:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002752b:	78 2d                	js     c002755a <__vprintf+0x185>
c002752d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0027531:	7f 09                	jg     c002753c <__vprintf+0x167>
c0027533:	81 7d f0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x10(%ebp)
c002753a:	76 1e                	jbe    c002755a <__vprintf+0x185>
                  value = value - SIZE_MAX - 1;
c002753c:	ff 4d f4             	decl   -0xc(%ebp)
                break;
c002753f:	eb 19                	jmp    c002755a <__vprintf+0x185>
              default:
                NOT_REACHED ();
c0027541:	68 7c 19 03 c0       	push   $0xc003197c
c0027546:	68 b0 1b 03 c0       	push   $0xc0031bb0
c002754b:	68 dc 00 00 00       	push   $0xdc
c0027550:	68 9e 19 03 c0       	push   $0xc003199e
c0027555:	e8 14 22 00 00       	call   c002976e <debug_panic>
                break;
c002755a:	90                   	nop
              }

            format_integer (value < 0 ? -value : value,
c002755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002755e:	c1 e8 1f             	shr    $0x1f,%eax
c0027561:	0f b6 c8             	movzbl %al,%ecx
c0027564:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027567:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002756a:	85 d2                	test   %edx,%edx
c002756c:	79 07                	jns    c0027575 <__vprintf+0x1a0>
c002756e:	f7 d8                	neg    %eax
c0027570:	83 d2 00             	adc    $0x0,%edx
c0027573:	f7 da                	neg    %edx
c0027575:	ff 75 14             	pushl  0x14(%ebp)
c0027578:	ff 75 10             	pushl  0x10(%ebp)
c002757b:	8d 5d cc             	lea    -0x34(%ebp),%ebx
c002757e:	53                   	push   %ebx
c002757f:	68 08 19 03 c0       	push   $0xc0031908
c0027584:	51                   	push   %ecx
c0027585:	6a 01                	push   $0x1
c0027587:	52                   	push   %edx
c0027588:	50                   	push   %eax
c0027589:	e8 3f 05 00 00       	call   c0027acd <format_integer>
c002758e:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c0027591:	e9 6d 02 00 00       	jmp    c0027803 <__vprintf+0x42e>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c0027596:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027599:	83 f8 08             	cmp    $0x8,%eax
c002759c:	0f 87 d3 00 00 00    	ja     c0027675 <__vprintf+0x2a0>
c00275a2:	8b 04 85 d8 1a 03 c0 	mov    -0x3ffce528(,%eax,4),%eax
c00275a9:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c00275ab:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275ae:	8d 50 04             	lea    0x4(%eax),%edx
c00275b1:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275b4:	8b 00                	mov    (%eax),%eax
c00275b6:	0f b6 c0             	movzbl %al,%eax
c00275b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00275bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00275c3:	e9 c6 00 00 00       	jmp    c002768e <__vprintf+0x2b9>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c00275c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275cb:	8d 50 04             	lea    0x4(%eax),%edx
c00275ce:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275d1:	8b 00                	mov    (%eax),%eax
c00275d3:	0f b7 c0             	movzwl %ax,%eax
c00275d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00275d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00275e0:	e9 a9 00 00 00       	jmp    c002768e <__vprintf+0x2b9>
              case INT:
                value = va_arg (args, unsigned);
c00275e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275e8:	8d 50 04             	lea    0x4(%eax),%edx
c00275eb:	89 55 0c             	mov    %edx,0xc(%ebp)
c00275ee:	8b 00                	mov    (%eax),%eax
c00275f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00275f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00275fa:	e9 8f 00 00 00       	jmp    c002768e <__vprintf+0x2b9>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c00275ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027602:	8d 50 08             	lea    0x8(%eax),%edx
c0027605:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027608:	8b 50 04             	mov    0x4(%eax),%edx
c002760b:	8b 00                	mov    (%eax),%eax
c002760d:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027610:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c0027613:	eb 79                	jmp    c002768e <__vprintf+0x2b9>
              case LONG:
                value = va_arg (args, unsigned long);
c0027615:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027618:	8d 50 04             	lea    0x4(%eax),%edx
c002761b:	89 55 0c             	mov    %edx,0xc(%ebp)
c002761e:	8b 00                	mov    (%eax),%eax
c0027620:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027623:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c002762a:	eb 62                	jmp    c002768e <__vprintf+0x2b9>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c002762c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002762f:	8d 50 08             	lea    0x8(%eax),%edx
c0027632:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027635:	8b 50 04             	mov    0x4(%eax),%edx
c0027638:	8b 00                	mov    (%eax),%eax
c002763a:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002763d:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c0027640:	eb 4c                	jmp    c002768e <__vprintf+0x2b9>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0027642:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027645:	8d 50 04             	lea    0x4(%eax),%edx
c0027648:	89 55 0c             	mov    %edx,0xc(%ebp)
c002764b:	8b 00                	mov    (%eax),%eax
c002764d:	99                   	cltd   
c002764e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027651:	89 55 ec             	mov    %edx,-0x14(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027654:	83 65 e8 ff          	andl   $0xffffffff,-0x18(%ebp)
c0027658:	83 65 ec 00          	andl   $0x0,-0x14(%ebp)
#endif
                break;
c002765c:	eb 30                	jmp    c002768e <__vprintf+0x2b9>
              case SIZET:
                value = va_arg (args, size_t);
c002765e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027661:	8d 50 04             	lea    0x4(%eax),%edx
c0027664:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027667:	8b 00                	mov    (%eax),%eax
c0027669:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002766c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c0027673:	eb 19                	jmp    c002768e <__vprintf+0x2b9>
              default:
                NOT_REACHED ();
c0027675:	68 7c 19 03 c0       	push   $0xc003197c
c002767a:	68 b0 1b 03 c0       	push   $0xc0031bb0
c002767f:	68 0b 01 00 00       	push   $0x10b
c0027684:	68 9e 19 03 c0       	push   $0xc003199e
c0027689:	e8 e0 20 00 00       	call   c002976e <debug_panic>
              }

            switch (*format) 
c002768e:	8b 45 08             	mov    0x8(%ebp),%eax
c0027691:	8a 00                	mov    (%eax),%al
c0027693:	0f be c0             	movsbl %al,%eax
c0027696:	83 f8 6f             	cmp    $0x6f,%eax
c0027699:	74 18                	je     c00276b3 <__vprintf+0x2de>
c002769b:	83 f8 6f             	cmp    $0x6f,%eax
c002769e:	7f 07                	jg     c00276a7 <__vprintf+0x2d2>
c00276a0:	83 f8 58             	cmp    $0x58,%eax
c00276a3:	74 29                	je     c00276ce <__vprintf+0x2f9>
c00276a5:	eb 30                	jmp    c00276d7 <__vprintf+0x302>
c00276a7:	83 f8 75             	cmp    $0x75,%eax
c00276aa:	74 10                	je     c00276bc <__vprintf+0x2e7>
c00276ac:	83 f8 78             	cmp    $0x78,%eax
c00276af:	74 14                	je     c00276c5 <__vprintf+0x2f0>
c00276b1:	eb 24                	jmp    c00276d7 <__vprintf+0x302>
              {
              case 'o': b = &base_o; break;
c00276b3:	c7 45 e4 24 19 03 c0 	movl   $0xc0031924,-0x1c(%ebp)
c00276ba:	eb 34                	jmp    c00276f0 <__vprintf+0x31b>
              case 'u': b = &base_d; break;
c00276bc:	c7 45 e4 08 19 03 c0 	movl   $0xc0031908,-0x1c(%ebp)
c00276c3:	eb 2b                	jmp    c00276f0 <__vprintf+0x31b>
              case 'x': b = &base_x; break;
c00276c5:	c7 45 e4 48 19 03 c0 	movl   $0xc0031948,-0x1c(%ebp)
c00276cc:	eb 22                	jmp    c00276f0 <__vprintf+0x31b>
              case 'X': b = &base_X; break;
c00276ce:	c7 45 e4 6c 19 03 c0 	movl   $0xc003196c,-0x1c(%ebp)
c00276d5:	eb 19                	jmp    c00276f0 <__vprintf+0x31b>
              default: NOT_REACHED ();
c00276d7:	68 7c 19 03 c0       	push   $0xc003197c
c00276dc:	68 b0 1b 03 c0       	push   $0xc0031bb0
c00276e1:	68 14 01 00 00       	push   $0x114
c00276e6:	68 9e 19 03 c0       	push   $0xc003199e
c00276eb:	e8 7e 20 00 00       	call   c002976e <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c00276f0:	ff 75 14             	pushl  0x14(%ebp)
c00276f3:	ff 75 10             	pushl  0x10(%ebp)
c00276f6:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00276f9:	50                   	push   %eax
c00276fa:	ff 75 e4             	pushl  -0x1c(%ebp)
c00276fd:	6a 00                	push   $0x0
c00276ff:	6a 00                	push   $0x0
c0027701:	ff 75 ec             	pushl  -0x14(%ebp)
c0027704:	ff 75 e8             	pushl  -0x18(%ebp)
c0027707:	e8 c1 03 00 00       	call   c0027acd <format_integer>
c002770c:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002770f:	e9 ef 00 00 00       	jmp    c0027803 <__vprintf+0x42e>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c0027714:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027717:	8d 50 04             	lea    0x4(%eax),%edx
c002771a:	89 55 0c             	mov    %edx,0xc(%ebp)
c002771d:	8b 00                	mov    (%eax),%eax
c002771f:	88 45 cb             	mov    %al,-0x35(%ebp)
            format_string (&ch, 1, &c, output, aux);
c0027722:	83 ec 0c             	sub    $0xc,%esp
c0027725:	ff 75 14             	pushl  0x14(%ebp)
c0027728:	ff 75 10             	pushl  0x10(%ebp)
c002772b:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002772e:	50                   	push   %eax
c002772f:	6a 01                	push   $0x1
c0027731:	8d 45 cb             	lea    -0x35(%ebp),%eax
c0027734:	50                   	push   %eax
c0027735:	e8 ed 06 00 00       	call   c0027e27 <format_string>
c002773a:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002773d:	e9 c1 00 00 00       	jmp    c0027803 <__vprintf+0x42e>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c0027742:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027745:	8d 50 04             	lea    0x4(%eax),%edx
c0027748:	89 55 0c             	mov    %edx,0xc(%ebp)
c002774b:	8b 00                	mov    (%eax),%eax
c002774d:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (s == NULL)
c0027750:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027754:	75 07                	jne    c002775d <__vprintf+0x388>
              s = "(null)";
c0027756:	c7 45 e0 b0 19 03 c0 	movl   $0xc00319b0,-0x20(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c002775d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027760:	83 ec 08             	sub    $0x8,%esp
c0027763:	50                   	push   %eax
c0027764:	ff 75 e0             	pushl  -0x20(%ebp)
c0027767:	e8 c2 14 00 00       	call   c0028c2e <strnlen>
c002776c:	83 c4 10             	add    $0x10,%esp
c002776f:	89 c2                	mov    %eax,%edx
c0027771:	83 ec 0c             	sub    $0xc,%esp
c0027774:	ff 75 14             	pushl  0x14(%ebp)
c0027777:	ff 75 10             	pushl  0x10(%ebp)
c002777a:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002777d:	50                   	push   %eax
c002777e:	52                   	push   %edx
c002777f:	ff 75 e0             	pushl  -0x20(%ebp)
c0027782:	e8 a0 06 00 00       	call   c0027e27 <format_string>
c0027787:	83 c4 20             	add    $0x20,%esp
          }
          break;
c002778a:	eb 77                	jmp    c0027803 <__vprintf+0x42e>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c002778c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002778f:	8d 50 04             	lea    0x4(%eax),%edx
c0027792:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027795:	8b 00                	mov    (%eax),%eax
c0027797:	89 45 dc             	mov    %eax,-0x24(%ebp)

            c.flags = POUND;
c002779a:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%ebp)
            format_integer ((uintptr_t) p, false, false,
c00277a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00277a4:	ba 00 00 00 00       	mov    $0x0,%edx
c00277a9:	ff 75 14             	pushl  0x14(%ebp)
c00277ac:	ff 75 10             	pushl  0x10(%ebp)
c00277af:	8d 4d cc             	lea    -0x34(%ebp),%ecx
c00277b2:	51                   	push   %ecx
c00277b3:	68 48 19 03 c0       	push   $0xc0031948
c00277b8:	6a 00                	push   $0x0
c00277ba:	6a 00                	push   $0x0
c00277bc:	52                   	push   %edx
c00277bd:	50                   	push   %eax
c00277be:	e8 0a 03 00 00       	call   c0027acd <format_integer>
c00277c3:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c00277c6:	eb 3b                	jmp    c0027803 <__vprintf+0x42e>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c00277c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00277cb:	8a 00                	mov    (%eax),%al
c00277cd:	0f be c0             	movsbl %al,%eax
c00277d0:	50                   	push   %eax
c00277d1:	ff 75 14             	pushl  0x14(%ebp)
c00277d4:	ff 75 10             	pushl  0x10(%ebp)
c00277d7:	68 b7 19 03 c0       	push   $0xc00319b7
c00277dc:	e8 e1 06 00 00       	call   c0027ec2 <__printf>
c00277e1:	83 c4 10             	add    $0x10,%esp
          break;
c00277e4:	eb 1d                	jmp    c0027803 <__vprintf+0x42e>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c00277e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00277e9:	8a 00                	mov    (%eax),%al
c00277eb:	0f be c0             	movsbl %al,%eax
c00277ee:	50                   	push   %eax
c00277ef:	ff 75 14             	pushl  0x14(%ebp)
c00277f2:	ff 75 10             	pushl  0x10(%ebp)
c00277f5:	68 cd 19 03 c0       	push   $0xc00319cd
c00277fa:	e8 c3 06 00 00       	call   c0027ec2 <__printf>
c00277ff:	83 c4 10             	add    $0x10,%esp
          break;
c0027802:	90                   	nop
  for (; *format != '\0'; format++)
c0027803:	ff 45 08             	incl   0x8(%ebp)
c0027806:	8b 45 08             	mov    0x8(%ebp),%eax
c0027809:	8a 00                	mov    (%eax),%al
c002780b:	84 c0                	test   %al,%al
c002780d:	0f 85 ce fb ff ff    	jne    c00273e1 <__vprintf+0xc>
        }
    }
}
c0027813:	90                   	nop
c0027814:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0027817:	c9                   	leave  
c0027818:	c3                   	ret    

c0027819 <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c0027819:	55                   	push   %ebp
c002781a:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c002781c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002781f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c0027825:	8b 45 08             	mov    0x8(%ebp),%eax
c0027828:	8d 50 01             	lea    0x1(%eax),%edx
c002782b:	89 55 08             	mov    %edx,0x8(%ebp)
c002782e:	8a 00                	mov    (%eax),%al
c0027830:	0f be c0             	movsbl %al,%eax
c0027833:	83 e8 20             	sub    $0x20,%eax
c0027836:	83 f8 10             	cmp    $0x10,%eax
c0027839:	77 6f                	ja     c00278aa <parse_conversion+0x91>
c002783b:	8b 04 85 fc 1a 03 c0 	mov    -0x3ffce504(,%eax,4),%eax
c0027842:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c0027844:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027847:	8b 00                	mov    (%eax),%eax
c0027849:	83 c8 01             	or     $0x1,%eax
c002784c:	89 c2                	mov    %eax,%edx
c002784e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027851:	89 10                	mov    %edx,(%eax)
          break;
c0027853:	eb 67                	jmp    c00278bc <parse_conversion+0xa3>
        case '+':
          c->flags |= PLUS;
c0027855:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027858:	8b 00                	mov    (%eax),%eax
c002785a:	83 c8 02             	or     $0x2,%eax
c002785d:	89 c2                	mov    %eax,%edx
c002785f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027862:	89 10                	mov    %edx,(%eax)
          break;
c0027864:	eb 56                	jmp    c00278bc <parse_conversion+0xa3>
        case ' ':
          c->flags |= SPACE;
c0027866:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027869:	8b 00                	mov    (%eax),%eax
c002786b:	83 c8 04             	or     $0x4,%eax
c002786e:	89 c2                	mov    %eax,%edx
c0027870:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027873:	89 10                	mov    %edx,(%eax)
          break;
c0027875:	eb 45                	jmp    c00278bc <parse_conversion+0xa3>
        case '#':
          c->flags |= POUND;
c0027877:	8b 45 0c             	mov    0xc(%ebp),%eax
c002787a:	8b 00                	mov    (%eax),%eax
c002787c:	83 c8 08             	or     $0x8,%eax
c002787f:	89 c2                	mov    %eax,%edx
c0027881:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027884:	89 10                	mov    %edx,(%eax)
          break;
c0027886:	eb 34                	jmp    c00278bc <parse_conversion+0xa3>
        case '0':
          c->flags |= ZERO;
c0027888:	8b 45 0c             	mov    0xc(%ebp),%eax
c002788b:	8b 00                	mov    (%eax),%eax
c002788d:	83 c8 10             	or     $0x10,%eax
c0027890:	89 c2                	mov    %eax,%edx
c0027892:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027895:	89 10                	mov    %edx,(%eax)
          break;
c0027897:	eb 23                	jmp    c00278bc <parse_conversion+0xa3>
        case '\'':
          c->flags |= GROUP;
c0027899:	8b 45 0c             	mov    0xc(%ebp),%eax
c002789c:	8b 00                	mov    (%eax),%eax
c002789e:	83 c8 20             	or     $0x20,%eax
c00278a1:	89 c2                	mov    %eax,%edx
c00278a3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278a6:	89 10                	mov    %edx,(%eax)
          break;
c00278a8:	eb 12                	jmp    c00278bc <parse_conversion+0xa3>
        default:
          format--;
c00278aa:	ff 4d 08             	decl   0x8(%ebp)
          goto not_a_flag;
c00278ad:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c00278ae:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278b1:	8b 00                	mov    (%eax),%eax
c00278b3:	83 e0 01             	and    $0x1,%eax
c00278b6:	85 c0                	test   %eax,%eax
c00278b8:	74 16                	je     c00278d0 <parse_conversion+0xb7>
c00278ba:	eb 05                	jmp    c00278c1 <parse_conversion+0xa8>
      switch (*format++) 
c00278bc:	e9 64 ff ff ff       	jmp    c0027825 <parse_conversion+0xc>
    c->flags &= ~ZERO;
c00278c1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278c4:	8b 00                	mov    (%eax),%eax
c00278c6:	83 e0 ef             	and    $0xffffffef,%eax
c00278c9:	89 c2                	mov    %eax,%edx
c00278cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278ce:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c00278d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278d3:	8b 00                	mov    (%eax),%eax
c00278d5:	83 e0 02             	and    $0x2,%eax
c00278d8:	85 c0                	test   %eax,%eax
c00278da:	74 0f                	je     c00278eb <parse_conversion+0xd2>
    c->flags &= ~SPACE;
c00278dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278df:	8b 00                	mov    (%eax),%eax
c00278e1:	83 e0 fb             	and    $0xfffffffb,%eax
c00278e4:	89 c2                	mov    %eax,%edx
c00278e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278e9:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c00278eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278ee:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c00278f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00278f8:	8a 00                	mov    (%eax),%al
c00278fa:	3c 2a                	cmp    $0x2a,%al
c00278fc:	75 41                	jne    c002793f <parse_conversion+0x126>
    {
      format++;
c00278fe:	ff 45 08             	incl   0x8(%ebp)
      c->width = va_arg (*args, int);
c0027901:	8b 45 10             	mov    0x10(%ebp),%eax
c0027904:	8b 00                	mov    (%eax),%eax
c0027906:	8d 48 04             	lea    0x4(%eax),%ecx
c0027909:	8b 55 10             	mov    0x10(%ebp),%edx
c002790c:	89 0a                	mov    %ecx,(%edx)
c002790e:	8b 10                	mov    (%eax),%edx
c0027910:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027913:	89 50 04             	mov    %edx,0x4(%eax)
c0027916:	eb 3c                	jmp    c0027954 <parse_conversion+0x13b>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c0027918:	8b 45 0c             	mov    0xc(%ebp),%eax
c002791b:	8b 50 04             	mov    0x4(%eax),%edx
c002791e:	89 d0                	mov    %edx,%eax
c0027920:	c1 e0 02             	shl    $0x2,%eax
c0027923:	01 d0                	add    %edx,%eax
c0027925:	01 c0                	add    %eax,%eax
c0027927:	89 c2                	mov    %eax,%edx
c0027929:	8b 45 08             	mov    0x8(%ebp),%eax
c002792c:	8a 00                	mov    (%eax),%al
c002792e:	0f be c0             	movsbl %al,%eax
c0027931:	01 d0                	add    %edx,%eax
c0027933:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027936:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027939:	89 50 04             	mov    %edx,0x4(%eax)
      for (; isdigit (*format); format++)
c002793c:	ff 45 08             	incl   0x8(%ebp)
c002793f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027942:	8a 00                	mov    (%eax),%al
c0027944:	0f be c0             	movsbl %al,%eax
c0027947:	50                   	push   %eax
c0027948:	e8 70 f9 ff ff       	call   c00272bd <isdigit>
c002794d:	83 c4 04             	add    $0x4,%esp
c0027950:	85 c0                	test   %eax,%eax
c0027952:	75 c4                	jne    c0027918 <parse_conversion+0xff>
    }
  if (c->width < 0) 
c0027954:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027957:	8b 40 04             	mov    0x4(%eax),%eax
c002795a:	85 c0                	test   %eax,%eax
c002795c:	79 1f                	jns    c002797d <parse_conversion+0x164>
    {
      c->width = -c->width;
c002795e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027961:	8b 40 04             	mov    0x4(%eax),%eax
c0027964:	f7 d8                	neg    %eax
c0027966:	89 c2                	mov    %eax,%edx
c0027968:	8b 45 0c             	mov    0xc(%ebp),%eax
c002796b:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c002796e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027971:	8b 00                	mov    (%eax),%eax
c0027973:	83 c8 01             	or     $0x1,%eax
c0027976:	89 c2                	mov    %eax,%edx
c0027978:	8b 45 0c             	mov    0xc(%ebp),%eax
c002797b:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c002797d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027980:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0027987:	8b 45 08             	mov    0x8(%ebp),%eax
c002798a:	8a 00                	mov    (%eax),%al
c002798c:	3c 2e                	cmp    $0x2e,%al
c002798e:	0f 85 82 00 00 00    	jne    c0027a16 <parse_conversion+0x1fd>
    {
      format++;
c0027994:	ff 45 08             	incl   0x8(%ebp)
      if (*format == '*') 
c0027997:	8b 45 08             	mov    0x8(%ebp),%eax
c002799a:	8a 00                	mov    (%eax),%al
c002799c:	3c 2a                	cmp    $0x2a,%al
c002799e:	75 1a                	jne    c00279ba <parse_conversion+0x1a1>
        {
          format++;
c00279a0:	ff 45 08             	incl   0x8(%ebp)
          c->precision = va_arg (*args, int);
c00279a3:	8b 45 10             	mov    0x10(%ebp),%eax
c00279a6:	8b 00                	mov    (%eax),%eax
c00279a8:	8d 48 04             	lea    0x4(%eax),%ecx
c00279ab:	8b 55 10             	mov    0x10(%ebp),%edx
c00279ae:	89 0a                	mov    %ecx,(%edx)
c00279b0:	8b 10                	mov    (%eax),%edx
c00279b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279b5:	89 50 08             	mov    %edx,0x8(%eax)
c00279b8:	eb 48                	jmp    c0027a02 <parse_conversion+0x1e9>
        }
      else 
        {
          c->precision = 0;
c00279ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279bd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c00279c4:	eb 27                	jmp    c00279ed <parse_conversion+0x1d4>
            c->precision = c->precision * 10 + *format - '0';
c00279c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279c9:	8b 50 08             	mov    0x8(%eax),%edx
c00279cc:	89 d0                	mov    %edx,%eax
c00279ce:	c1 e0 02             	shl    $0x2,%eax
c00279d1:	01 d0                	add    %edx,%eax
c00279d3:	01 c0                	add    %eax,%eax
c00279d5:	89 c2                	mov    %eax,%edx
c00279d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00279da:	8a 00                	mov    (%eax),%al
c00279dc:	0f be c0             	movsbl %al,%eax
c00279df:	01 d0                	add    %edx,%eax
c00279e1:	8d 50 d0             	lea    -0x30(%eax),%edx
c00279e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00279e7:	89 50 08             	mov    %edx,0x8(%eax)
          for (; isdigit (*format); format++)
c00279ea:	ff 45 08             	incl   0x8(%ebp)
c00279ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00279f0:	8a 00                	mov    (%eax),%al
c00279f2:	0f be c0             	movsbl %al,%eax
c00279f5:	50                   	push   %eax
c00279f6:	e8 c2 f8 ff ff       	call   c00272bd <isdigit>
c00279fb:	83 c4 04             	add    $0x4,%esp
c00279fe:	85 c0                	test   %eax,%eax
c0027a00:	75 c4                	jne    c00279c6 <parse_conversion+0x1ad>
        }
      if (c->precision < 0) 
c0027a02:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a05:	8b 40 08             	mov    0x8(%eax),%eax
c0027a08:	85 c0                	test   %eax,%eax
c0027a0a:	79 0a                	jns    c0027a16 <parse_conversion+0x1fd>
        c->precision = -1;
c0027a0c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a0f:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c0027a16:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a19:	8b 40 08             	mov    0x8(%eax),%eax
c0027a1c:	85 c0                	test   %eax,%eax
c0027a1e:	78 0f                	js     c0027a2f <parse_conversion+0x216>
    c->flags &= ~ZERO;
c0027a20:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a23:	8b 00                	mov    (%eax),%eax
c0027a25:	83 e0 ef             	and    $0xffffffef,%eax
c0027a28:	89 c2                	mov    %eax,%edx
c0027a2a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a2d:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c0027a2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a32:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c0027a39:	8b 45 08             	mov    0x8(%ebp),%eax
c0027a3c:	8d 50 01             	lea    0x1(%eax),%edx
c0027a3f:	89 55 08             	mov    %edx,0x8(%ebp)
c0027a42:	8a 00                	mov    (%eax),%al
c0027a44:	0f be c0             	movsbl %al,%eax
c0027a47:	83 e8 68             	sub    $0x68,%eax
c0027a4a:	83 f8 12             	cmp    $0x12,%eax
c0027a4d:	77 75                	ja     c0027ac4 <parse_conversion+0x2ab>
c0027a4f:	8b 04 85 40 1b 03 c0 	mov    -0x3ffce4c0(,%eax,4),%eax
c0027a56:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c0027a58:	8b 45 08             	mov    0x8(%ebp),%eax
c0027a5b:	8a 00                	mov    (%eax),%al
c0027a5d:	3c 68                	cmp    $0x68,%al
c0027a5f:	75 0f                	jne    c0027a70 <parse_conversion+0x257>
        {
          format++;
c0027a61:	ff 45 08             	incl   0x8(%ebp)
          c->type = CHAR;
c0027a64:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a67:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0027a6e:	eb 58                	jmp    c0027ac8 <parse_conversion+0x2af>
        c->type = SHORT;
c0027a70:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a73:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027a7a:	eb 4c                	jmp    c0027ac8 <parse_conversion+0x2af>
      
    case 'j':
      c->type = INTMAX;
c0027a7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a7f:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0027a86:	eb 40                	jmp    c0027ac8 <parse_conversion+0x2af>

    case 'l':
      if (*format == 'l')
c0027a88:	8b 45 08             	mov    0x8(%ebp),%eax
c0027a8b:	8a 00                	mov    (%eax),%al
c0027a8d:	3c 6c                	cmp    $0x6c,%al
c0027a8f:	75 0f                	jne    c0027aa0 <parse_conversion+0x287>
        {
          format++;
c0027a91:	ff 45 08             	incl   0x8(%ebp)
          c->type = LONGLONG;
c0027a94:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a97:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0027a9e:	eb 28                	jmp    c0027ac8 <parse_conversion+0x2af>
        c->type = LONG;
c0027aa0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027aa3:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027aaa:	eb 1c                	jmp    c0027ac8 <parse_conversion+0x2af>

    case 't':
      c->type = PTRDIFFT;
c0027aac:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027aaf:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0027ab6:	eb 10                	jmp    c0027ac8 <parse_conversion+0x2af>

    case 'z':
      c->type = SIZET;
c0027ab8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027abb:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c0027ac2:	eb 04                	jmp    c0027ac8 <parse_conversion+0x2af>

    default:
      format--;
c0027ac4:	ff 4d 08             	decl   0x8(%ebp)
      break;
c0027ac7:	90                   	nop
    }

  return format;
c0027ac8:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027acb:	c9                   	leave  
c0027acc:	c3                   	ret    

c0027acd <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027acd:	55                   	push   %ebp
c0027ace:	89 e5                	mov    %esp,%ebp
c0027ad0:	57                   	push   %edi
c0027ad1:	56                   	push   %esi
c0027ad2:	53                   	push   %ebx
c0027ad3:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
c0027ad9:	8b 45 10             	mov    0x10(%ebp),%eax
c0027adc:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
c0027ae2:	8b 5d 14             	mov    0x14(%ebp),%ebx
c0027ae5:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ae8:	89 45 80             	mov    %eax,-0x80(%ebp)
c0027aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027aee:	89 45 84             	mov    %eax,-0x7c(%ebp)
c0027af1:	8a 85 6c ff ff ff    	mov    -0x94(%ebp),%al
c0027af7:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
c0027afd:	88 9d 78 ff ff ff    	mov    %bl,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c0027b03:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c0027b0a:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c0027b11:	74 5c                	je     c0027b6f <format_integer+0xa2>
    {
      if (c->flags & PLUS)
c0027b13:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b16:	8b 00                	mov    (%eax),%eax
c0027b18:	83 e0 02             	and    $0x2,%eax
c0027b1b:	85 c0                	test   %eax,%eax
c0027b1d:	74 1a                	je     c0027b39 <format_integer+0x6c>
        sign = negative ? '-' : '+';
c0027b1f:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027b26:	74 07                	je     c0027b2f <format_integer+0x62>
c0027b28:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027b2d:	eb 05                	jmp    c0027b34 <format_integer+0x67>
c0027b2f:	b8 2b 00 00 00       	mov    $0x2b,%eax
c0027b34:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027b37:	eb 36                	jmp    c0027b6f <format_integer+0xa2>
      else if (c->flags & SPACE)
c0027b39:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b3c:	8b 00                	mov    (%eax),%eax
c0027b3e:	83 e0 04             	and    $0x4,%eax
c0027b41:	85 c0                	test   %eax,%eax
c0027b43:	74 1a                	je     c0027b5f <format_integer+0x92>
        sign = negative ? '-' : ' ';
c0027b45:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027b4c:	74 07                	je     c0027b55 <format_integer+0x88>
c0027b4e:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027b53:	eb 05                	jmp    c0027b5a <format_integer+0x8d>
c0027b55:	b8 20 00 00 00       	mov    $0x20,%eax
c0027b5a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027b5d:	eb 10                	jmp    c0027b6f <format_integer+0xa2>
      else if (negative)
c0027b5f:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027b66:	74 07                	je     c0027b6f <format_integer+0xa2>
        sign = '-';
c0027b68:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0027b6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b72:	8b 00                	mov    (%eax),%eax
c0027b74:	83 e0 08             	and    $0x8,%eax
c0027b77:	85 c0                	test   %eax,%eax
c0027b79:	74 20                	je     c0027b9b <format_integer+0xce>
c0027b7b:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027b7e:	80 f4 00             	xor    $0x0,%ah
c0027b81:	89 c2                	mov    %eax,%edx
c0027b83:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027b86:	80 f4 00             	xor    $0x0,%ah
c0027b89:	89 c1                	mov    %eax,%ecx
c0027b8b:	89 c8                	mov    %ecx,%eax
c0027b8d:	09 d0                	or     %edx,%eax
c0027b8f:	85 c0                	test   %eax,%eax
c0027b91:	74 08                	je     c0027b9b <format_integer+0xce>
c0027b93:	8b 45 18             	mov    0x18(%ebp),%eax
c0027b96:	8b 40 08             	mov    0x8(%eax),%eax
c0027b99:	eb 05                	jmp    c0027ba0 <format_integer+0xd3>
c0027b9b:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ba0:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0027ba3:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027ba6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027ba9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c0027bb0:	e9 82 00 00 00       	jmp    c0027c37 <format_integer+0x16a>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027bb5:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027bb8:	8b 00                	mov    (%eax),%eax
c0027bba:	83 e0 20             	and    $0x20,%eax
c0027bbd:	85 c0                	test   %eax,%eax
c0027bbf:	74 24                	je     c0027be5 <format_integer+0x118>
c0027bc1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c0027bc5:	7e 1e                	jle    c0027be5 <format_integer+0x118>
c0027bc7:	8b 45 18             	mov    0x18(%ebp),%eax
c0027bca:	8b 48 0c             	mov    0xc(%eax),%ecx
c0027bcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027bd0:	99                   	cltd   
c0027bd1:	f7 f9                	idiv   %ecx
c0027bd3:	89 d0                	mov    %edx,%eax
c0027bd5:	85 c0                	test   %eax,%eax
c0027bd7:	75 0c                	jne    c0027be5 <format_integer+0x118>
        *cp++ = ',';
c0027bd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027bdc:	8d 50 01             	lea    0x1(%eax),%edx
c0027bdf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027be2:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c0027be5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0027be8:	8d 46 01             	lea    0x1(%esi),%eax
c0027beb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0027bee:	8b 45 18             	mov    0x18(%ebp),%eax
c0027bf1:	8b 78 04             	mov    0x4(%eax),%edi
c0027bf4:	8b 45 18             	mov    0x18(%ebp),%eax
c0027bf7:	8b 00                	mov    (%eax),%eax
c0027bf9:	89 c1                	mov    %eax,%ecx
c0027bfb:	89 c3                	mov    %eax,%ebx
c0027bfd:	c1 fb 1f             	sar    $0x1f,%ebx
c0027c00:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027c03:	8b 55 84             	mov    -0x7c(%ebp),%edx
c0027c06:	53                   	push   %ebx
c0027c07:	51                   	push   %ecx
c0027c08:	52                   	push   %edx
c0027c09:	50                   	push   %eax
c0027c0a:	e8 02 16 00 00       	call   c0029211 <__umoddi3>
c0027c0f:	83 c4 10             	add    $0x10,%esp
c0027c12:	01 f8                	add    %edi,%eax
c0027c14:	8a 00                	mov    (%eax),%al
c0027c16:	88 06                	mov    %al,(%esi)
      value /= b->base;
c0027c18:	8b 45 18             	mov    0x18(%ebp),%eax
c0027c1b:	8b 00                	mov    (%eax),%eax
c0027c1d:	99                   	cltd   
c0027c1e:	52                   	push   %edx
c0027c1f:	50                   	push   %eax
c0027c20:	ff 75 84             	pushl  -0x7c(%ebp)
c0027c23:	ff 75 80             	pushl  -0x80(%ebp)
c0027c26:	e8 b2 15 00 00       	call   c00291dd <__udivdi3>
c0027c2b:	83 c4 10             	add    $0x10,%esp
c0027c2e:	89 45 80             	mov    %eax,-0x80(%ebp)
c0027c31:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c0027c34:	ff 45 d8             	incl   -0x28(%ebp)
  while (value > 0) 
c0027c37:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027c3a:	80 f4 00             	xor    $0x0,%ah
c0027c3d:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
c0027c43:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027c46:	80 f4 00             	xor    $0x0,%ah
c0027c49:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c0027c4f:	8b 9d 70 ff ff ff    	mov    -0x90(%ebp),%ebx
c0027c55:	8b b5 74 ff ff ff    	mov    -0x8c(%ebp),%esi
c0027c5b:	89 f0                	mov    %esi,%eax
c0027c5d:	09 d8                	or     %ebx,%eax
c0027c5f:	85 c0                	test   %eax,%eax
c0027c61:	0f 85 4e ff ff ff    	jne    c0027bb5 <format_integer+0xe8>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0027c67:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027c6a:	8b 40 08             	mov    0x8(%eax),%eax
c0027c6d:	85 c0                	test   %eax,%eax
c0027c6f:	78 08                	js     c0027c79 <format_integer+0x1ac>
c0027c71:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027c74:	8b 40 08             	mov    0x8(%eax),%eax
c0027c77:	eb 05                	jmp    c0027c7e <format_integer+0x1b1>
c0027c79:	b8 01 00 00 00       	mov    $0x1,%eax
c0027c7e:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027c81:	eb 0c                	jmp    c0027c8f <format_integer+0x1c2>
    *cp++ = '0';
c0027c83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027c86:	8d 50 01             	lea    0x1(%eax),%edx
c0027c89:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027c8c:	c6 00 30             	movb   $0x30,(%eax)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027c8f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027c92:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027c95:	29 c2                	sub    %eax,%edx
c0027c97:	89 d0                	mov    %edx,%eax
c0027c99:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0027c9c:	7d 0b                	jge    c0027ca9 <format_integer+0x1dc>
c0027c9e:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027ca1:	83 c0 3f             	add    $0x3f,%eax
c0027ca4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027ca7:	77 da                	ja     c0027c83 <format_integer+0x1b6>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027ca9:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027cac:	8b 00                	mov    (%eax),%eax
c0027cae:	83 e0 08             	and    $0x8,%eax
c0027cb1:	85 c0                	test   %eax,%eax
c0027cb3:	74 28                	je     c0027cdd <format_integer+0x210>
c0027cb5:	8b 45 18             	mov    0x18(%ebp),%eax
c0027cb8:	8b 00                	mov    (%eax),%eax
c0027cba:	83 f8 08             	cmp    $0x8,%eax
c0027cbd:	75 1e                	jne    c0027cdd <format_integer+0x210>
c0027cbf:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027cc2:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027cc5:	74 0a                	je     c0027cd1 <format_integer+0x204>
c0027cc7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027cca:	48                   	dec    %eax
c0027ccb:	8a 00                	mov    (%eax),%al
c0027ccd:	3c 30                	cmp    $0x30,%al
c0027ccf:	74 0c                	je     c0027cdd <format_integer+0x210>
    *cp++ = '0';
c0027cd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027cd4:	8d 50 01             	lea    0x1(%eax),%edx
c0027cd7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027cda:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027cdd:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027ce0:	8b 40 04             	mov    0x4(%eax),%eax
c0027ce3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027ce6:	8d 55 90             	lea    -0x70(%ebp),%edx
c0027ce9:	29 d1                	sub    %edx,%ecx
c0027ceb:	89 ca                	mov    %ecx,%edx
c0027ced:	29 d0                	sub    %edx,%eax
c0027cef:	89 c2                	mov    %eax,%edx
c0027cf1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027cf5:	74 07                	je     c0027cfe <format_integer+0x231>
c0027cf7:	b8 02 00 00 00       	mov    $0x2,%eax
c0027cfc:	eb 05                	jmp    c0027d03 <format_integer+0x236>
c0027cfe:	b8 00 00 00 00       	mov    $0x0,%eax
c0027d03:	29 c2                	sub    %eax,%edx
c0027d05:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027d09:	0f 95 c0             	setne  %al
c0027d0c:	0f b6 c0             	movzbl %al,%eax
c0027d0f:	29 c2                	sub    %eax,%edx
c0027d11:	89 d0                	mov    %edx,%eax
c0027d13:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c0027d16:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0027d1a:	79 07                	jns    c0027d23 <format_integer+0x256>
    pad_cnt = 0;
c0027d1c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027d23:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027d26:	8b 00                	mov    (%eax),%eax
c0027d28:	83 e0 11             	and    $0x11,%eax
c0027d2b:	85 c0                	test   %eax,%eax
c0027d2d:	75 14                	jne    c0027d43 <format_integer+0x276>
    output_dup (' ', pad_cnt, output, aux);
c0027d2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027d32:	ff 75 24             	pushl  0x24(%ebp)
c0027d35:	ff 75 20             	pushl  0x20(%ebp)
c0027d38:	50                   	push   %eax
c0027d39:	6a 20                	push   $0x20
c0027d3b:	e8 b6 00 00 00       	call   c0027df6 <output_dup>
c0027d40:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0027d43:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027d47:	74 15                	je     c0027d5e <format_integer+0x291>
    output (sign, aux);
c0027d49:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027d4c:	0f be c0             	movsbl %al,%eax
c0027d4f:	83 ec 08             	sub    $0x8,%esp
c0027d52:	ff 75 24             	pushl  0x24(%ebp)
c0027d55:	50                   	push   %eax
c0027d56:	8b 45 20             	mov    0x20(%ebp),%eax
c0027d59:	ff d0                	call   *%eax
c0027d5b:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0027d5e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027d62:	74 25                	je     c0027d89 <format_integer+0x2bc>
    {
      output ('0', aux);
c0027d64:	83 ec 08             	sub    $0x8,%esp
c0027d67:	ff 75 24             	pushl  0x24(%ebp)
c0027d6a:	6a 30                	push   $0x30
c0027d6c:	8b 45 20             	mov    0x20(%ebp),%eax
c0027d6f:	ff d0                	call   *%eax
c0027d71:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c0027d74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027d77:	0f be c0             	movsbl %al,%eax
c0027d7a:	83 ec 08             	sub    $0x8,%esp
c0027d7d:	ff 75 24             	pushl  0x24(%ebp)
c0027d80:	50                   	push   %eax
c0027d81:	8b 45 20             	mov    0x20(%ebp),%eax
c0027d84:	ff d0                	call   *%eax
c0027d86:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c0027d89:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027d8c:	8b 00                	mov    (%eax),%eax
c0027d8e:	83 e0 10             	and    $0x10,%eax
c0027d91:	85 c0                	test   %eax,%eax
c0027d93:	74 30                	je     c0027dc5 <format_integer+0x2f8>
    output_dup ('0', pad_cnt, output, aux);
c0027d95:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027d98:	ff 75 24             	pushl  0x24(%ebp)
c0027d9b:	ff 75 20             	pushl  0x20(%ebp)
c0027d9e:	50                   	push   %eax
c0027d9f:	6a 30                	push   $0x30
c0027da1:	e8 50 00 00 00       	call   c0027df6 <output_dup>
c0027da6:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027da9:	eb 1a                	jmp    c0027dc5 <format_integer+0x2f8>
    output (*--cp, aux);
c0027dab:	ff 4d e4             	decl   -0x1c(%ebp)
c0027dae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027db1:	8a 00                	mov    (%eax),%al
c0027db3:	0f be c0             	movsbl %al,%eax
c0027db6:	83 ec 08             	sub    $0x8,%esp
c0027db9:	ff 75 24             	pushl  0x24(%ebp)
c0027dbc:	50                   	push   %eax
c0027dbd:	8b 45 20             	mov    0x20(%ebp),%eax
c0027dc0:	ff d0                	call   *%eax
c0027dc2:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027dc5:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027dc8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027dcb:	77 de                	ja     c0027dab <format_integer+0x2de>
  if (c->flags & MINUS)
c0027dcd:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027dd0:	8b 00                	mov    (%eax),%eax
c0027dd2:	83 e0 01             	and    $0x1,%eax
c0027dd5:	85 c0                	test   %eax,%eax
c0027dd7:	74 14                	je     c0027ded <format_integer+0x320>
    output_dup (' ', pad_cnt, output, aux);
c0027dd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027ddc:	ff 75 24             	pushl  0x24(%ebp)
c0027ddf:	ff 75 20             	pushl  0x20(%ebp)
c0027de2:	50                   	push   %eax
c0027de3:	6a 20                	push   $0x20
c0027de5:	e8 0c 00 00 00       	call   c0027df6 <output_dup>
c0027dea:	83 c4 10             	add    $0x10,%esp
}
c0027ded:	90                   	nop
c0027dee:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027df1:	5b                   	pop    %ebx
c0027df2:	5e                   	pop    %esi
c0027df3:	5f                   	pop    %edi
c0027df4:	5d                   	pop    %ebp
c0027df5:	c3                   	ret    

c0027df6 <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0027df6:	55                   	push   %ebp
c0027df7:	89 e5                	mov    %esp,%ebp
c0027df9:	83 ec 18             	sub    $0x18,%esp
c0027dfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0027dff:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0027e02:	eb 13                	jmp    c0027e17 <output_dup+0x21>
    output (ch, aux);
c0027e04:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0027e08:	83 ec 08             	sub    $0x8,%esp
c0027e0b:	ff 75 14             	pushl  0x14(%ebp)
c0027e0e:	50                   	push   %eax
c0027e0f:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e12:	ff d0                	call   *%eax
c0027e14:	83 c4 10             	add    $0x10,%esp
  while (cnt-- > 0)
c0027e17:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e1a:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027e1d:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027e20:	85 c0                	test   %eax,%eax
c0027e22:	75 e0                	jne    c0027e04 <output_dup+0xe>
}
c0027e24:	90                   	nop
c0027e25:	c9                   	leave  
c0027e26:	c3                   	ret    

c0027e27 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0027e27:	55                   	push   %ebp
c0027e28:	89 e5                	mov    %esp,%ebp
c0027e2a:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027e2d:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e30:	8b 40 04             	mov    0x4(%eax),%eax
c0027e33:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027e36:	7e 26                	jle    c0027e5e <format_string+0x37>
c0027e38:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e3b:	8b 00                	mov    (%eax),%eax
c0027e3d:	83 e0 01             	and    $0x1,%eax
c0027e40:	85 c0                	test   %eax,%eax
c0027e42:	75 1a                	jne    c0027e5e <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c0027e44:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e47:	8b 40 04             	mov    0x4(%eax),%eax
c0027e4a:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027e4d:	ff 75 18             	pushl  0x18(%ebp)
c0027e50:	ff 75 14             	pushl  0x14(%ebp)
c0027e53:	50                   	push   %eax
c0027e54:	6a 20                	push   $0x20
c0027e56:	e8 9b ff ff ff       	call   c0027df6 <output_dup>
c0027e5b:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027e5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027e65:	eb 1f                	jmp    c0027e86 <format_string+0x5f>
    output (string[i], aux);
c0027e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e6d:	01 d0                	add    %edx,%eax
c0027e6f:	8a 00                	mov    (%eax),%al
c0027e71:	0f be c0             	movsbl %al,%eax
c0027e74:	83 ec 08             	sub    $0x8,%esp
c0027e77:	ff 75 18             	pushl  0x18(%ebp)
c0027e7a:	50                   	push   %eax
c0027e7b:	8b 45 14             	mov    0x14(%ebp),%eax
c0027e7e:	ff d0                	call   *%eax
c0027e80:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027e83:	ff 45 f4             	incl   -0xc(%ebp)
c0027e86:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e89:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027e8c:	7c d9                	jl     c0027e67 <format_string+0x40>
  if (c->width > length && (c->flags & MINUS) != 0)
c0027e8e:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e91:	8b 40 04             	mov    0x4(%eax),%eax
c0027e94:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027e97:	7e 26                	jle    c0027ebf <format_string+0x98>
c0027e99:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e9c:	8b 00                	mov    (%eax),%eax
c0027e9e:	83 e0 01             	and    $0x1,%eax
c0027ea1:	85 c0                	test   %eax,%eax
c0027ea3:	74 1a                	je     c0027ebf <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0027ea5:	8b 45 10             	mov    0x10(%ebp),%eax
c0027ea8:	8b 40 04             	mov    0x4(%eax),%eax
c0027eab:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027eae:	ff 75 18             	pushl  0x18(%ebp)
c0027eb1:	ff 75 14             	pushl  0x14(%ebp)
c0027eb4:	50                   	push   %eax
c0027eb5:	6a 20                	push   $0x20
c0027eb7:	e8 3a ff ff ff       	call   c0027df6 <output_dup>
c0027ebc:	83 c4 10             	add    $0x10,%esp
}
c0027ebf:	90                   	nop
c0027ec0:	c9                   	leave  
c0027ec1:	c3                   	ret    

c0027ec2 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0027ec2:	55                   	push   %ebp
c0027ec3:	89 e5                	mov    %esp,%ebp
c0027ec5:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c0027ec8:	8d 45 14             	lea    0x14(%ebp),%eax
c0027ecb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0027ece:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027ed1:	ff 75 10             	pushl  0x10(%ebp)
c0027ed4:	ff 75 0c             	pushl  0xc(%ebp)
c0027ed7:	50                   	push   %eax
c0027ed8:	ff 75 08             	pushl  0x8(%ebp)
c0027edb:	e8 f5 f4 ff ff       	call   c00273d5 <__vprintf>
c0027ee0:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0027ee3:	90                   	nop
c0027ee4:	c9                   	leave  
c0027ee5:	c3                   	ret    

c0027ee6 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027ee6:	55                   	push   %ebp
c0027ee7:	89 e5                	mov    %esp,%ebp
c0027ee9:	83 ec 38             	sub    $0x38,%esp
c0027eec:	8b 45 14             	mov    0x14(%ebp),%eax
c0027eef:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0027ef2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ef5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0027ef8:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c0027eff:	e9 b4 01 00 00       	jmp    c00280b8 <hex_dump+0x1d2>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0027f04:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f07:	ba 00 00 00 00       	mov    $0x0,%edx
c0027f0c:	f7 75 e8             	divl   -0x18(%ebp)
c0027f0f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0027f12:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027f15:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0027f18:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027f1b:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027f1e:	3b 45 10             	cmp    0x10(%ebp),%eax
c0027f21:	76 0b                	jbe    c0027f2e <hex_dump+0x48>
        end = start + size;
c0027f23:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027f26:	8b 45 10             	mov    0x10(%ebp),%eax
c0027f29:	01 d0                	add    %edx,%eax
c0027f2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c0027f2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027f31:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027f34:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027f37:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f3a:	ba 00 00 00 00       	mov    $0x0,%edx
c0027f3f:	f7 75 e8             	divl   -0x18(%ebp)
c0027f42:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0027f46:	ba 00 00 00 00       	mov    $0x0,%edx
c0027f4b:	83 ec 04             	sub    $0x4,%esp
c0027f4e:	52                   	push   %edx
c0027f4f:	50                   	push   %eax
c0027f50:	68 8c 1b 03 c0       	push   $0xc0031b8c
c0027f55:	e8 55 f4 ff ff       	call   c00273af <printf>
c0027f5a:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027f5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027f64:	eb 13                	jmp    c0027f79 <hex_dump+0x93>
        printf ("   ");
c0027f66:	83 ec 0c             	sub    $0xc,%esp
c0027f69:	68 94 1b 03 c0       	push   $0xc0031b94
c0027f6e:	e8 3c f4 ff ff       	call   c00273af <printf>
c0027f73:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027f76:	ff 45 ec             	incl   -0x14(%ebp)
c0027f79:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027f7c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027f7f:	72 e5                	jb     c0027f66 <hex_dump+0x80>
      for (; i < end; i++) 
c0027f81:	eb 3e                	jmp    c0027fc1 <hex_dump+0xdb>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027f83:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027f86:	d1 e8                	shr    %eax
c0027f88:	48                   	dec    %eax
        printf ("%02hhx%c",
c0027f89:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0027f8c:	75 07                	jne    c0027f95 <hex_dump+0xaf>
c0027f8e:	ba 2d 00 00 00       	mov    $0x2d,%edx
c0027f93:	eb 05                	jmp    c0027f9a <hex_dump+0xb4>
c0027f95:	ba 20 00 00 00       	mov    $0x20,%edx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027f9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027f9d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027fa0:	89 c1                	mov    %eax,%ecx
c0027fa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027fa5:	01 c8                	add    %ecx,%eax
c0027fa7:	8a 00                	mov    (%eax),%al
        printf ("%02hhx%c",
c0027fa9:	0f b6 c0             	movzbl %al,%eax
c0027fac:	83 ec 04             	sub    $0x4,%esp
c0027faf:	52                   	push   %edx
c0027fb0:	50                   	push   %eax
c0027fb1:	68 98 1b 03 c0       	push   $0xc0031b98
c0027fb6:	e8 f4 f3 ff ff       	call   c00273af <printf>
c0027fbb:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
c0027fbe:	ff 45 ec             	incl   -0x14(%ebp)
c0027fc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027fc4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027fc7:	72 ba                	jb     c0027f83 <hex_dump+0x9d>
      if (ascii) 
c0027fc9:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0027fcd:	0f 84 c6 00 00 00    	je     c0028099 <hex_dump+0x1b3>
        {
          for (; i < per_line; i++)
c0027fd3:	eb 13                	jmp    c0027fe8 <hex_dump+0x102>
            printf ("   ");
c0027fd5:	83 ec 0c             	sub    $0xc,%esp
c0027fd8:	68 94 1b 03 c0       	push   $0xc0031b94
c0027fdd:	e8 cd f3 ff ff       	call   c00273af <printf>
c0027fe2:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0027fe5:	ff 45 ec             	incl   -0x14(%ebp)
c0027fe8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027feb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027fee:	72 e5                	jb     c0027fd5 <hex_dump+0xef>
          printf ("|");
c0027ff0:	83 ec 0c             	sub    $0xc,%esp
c0027ff3:	6a 7c                	push   $0x7c
c0027ff5:	e8 cb 3a 00 00       	call   c002bac5 <putchar>
c0027ffa:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027ffd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0028004:	eb 10                	jmp    c0028016 <hex_dump+0x130>
            printf (" ");
c0028006:	83 ec 0c             	sub    $0xc,%esp
c0028009:	6a 20                	push   $0x20
c002800b:	e8 b5 3a 00 00       	call   c002bac5 <putchar>
c0028010:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0028013:	ff 45 ec             	incl   -0x14(%ebp)
c0028016:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028019:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002801c:	72 e8                	jb     c0028006 <hex_dump+0x120>
          for (; i < end; i++)
c002801e:	eb 4a                	jmp    c002806a <hex_dump+0x184>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0028020:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028023:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028026:	89 c2                	mov    %eax,%edx
c0028028:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002802b:	01 d0                	add    %edx,%eax
c002802d:	8a 00                	mov    (%eax),%al
c002802f:	0f b6 c0             	movzbl %al,%eax
c0028032:	83 ec 0c             	sub    $0xc,%esp
c0028035:	50                   	push   %eax
c0028036:	e8 9f f2 ff ff       	call   c00272da <isprint>
c002803b:	83 c4 10             	add    $0x10,%esp
            printf ("%c",
c002803e:	85 c0                	test   %eax,%eax
c0028040:	74 14                	je     c0028056 <hex_dump+0x170>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0028042:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028045:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028048:	89 c2                	mov    %eax,%edx
c002804a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002804d:	01 d0                	add    %edx,%eax
c002804f:	8a 00                	mov    (%eax),%al
            printf ("%c",
c0028051:	0f b6 c0             	movzbl %al,%eax
c0028054:	eb 05                	jmp    c002805b <hex_dump+0x175>
c0028056:	b8 2e 00 00 00       	mov    $0x2e,%eax
c002805b:	83 ec 0c             	sub    $0xc,%esp
c002805e:	50                   	push   %eax
c002805f:	e8 61 3a 00 00       	call   c002bac5 <putchar>
c0028064:	83 c4 10             	add    $0x10,%esp
          for (; i < end; i++)
c0028067:	ff 45 ec             	incl   -0x14(%ebp)
c002806a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002806d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028070:	72 ae                	jb     c0028020 <hex_dump+0x13a>
          for (; i < per_line; i++)
c0028072:	eb 10                	jmp    c0028084 <hex_dump+0x19e>
            printf (" ");
c0028074:	83 ec 0c             	sub    $0xc,%esp
c0028077:	6a 20                	push   $0x20
c0028079:	e8 47 3a 00 00       	call   c002bac5 <putchar>
c002807e:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0028081:	ff 45 ec             	incl   -0x14(%ebp)
c0028084:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028087:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002808a:	72 e8                	jb     c0028074 <hex_dump+0x18e>
          printf ("|");
c002808c:	83 ec 0c             	sub    $0xc,%esp
c002808f:	6a 7c                	push   $0x7c
c0028091:	e8 2f 3a 00 00       	call   c002bac5 <putchar>
c0028096:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0028099:	83 ec 0c             	sub    $0xc,%esp
c002809c:	6a 0a                	push   $0xa
c002809e:	e8 22 3a 00 00       	call   c002bac5 <putchar>
c00280a3:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c00280a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00280a9:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c00280ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00280af:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c00280b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00280b5:	29 45 10             	sub    %eax,0x10(%ebp)
  while (size > 0)
c00280b8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00280bc:	0f 85 42 fe ff ff    	jne    c0027f04 <hex_dump+0x1e>
    }
}
c00280c2:	90                   	nop
c00280c3:	c9                   	leave  
c00280c4:	c3                   	ret    

c00280c5 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c00280c5:	55                   	push   %ebp
c00280c6:	89 e5                	mov    %esp,%ebp
c00280c8:	83 ec 28             	sub    $0x28,%esp
c00280cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00280ce:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c00280d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00280d4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if (size == 1)
c00280d7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c00280da:	83 f1 01             	xor    $0x1,%ecx
c00280dd:	89 c8                	mov    %ecx,%eax
c00280df:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c00280e2:	80 f5 00             	xor    $0x0,%ch
c00280e5:	89 ca                	mov    %ecx,%edx
c00280e7:	09 d0                	or     %edx,%eax
c00280e9:	85 c0                	test   %eax,%eax
c00280eb:	75 12                	jne    c00280ff <print_human_readable_size+0x3a>
    printf ("1 byte");
c00280ed:	83 ec 0c             	sub    $0xc,%esp
c00280f0:	68 a1 1b 03 c0       	push   $0xc0031ba1
c00280f5:	e8 b5 f2 ff ff       	call   c00273af <printf>
c00280fa:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c00280fd:	eb 5a                	jmp    c0028159 <print_human_readable_size+0x94>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c00280ff:	c7 45 f4 48 88 03 c0 	movl   $0xc0038848,-0xc(%ebp)
c0028106:	eb 17                	jmp    c002811f <print_human_readable_size+0x5a>
        size /= 1024;
c0028108:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002810b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002810e:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0028112:	c1 ea 0a             	shr    $0xa,%edx
c0028115:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028118:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002811b:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002811f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028123:	72 1b                	jb     c0028140 <print_human_readable_size+0x7b>
c0028125:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028129:	77 09                	ja     c0028134 <print_human_readable_size+0x6f>
c002812b:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c0028132:	76 0c                	jbe    c0028140 <print_human_readable_size+0x7b>
c0028134:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028137:	83 c0 04             	add    $0x4,%eax
c002813a:	8b 00                	mov    (%eax),%eax
c002813c:	85 c0                	test   %eax,%eax
c002813e:	75 c8                	jne    c0028108 <print_human_readable_size+0x43>
      printf ("%"PRIu64" %s", size, *fp);
c0028140:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028143:	8b 00                	mov    (%eax),%eax
c0028145:	50                   	push   %eax
c0028146:	ff 75 e4             	pushl  -0x1c(%ebp)
c0028149:	ff 75 e0             	pushl  -0x20(%ebp)
c002814c:	68 a8 1b 03 c0       	push   $0xc0031ba8
c0028151:	e8 59 f2 ff ff       	call   c00273af <printf>
c0028156:	83 c4 10             	add    $0x10,%esp
}
c0028159:	90                   	nop
c002815a:	c9                   	leave  
c002815b:	c3                   	ret    

c002815c <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c002815c:	55                   	push   %ebp
c002815d:	89 e5                	mov    %esp,%ebp
c002815f:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0028163:	7e 0d                	jle    c0028172 <isdigit+0x16>
c0028165:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0028169:	7f 07                	jg     c0028172 <isdigit+0x16>
c002816b:	b8 01 00 00 00       	mov    $0x1,%eax
c0028170:	eb 05                	jmp    c0028177 <isdigit+0x1b>
c0028172:	b8 00 00 00 00       	mov    $0x0,%eax
c0028177:	5d                   	pop    %ebp
c0028178:	c3                   	ret    

c0028179 <isspace>:
static inline int isspace (int c) {
c0028179:	55                   	push   %ebp
c002817a:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c002817c:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0028180:	74 1e                	je     c00281a0 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0028182:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0028186:	74 18                	je     c00281a0 <isspace+0x27>
c0028188:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c002818c:	74 12                	je     c00281a0 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c002818e:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0028192:	74 0c                	je     c00281a0 <isspace+0x27>
c0028194:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0028198:	74 06                	je     c00281a0 <isspace+0x27>
c002819a:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c002819e:	75 07                	jne    c00281a7 <isspace+0x2e>
c00281a0:	b8 01 00 00 00       	mov    $0x1,%eax
c00281a5:	eb 05                	jmp    c00281ac <isspace+0x33>
c00281a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00281ac:	5d                   	pop    %ebp
c00281ad:	c3                   	ret    

c00281ae <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c00281ae:	55                   	push   %ebp
c00281af:	89 e5                	mov    %esp,%ebp
c00281b1:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c00281b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00281b8:	75 21                	jne    c00281db <atoi+0x2d>
c00281ba:	83 ec 0c             	sub    $0xc,%esp
c00281bd:	68 cc 1b 03 c0       	push   $0xc0031bcc
c00281c2:	68 d6 1b 03 c0       	push   $0xc0031bd6
c00281c7:	68 34 1c 03 c0       	push   $0xc0031c34
c00281cc:	6a 0f                	push   $0xf
c00281ce:	68 ed 1b 03 c0       	push   $0xc0031bed
c00281d3:	e8 96 15 00 00       	call   c002976e <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c00281d8:	ff 45 08             	incl   0x8(%ebp)
  while (isspace ((unsigned char) *s))
c00281db:	8b 45 08             	mov    0x8(%ebp),%eax
c00281de:	8a 00                	mov    (%eax),%al
c00281e0:	0f b6 c0             	movzbl %al,%eax
c00281e3:	83 ec 0c             	sub    $0xc,%esp
c00281e6:	50                   	push   %eax
c00281e7:	e8 8d ff ff ff       	call   c0028179 <isspace>
c00281ec:	83 c4 10             	add    $0x10,%esp
c00281ef:	85 c0                	test   %eax,%eax
c00281f1:	75 e5                	jne    c00281d8 <atoi+0x2a>

  /* Parse sign. */
  negative = false;
c00281f3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c00281f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00281fa:	8a 00                	mov    (%eax),%al
c00281fc:	3c 2b                	cmp    $0x2b,%al
c00281fe:	75 05                	jne    c0028205 <atoi+0x57>
    s++;
c0028200:	ff 45 08             	incl   0x8(%ebp)
c0028203:	eb 10                	jmp    c0028215 <atoi+0x67>
  else if (*s == '-')
c0028205:	8b 45 08             	mov    0x8(%ebp),%eax
c0028208:	8a 00                	mov    (%eax),%al
c002820a:	3c 2d                	cmp    $0x2d,%al
c002820c:	75 07                	jne    c0028215 <atoi+0x67>
    {
      negative = true;
c002820e:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c0028212:	ff 45 08             	incl   0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0028215:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002821c:	eb 23                	jmp    c0028241 <atoi+0x93>
    value = value * 10 - (*s - '0');
c002821e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028221:	89 d0                	mov    %edx,%eax
c0028223:	c1 e0 02             	shl    $0x2,%eax
c0028226:	01 d0                	add    %edx,%eax
c0028228:	01 c0                	add    %eax,%eax
c002822a:	89 c2                	mov    %eax,%edx
c002822c:	8b 45 08             	mov    0x8(%ebp),%eax
c002822f:	8a 00                	mov    (%eax),%al
c0028231:	0f be c0             	movsbl %al,%eax
c0028234:	83 e8 30             	sub    $0x30,%eax
c0028237:	29 c2                	sub    %eax,%edx
c0028239:	89 d0                	mov    %edx,%eax
c002823b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (value = 0; isdigit (*s); s++)
c002823e:	ff 45 08             	incl   0x8(%ebp)
c0028241:	8b 45 08             	mov    0x8(%ebp),%eax
c0028244:	8a 00                	mov    (%eax),%al
c0028246:	0f be c0             	movsbl %al,%eax
c0028249:	83 ec 0c             	sub    $0xc,%esp
c002824c:	50                   	push   %eax
c002824d:	e8 0a ff ff ff       	call   c002815c <isdigit>
c0028252:	83 c4 10             	add    $0x10,%esp
c0028255:	85 c0                	test   %eax,%eax
c0028257:	75 c5                	jne    c002821e <atoi+0x70>
  if (!negative)
c0028259:	8a 45 f7             	mov    -0x9(%ebp),%al
c002825c:	83 f0 01             	xor    $0x1,%eax
c002825f:	84 c0                	test   %al,%al
c0028261:	74 03                	je     c0028266 <atoi+0xb8>
    value = -value;
c0028263:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c0028266:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028269:	c9                   	leave  
c002826a:	c3                   	ret    

c002826b <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c002826b:	55                   	push   %ebp
c002826c:	89 e5                	mov    %esp,%ebp
c002826e:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c0028271:	8b 45 10             	mov    0x10(%ebp),%eax
c0028274:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c0028277:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002827a:	8b 00                	mov    (%eax),%eax
c002827c:	83 ec 08             	sub    $0x8,%esp
c002827f:	ff 75 0c             	pushl  0xc(%ebp)
c0028282:	ff 75 08             	pushl  0x8(%ebp)
c0028285:	ff d0                	call   *%eax
c0028287:	83 c4 10             	add    $0x10,%esp
}
c002828a:	c9                   	leave  
c002828b:	c3                   	ret    

c002828c <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c002828c:	55                   	push   %ebp
c002828d:	89 e5                	mov    %esp,%ebp
c002828f:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c0028292:	83 ec 0c             	sub    $0xc,%esp
c0028295:	8d 45 14             	lea    0x14(%ebp),%eax
c0028298:	50                   	push   %eax
c0028299:	68 6b 82 02 c0       	push   $0xc002826b
c002829e:	ff 75 10             	pushl  0x10(%ebp)
c00282a1:	ff 75 0c             	pushl  0xc(%ebp)
c00282a4:	ff 75 08             	pushl  0x8(%ebp)
c00282a7:	e8 51 01 00 00       	call   c00283fd <sort>
c00282ac:	83 c4 20             	add    $0x20,%esp
}
c00282af:	90                   	nop
c00282b0:	c9                   	leave  
c00282b1:	c3                   	ret    

c00282b2 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00282b2:	55                   	push   %ebp
c00282b3:	89 e5                	mov    %esp,%ebp
c00282b5:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c00282b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282bb:	48                   	dec    %eax
c00282bc:	0f af 45 14          	imul   0x14(%ebp),%eax
c00282c0:	89 c2                	mov    %eax,%edx
c00282c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00282c5:	01 d0                	add    %edx,%eax
c00282c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c00282ca:	8b 45 10             	mov    0x10(%ebp),%eax
c00282cd:	48                   	dec    %eax
c00282ce:	0f af 45 14          	imul   0x14(%ebp),%eax
c00282d2:	89 c2                	mov    %eax,%edx
c00282d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00282d7:	01 d0                	add    %edx,%eax
c00282d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c00282dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00282e3:	eb 31                	jmp    c0028316 <do_swap+0x64>
    {
      unsigned char t = a[i];
c00282e5:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00282e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00282eb:	01 d0                	add    %edx,%eax
c00282ed:	8a 00                	mov    (%eax),%al
c00282ef:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c00282f2:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00282f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00282f8:	01 c2                	add    %eax,%edx
c00282fa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00282fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028300:	01 c8                	add    %ecx,%eax
c0028302:	8a 00                	mov    (%eax),%al
c0028304:	88 02                	mov    %al,(%edx)
      b[i] = t;
c0028306:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028309:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002830c:	01 c2                	add    %eax,%edx
c002830e:	8a 45 f3             	mov    -0xd(%ebp),%al
c0028311:	88 02                	mov    %al,(%edx)
  for (i = 0; i < size; i++)
c0028313:	ff 45 fc             	incl   -0x4(%ebp)
c0028316:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028319:	3b 45 14             	cmp    0x14(%ebp),%eax
c002831c:	72 c7                	jb     c00282e5 <do_swap+0x33>
    }
}
c002831e:	90                   	nop
c002831f:	c9                   	leave  
c0028320:	c3                   	ret    

c0028321 <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c0028321:	55                   	push   %ebp
c0028322:	89 e5                	mov    %esp,%ebp
c0028324:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028327:	8b 45 10             	mov    0x10(%ebp),%eax
c002832a:	48                   	dec    %eax
c002832b:	0f af 45 14          	imul   0x14(%ebp),%eax
c002832f:	89 c2                	mov    %eax,%edx
c0028331:	8b 45 08             	mov    0x8(%ebp),%eax
c0028334:	01 c2                	add    %eax,%edx
c0028336:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028339:	48                   	dec    %eax
c002833a:	0f af 45 14          	imul   0x14(%ebp),%eax
c002833e:	89 c1                	mov    %eax,%ecx
c0028340:	8b 45 08             	mov    0x8(%ebp),%eax
c0028343:	01 c8                	add    %ecx,%eax
c0028345:	83 ec 04             	sub    $0x4,%esp
c0028348:	ff 75 1c             	pushl  0x1c(%ebp)
c002834b:	52                   	push   %edx
c002834c:	50                   	push   %eax
c002834d:	8b 45 18             	mov    0x18(%ebp),%eax
c0028350:	ff d0                	call   *%eax
c0028352:	83 c4 10             	add    $0x10,%esp
}
c0028355:	c9                   	leave  
c0028356:	c3                   	ret    

c0028357 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0028357:	55                   	push   %ebp
c0028358:	89 e5                	mov    %esp,%ebp
c002835a:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c002835d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028360:	01 c0                	add    %eax,%eax
c0028362:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c0028365:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028368:	01 c0                	add    %eax,%eax
c002836a:	40                   	inc    %eax
c002836b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c002836e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028371:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c0028374:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028377:	3b 45 10             	cmp    0x10(%ebp),%eax
c002837a:	77 27                	ja     c00283a3 <heapify+0x4c>
c002837c:	83 ec 08             	sub    $0x8,%esp
c002837f:	ff 75 1c             	pushl  0x1c(%ebp)
c0028382:	ff 75 18             	pushl  0x18(%ebp)
c0028385:	ff 75 14             	pushl  0x14(%ebp)
c0028388:	ff 75 f4             	pushl  -0xc(%ebp)
c002838b:	ff 75 f0             	pushl  -0x10(%ebp)
c002838e:	ff 75 08             	pushl  0x8(%ebp)
c0028391:	e8 8b ff ff ff       	call   c0028321 <do_compare>
c0028396:	83 c4 20             	add    $0x20,%esp
c0028399:	85 c0                	test   %eax,%eax
c002839b:	7e 06                	jle    c00283a3 <heapify+0x4c>
        max = left;
c002839d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00283a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c00283a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283a6:	3b 45 10             	cmp    0x10(%ebp),%eax
c00283a9:	77 27                	ja     c00283d2 <heapify+0x7b>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c00283ab:	83 ec 08             	sub    $0x8,%esp
c00283ae:	ff 75 1c             	pushl  0x1c(%ebp)
c00283b1:	ff 75 18             	pushl  0x18(%ebp)
c00283b4:	ff 75 14             	pushl  0x14(%ebp)
c00283b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00283ba:	ff 75 ec             	pushl  -0x14(%ebp)
c00283bd:	ff 75 08             	pushl  0x8(%ebp)
c00283c0:	e8 5c ff ff ff       	call   c0028321 <do_compare>
c00283c5:	83 c4 20             	add    $0x20,%esp
c00283c8:	85 c0                	test   %eax,%eax
c00283ca:	7e 06                	jle    c00283d2 <heapify+0x7b>
        max = right;
c00283cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283cf:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c00283d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00283d8:	74 1f                	je     c00283f9 <heapify+0xa2>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c00283da:	ff 75 14             	pushl  0x14(%ebp)
c00283dd:	ff 75 f4             	pushl  -0xc(%ebp)
c00283e0:	ff 75 0c             	pushl  0xc(%ebp)
c00283e3:	ff 75 08             	pushl  0x8(%ebp)
c00283e6:	e8 c7 fe ff ff       	call   c00282b2 <do_swap>
c00283eb:	83 c4 10             	add    $0x10,%esp
      i = max;
c00283ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283f1:	89 45 0c             	mov    %eax,0xc(%ebp)
    {
c00283f4:	e9 64 ff ff ff       	jmp    c002835d <heapify+0x6>
        break;
c00283f9:	90                   	nop
    }
}
c00283fa:	90                   	nop
c00283fb:	c9                   	leave  
c00283fc:	c3                   	ret    

c00283fd <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c00283fd:	55                   	push   %ebp
c00283fe:	89 e5                	mov    %esp,%ebp
c0028400:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c0028403:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028407:	75 27                	jne    c0028430 <sort+0x33>
c0028409:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002840d:	74 21                	je     c0028430 <sort+0x33>
c002840f:	83 ec 0c             	sub    $0xc,%esp
c0028412:	68 00 1c 03 c0       	push   $0xc0031c00
c0028417:	68 d6 1b 03 c0       	push   $0xc0031bd6
c002841c:	68 3c 1c 03 c0       	push   $0xc0031c3c
c0028421:	68 8a 00 00 00       	push   $0x8a
c0028426:	68 ed 1b 03 c0       	push   $0xc0031bed
c002842b:	e8 3e 13 00 00       	call   c002976e <debug_panic>
  ASSERT (compare != NULL);
c0028430:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0028434:	75 21                	jne    c0028457 <sort+0x5a>
c0028436:	83 ec 0c             	sub    $0xc,%esp
c0028439:	68 1a 1c 03 c0       	push   $0xc0031c1a
c002843e:	68 d6 1b 03 c0       	push   $0xc0031bd6
c0028443:	68 3c 1c 03 c0       	push   $0xc0031c3c
c0028448:	68 8b 00 00 00       	push   $0x8b
c002844d:	68 ed 1b 03 c0       	push   $0xc0031bed
c0028452:	e8 17 13 00 00       	call   c002976e <debug_panic>
  ASSERT (size > 0);
c0028457:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002845b:	75 21                	jne    c002847e <sort+0x81>
c002845d:	83 ec 0c             	sub    $0xc,%esp
c0028460:	68 2a 1c 03 c0       	push   $0xc0031c2a
c0028465:	68 d6 1b 03 c0       	push   $0xc0031bd6
c002846a:	68 3c 1c 03 c0       	push   $0xc0031c3c
c002846f:	68 8c 00 00 00       	push   $0x8c
c0028474:	68 ed 1b 03 c0       	push   $0xc0031bed
c0028479:	e8 f0 12 00 00       	call   c002976e <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c002847e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028481:	d1 e8                	shr    %eax
c0028483:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028486:	eb 20                	jmp    c00284a8 <sort+0xab>
    heapify (array, i, cnt, size, compare, aux);
c0028488:	83 ec 08             	sub    $0x8,%esp
c002848b:	ff 75 18             	pushl  0x18(%ebp)
c002848e:	ff 75 14             	pushl  0x14(%ebp)
c0028491:	ff 75 10             	pushl  0x10(%ebp)
c0028494:	ff 75 0c             	pushl  0xc(%ebp)
c0028497:	ff 75 f4             	pushl  -0xc(%ebp)
c002849a:	ff 75 08             	pushl  0x8(%ebp)
c002849d:	e8 b5 fe ff ff       	call   c0028357 <heapify>
c00284a2:	83 c4 20             	add    $0x20,%esp
  for (i = cnt / 2; i > 0; i--)
c00284a5:	ff 4d f4             	decl   -0xc(%ebp)
c00284a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00284ac:	75 da                	jne    c0028488 <sort+0x8b>

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c00284ae:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00284b4:	eb 34                	jmp    c00284ea <sort+0xed>
    {
      do_swap (array, 1, i, size);
c00284b6:	ff 75 10             	pushl  0x10(%ebp)
c00284b9:	ff 75 f4             	pushl  -0xc(%ebp)
c00284bc:	6a 01                	push   $0x1
c00284be:	ff 75 08             	pushl  0x8(%ebp)
c00284c1:	e8 ec fd ff ff       	call   c00282b2 <do_swap>
c00284c6:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c00284c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00284cc:	48                   	dec    %eax
c00284cd:	83 ec 08             	sub    $0x8,%esp
c00284d0:	ff 75 18             	pushl  0x18(%ebp)
c00284d3:	ff 75 14             	pushl  0x14(%ebp)
c00284d6:	ff 75 10             	pushl  0x10(%ebp)
c00284d9:	50                   	push   %eax
c00284da:	6a 01                	push   $0x1
c00284dc:	ff 75 08             	pushl  0x8(%ebp)
c00284df:	e8 73 fe ff ff       	call   c0028357 <heapify>
c00284e4:	83 c4 20             	add    $0x20,%esp
  for (i = cnt; i > 1; i--) 
c00284e7:	ff 4d f4             	decl   -0xc(%ebp)
c00284ea:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00284ee:	77 c6                	ja     c00284b6 <sort+0xb9>
    }
}
c00284f0:	90                   	nop
c00284f1:	c9                   	leave  
c00284f2:	c3                   	ret    

c00284f3 <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c00284f3:	55                   	push   %ebp
c00284f4:	89 e5                	mov    %esp,%ebp
c00284f6:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00284f9:	83 ec 08             	sub    $0x8,%esp
c00284fc:	8d 45 18             	lea    0x18(%ebp),%eax
c00284ff:	50                   	push   %eax
c0028500:	68 6b 82 02 c0       	push   $0xc002826b
c0028505:	ff 75 14             	pushl  0x14(%ebp)
c0028508:	ff 75 10             	pushl  0x10(%ebp)
c002850b:	ff 75 0c             	pushl  0xc(%ebp)
c002850e:	ff 75 08             	pushl  0x8(%ebp)
c0028511:	e8 05 00 00 00       	call   c002851b <binary_search>
c0028516:	83 c4 20             	add    $0x20,%esp
}
c0028519:	c9                   	leave  
c002851a:	c3                   	ret    

c002851b <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c002851b:	55                   	push   %ebp
c002851c:	89 e5                	mov    %esp,%ebp
c002851e:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c0028521:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028524:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c0028527:	8b 45 14             	mov    0x14(%ebp),%eax
c002852a:	0f af 45 10          	imul   0x10(%ebp),%eax
c002852e:	89 c2                	mov    %eax,%edx
c0028530:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028533:	01 d0                	add    %edx,%eax
c0028535:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c0028538:	eb 65                	jmp    c002859f <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c002853a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002853d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028540:	29 c2                	sub    %eax,%edx
c0028542:	89 d0                	mov    %edx,%eax
c0028544:	ba 00 00 00 00       	mov    $0x0,%edx
c0028549:	f7 75 14             	divl   0x14(%ebp)
c002854c:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c002854f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028552:	d1 e8                	shr    %eax
c0028554:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028558:	89 c2                	mov    %eax,%edx
c002855a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002855d:	01 d0                	add    %edx,%eax
c002855f:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c0028562:	83 ec 04             	sub    $0x4,%esp
c0028565:	ff 75 1c             	pushl  0x1c(%ebp)
c0028568:	ff 75 e8             	pushl  -0x18(%ebp)
c002856b:	ff 75 08             	pushl  0x8(%ebp)
c002856e:	8b 45 18             	mov    0x18(%ebp),%eax
c0028571:	ff d0                	call   *%eax
c0028573:	83 c4 10             	add    $0x10,%esp
c0028576:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c0028579:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002857d:	79 08                	jns    c0028587 <binary_search+0x6c>
        last = middle;
c002857f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028582:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028585:	eb 18                	jmp    c002859f <binary_search+0x84>
      else if (cmp > 0) 
c0028587:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002858b:	7e 0d                	jle    c002859a <binary_search+0x7f>
        first = middle + size;
c002858d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0028590:	8b 45 14             	mov    0x14(%ebp),%eax
c0028593:	01 d0                	add    %edx,%eax
c0028595:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028598:	eb 05                	jmp    c002859f <binary_search+0x84>
      else
        return (void *) middle;
c002859a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002859d:	eb 0d                	jmp    c00285ac <binary_search+0x91>
  while (first < last) 
c002859f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285a2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00285a5:	72 93                	jb     c002853a <binary_search+0x1f>
    }
  
  return NULL;
c00285a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00285ac:	c9                   	leave  
c00285ad:	c3                   	ret    

c00285ae <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c00285ae:	55                   	push   %ebp
c00285af:	89 e5                	mov    %esp,%ebp
c00285b1:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c00285b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00285b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c00285ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00285bd:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c00285c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00285c4:	75 24                	jne    c00285ea <memcpy+0x3c>
c00285c6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00285ca:	74 1e                	je     c00285ea <memcpy+0x3c>
c00285cc:	83 ec 0c             	sub    $0xc,%esp
c00285cf:	68 44 1c 03 c0       	push   $0xc0031c44
c00285d4:	68 5d 1c 03 c0       	push   $0xc0031c5d
c00285d9:	68 54 1d 03 c0       	push   $0xc0031d54
c00285de:	6a 0c                	push   $0xc
c00285e0:	68 74 1c 03 c0       	push   $0xc0031c74
c00285e5:	e8 84 11 00 00       	call   c002976e <debug_panic>
  ASSERT (src != NULL || size == 0);
c00285ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00285ee:	75 3a                	jne    c002862a <memcpy+0x7c>
c00285f0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00285f4:	74 34                	je     c002862a <memcpy+0x7c>
c00285f6:	83 ec 0c             	sub    $0xc,%esp
c00285f9:	68 87 1c 03 c0       	push   $0xc0031c87
c00285fe:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028603:	68 54 1d 03 c0       	push   $0xc0031d54
c0028608:	6a 0d                	push   $0xd
c002860a:	68 74 1c 03 c0       	push   $0xc0031c74
c002860f:	e8 5a 11 00 00       	call   c002976e <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c0028614:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028617:	8d 50 01             	lea    0x1(%eax),%edx
c002861a:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002861d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028620:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028623:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028626:	8a 12                	mov    (%edx),%dl
c0028628:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c002862a:	8b 45 10             	mov    0x10(%ebp),%eax
c002862d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028630:	89 55 10             	mov    %edx,0x10(%ebp)
c0028633:	85 c0                	test   %eax,%eax
c0028635:	75 dd                	jne    c0028614 <memcpy+0x66>

  return dst_;
c0028637:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002863a:	c9                   	leave  
c002863b:	c3                   	ret    

c002863c <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c002863c:	55                   	push   %ebp
c002863d:	89 e5                	mov    %esp,%ebp
c002863f:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028642:	8b 45 08             	mov    0x8(%ebp),%eax
c0028645:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028648:	8b 45 0c             	mov    0xc(%ebp),%eax
c002864b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c002864e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028652:	75 24                	jne    c0028678 <memmove+0x3c>
c0028654:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028658:	74 1e                	je     c0028678 <memmove+0x3c>
c002865a:	83 ec 0c             	sub    $0xc,%esp
c002865d:	68 44 1c 03 c0       	push   $0xc0031c44
c0028662:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028667:	68 5c 1d 03 c0       	push   $0xc0031d5c
c002866c:	6a 1d                	push   $0x1d
c002866e:	68 74 1c 03 c0       	push   $0xc0031c74
c0028673:	e8 f6 10 00 00       	call   c002976e <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028678:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002867c:	75 24                	jne    c00286a2 <memmove+0x66>
c002867e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028682:	74 1e                	je     c00286a2 <memmove+0x66>
c0028684:	83 ec 0c             	sub    $0xc,%esp
c0028687:	68 87 1c 03 c0       	push   $0xc0031c87
c002868c:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028691:	68 5c 1d 03 c0       	push   $0xc0031d5c
c0028696:	6a 1e                	push   $0x1e
c0028698:	68 74 1c 03 c0       	push   $0xc0031c74
c002869d:	e8 cc 10 00 00       	call   c002976e <debug_panic>

  if (dst < src) 
c00286a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286a5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00286a8:	73 27                	jae    c00286d1 <memmove+0x95>
    {
      while (size-- > 0)
c00286aa:	eb 16                	jmp    c00286c2 <memmove+0x86>
        *dst++ = *src++;
c00286ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286af:	8d 50 01             	lea    0x1(%eax),%edx
c00286b2:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00286b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00286b8:	8d 4a 01             	lea    0x1(%edx),%ecx
c00286bb:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c00286be:	8a 12                	mov    (%edx),%dl
c00286c0:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c00286c2:	8b 45 10             	mov    0x10(%ebp),%eax
c00286c5:	8d 50 ff             	lea    -0x1(%eax),%edx
c00286c8:	89 55 10             	mov    %edx,0x10(%ebp)
c00286cb:	85 c0                	test   %eax,%eax
c00286cd:	75 dd                	jne    c00286ac <memmove+0x70>
c00286cf:	eb 2b                	jmp    c00286fc <memmove+0xc0>
    }
  else 
    {
      dst += size;
c00286d1:	8b 45 10             	mov    0x10(%ebp),%eax
c00286d4:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c00286d7:	8b 45 10             	mov    0x10(%ebp),%eax
c00286da:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c00286dd:	eb 10                	jmp    c00286ef <memmove+0xb3>
        *--dst = *--src;
c00286df:	ff 4d f4             	decl   -0xc(%ebp)
c00286e2:	ff 4d f0             	decl   -0x10(%ebp)
c00286e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00286e8:	8a 10                	mov    (%eax),%dl
c00286ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286ed:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c00286ef:	8b 45 10             	mov    0x10(%ebp),%eax
c00286f2:	8d 50 ff             	lea    -0x1(%eax),%edx
c00286f5:	89 55 10             	mov    %edx,0x10(%ebp)
c00286f8:	85 c0                	test   %eax,%eax
c00286fa:	75 e3                	jne    c00286df <memmove+0xa3>
    }

  return dst;
c00286fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00286ff:	c9                   	leave  
c0028700:	c3                   	ret    

c0028701 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028701:	55                   	push   %ebp
c0028702:	89 e5                	mov    %esp,%ebp
c0028704:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c0028707:	8b 45 08             	mov    0x8(%ebp),%eax
c002870a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c002870d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028710:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c0028713:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028717:	75 24                	jne    c002873d <memcmp+0x3c>
c0028719:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002871d:	74 1e                	je     c002873d <memcmp+0x3c>
c002871f:	83 ec 0c             	sub    $0xc,%esp
c0028722:	68 a0 1c 03 c0       	push   $0xc0031ca0
c0028727:	68 5d 1c 03 c0       	push   $0xc0031c5d
c002872c:	68 64 1d 03 c0       	push   $0xc0031d64
c0028731:	6a 3a                	push   $0x3a
c0028733:	68 74 1c 03 c0       	push   $0xc0031c74
c0028738:	e8 31 10 00 00       	call   c002976e <debug_panic>
  ASSERT (b != NULL || size == 0);
c002873d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028741:	75 54                	jne    c0028797 <memcmp+0x96>
c0028743:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028747:	74 4e                	je     c0028797 <memcmp+0x96>
c0028749:	83 ec 0c             	sub    $0xc,%esp
c002874c:	68 b7 1c 03 c0       	push   $0xc0031cb7
c0028751:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028756:	68 64 1d 03 c0       	push   $0xc0031d64
c002875b:	6a 3b                	push   $0x3b
c002875d:	68 74 1c 03 c0       	push   $0xc0031c74
c0028762:	e8 07 10 00 00       	call   c002976e <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028767:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002876a:	8a 10                	mov    (%eax),%dl
c002876c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002876f:	8a 00                	mov    (%eax),%al
c0028771:	38 c2                	cmp    %al,%dl
c0028773:	74 1c                	je     c0028791 <memcmp+0x90>
      return *a > *b ? +1 : -1;
c0028775:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028778:	8a 10                	mov    (%eax),%dl
c002877a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002877d:	8a 00                	mov    (%eax),%al
c002877f:	38 c2                	cmp    %al,%dl
c0028781:	76 07                	jbe    c002878a <memcmp+0x89>
c0028783:	b8 01 00 00 00       	mov    $0x1,%eax
c0028788:	eb 1f                	jmp    c00287a9 <memcmp+0xa8>
c002878a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002878f:	eb 18                	jmp    c00287a9 <memcmp+0xa8>
  for (; size-- > 0; a++, b++)
c0028791:	ff 45 f4             	incl   -0xc(%ebp)
c0028794:	ff 45 f0             	incl   -0x10(%ebp)
c0028797:	8b 45 10             	mov    0x10(%ebp),%eax
c002879a:	8d 50 ff             	lea    -0x1(%eax),%edx
c002879d:	89 55 10             	mov    %edx,0x10(%ebp)
c00287a0:	85 c0                	test   %eax,%eax
c00287a2:	75 c3                	jne    c0028767 <memcmp+0x66>
  return 0;
c00287a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00287a9:	c9                   	leave  
c00287aa:	c3                   	ret    

c00287ab <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c00287ab:	55                   	push   %ebp
c00287ac:	89 e5                	mov    %esp,%ebp
c00287ae:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c00287b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00287b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c00287b7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00287ba:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c00287bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00287c1:	75 1e                	jne    c00287e1 <strcmp+0x36>
c00287c3:	83 ec 0c             	sub    $0xc,%esp
c00287c6:	68 ce 1c 03 c0       	push   $0xc0031cce
c00287cb:	68 5d 1c 03 c0       	push   $0xc0031c5d
c00287d0:	68 6c 1d 03 c0       	push   $0xc0031d6c
c00287d5:	6a 4e                	push   $0x4e
c00287d7:	68 74 1c 03 c0       	push   $0xc0031c74
c00287dc:	e8 8d 0f 00 00       	call   c002976e <debug_panic>
  ASSERT (b != NULL);
c00287e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00287e5:	75 24                	jne    c002880b <strcmp+0x60>
c00287e7:	83 ec 0c             	sub    $0xc,%esp
c00287ea:	68 d8 1c 03 c0       	push   $0xc0031cd8
c00287ef:	68 5d 1c 03 c0       	push   $0xc0031c5d
c00287f4:	68 6c 1d 03 c0       	push   $0xc0031d6c
c00287f9:	6a 4f                	push   $0x4f
c00287fb:	68 74 1c 03 c0       	push   $0xc0031c74
c0028800:	e8 69 0f 00 00       	call   c002976e <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c0028805:	ff 45 f4             	incl   -0xc(%ebp)
      b++;
c0028808:	ff 45 f0             	incl   -0x10(%ebp)
  while (*a != '\0' && *a == *b) 
c002880b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002880e:	8a 00                	mov    (%eax),%al
c0028810:	84 c0                	test   %al,%al
c0028812:	74 0e                	je     c0028822 <strcmp+0x77>
c0028814:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028817:	8a 10                	mov    (%eax),%dl
c0028819:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002881c:	8a 00                	mov    (%eax),%al
c002881e:	38 c2                	cmp    %al,%dl
c0028820:	74 e3                	je     c0028805 <strcmp+0x5a>
    }

  return *a < *b ? -1 : *a > *b;
c0028822:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028825:	8a 10                	mov    (%eax),%dl
c0028827:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002882a:	8a 00                	mov    (%eax),%al
c002882c:	38 c2                	cmp    %al,%dl
c002882e:	72 14                	jb     c0028844 <strcmp+0x99>
c0028830:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028833:	8a 10                	mov    (%eax),%dl
c0028835:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028838:	8a 00                	mov    (%eax),%al
c002883a:	38 c2                	cmp    %al,%dl
c002883c:	0f 97 c0             	seta   %al
c002883f:	0f b6 c0             	movzbl %al,%eax
c0028842:	eb 05                	jmp    c0028849 <strcmp+0x9e>
c0028844:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028849:	c9                   	leave  
c002884a:	c3                   	ret    

c002884b <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c002884b:	55                   	push   %ebp
c002884c:	89 e5                	mov    %esp,%ebp
c002884e:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c0028851:	8b 45 08             	mov    0x8(%ebp),%eax
c0028854:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028857:	8b 45 0c             	mov    0xc(%ebp),%eax
c002885a:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c002885d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028861:	75 36                	jne    c0028899 <memchr+0x4e>
c0028863:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028867:	74 30                	je     c0028899 <memchr+0x4e>
c0028869:	83 ec 0c             	sub    $0xc,%esp
c002886c:	68 e2 1c 03 c0       	push   $0xc0031ce2
c0028871:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028876:	68 74 1d 03 c0       	push   $0xc0031d74
c002887b:	6a 63                	push   $0x63
c002887d:	68 74 1c 03 c0       	push   $0xc0031c74
c0028882:	e8 e7 0e 00 00       	call   c002976e <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0028887:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002888a:	8a 00                	mov    (%eax),%al
c002888c:	3a 45 f3             	cmp    -0xd(%ebp),%al
c002888f:	75 05                	jne    c0028896 <memchr+0x4b>
      return (void *) block;
c0028891:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028894:	eb 15                	jmp    c00288ab <memchr+0x60>
  for (; size-- > 0; block++)
c0028896:	ff 45 f4             	incl   -0xc(%ebp)
c0028899:	8b 45 10             	mov    0x10(%ebp),%eax
c002889c:	8d 50 ff             	lea    -0x1(%eax),%edx
c002889f:	89 55 10             	mov    %edx,0x10(%ebp)
c00288a2:	85 c0                	test   %eax,%eax
c00288a4:	75 e1                	jne    c0028887 <memchr+0x3c>

  return NULL;
c00288a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00288ab:	c9                   	leave  
c00288ac:	c3                   	ret    

c00288ad <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c00288ad:	55                   	push   %ebp
c00288ae:	89 e5                	mov    %esp,%ebp
c00288b0:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c00288b3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00288b6:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c00288b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00288bd:	75 1e                	jne    c00288dd <strchr+0x30>
c00288bf:	83 ec 0c             	sub    $0xc,%esp
c00288c2:	68 fd 1c 03 c0       	push   $0xc0031cfd
c00288c7:	68 5d 1c 03 c0       	push   $0xc0031c5d
c00288cc:	68 7c 1d 03 c0       	push   $0xc0031d7c
c00288d1:	6a 75                	push   $0x75
c00288d3:	68 74 1c 03 c0       	push   $0xc0031c74
c00288d8:	e8 91 0e 00 00       	call   c002976e <debug_panic>

  for (;;) 
    if (*string == c)
c00288dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00288e0:	8a 00                	mov    (%eax),%al
c00288e2:	3a 45 f7             	cmp    -0x9(%ebp),%al
c00288e5:	75 05                	jne    c00288ec <strchr+0x3f>
      return (char *) string;
c00288e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00288ea:	eb 15                	jmp    c0028901 <strchr+0x54>
    else if (*string == '\0')
c00288ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00288ef:	8a 00                	mov    (%eax),%al
c00288f1:	84 c0                	test   %al,%al
c00288f3:	75 07                	jne    c00288fc <strchr+0x4f>
      return NULL;
c00288f5:	b8 00 00 00 00       	mov    $0x0,%eax
c00288fa:	eb 05                	jmp    c0028901 <strchr+0x54>
    else
      string++;
c00288fc:	ff 45 08             	incl   0x8(%ebp)
    if (*string == c)
c00288ff:	eb dc                	jmp    c00288dd <strchr+0x30>
}
c0028901:	c9                   	leave  
c0028902:	c3                   	ret    

c0028903 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0028903:	55                   	push   %ebp
c0028904:	89 e5                	mov    %esp,%ebp
c0028906:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028909:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028910:	eb 23                	jmp    c0028935 <strcspn+0x32>
    if (strchr (stop, string[length]) != NULL)
c0028912:	8b 55 08             	mov    0x8(%ebp),%edx
c0028915:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028918:	01 d0                	add    %edx,%eax
c002891a:	8a 00                	mov    (%eax),%al
c002891c:	0f be c0             	movsbl %al,%eax
c002891f:	83 ec 08             	sub    $0x8,%esp
c0028922:	50                   	push   %eax
c0028923:	ff 75 0c             	pushl  0xc(%ebp)
c0028926:	e8 82 ff ff ff       	call   c00288ad <strchr>
c002892b:	83 c4 10             	add    $0x10,%esp
c002892e:	85 c0                	test   %eax,%eax
c0028930:	75 13                	jne    c0028945 <strcspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c0028932:	ff 45 f4             	incl   -0xc(%ebp)
c0028935:	8b 55 08             	mov    0x8(%ebp),%edx
c0028938:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002893b:	01 d0                	add    %edx,%eax
c002893d:	8a 00                	mov    (%eax),%al
c002893f:	84 c0                	test   %al,%al
c0028941:	75 cf                	jne    c0028912 <strcspn+0xf>
c0028943:	eb 01                	jmp    c0028946 <strcspn+0x43>
      break;
c0028945:	90                   	nop
  return length;
c0028946:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028949:	c9                   	leave  
c002894a:	c3                   	ret    

c002894b <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c002894b:	55                   	push   %ebp
c002894c:	89 e5                	mov    %esp,%ebp
c002894e:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c0028951:	eb 23                	jmp    c0028976 <strpbrk+0x2b>
    if (strchr (stop, *string) != NULL)
c0028953:	8b 45 08             	mov    0x8(%ebp),%eax
c0028956:	8a 00                	mov    (%eax),%al
c0028958:	0f be c0             	movsbl %al,%eax
c002895b:	83 ec 08             	sub    $0x8,%esp
c002895e:	50                   	push   %eax
c002895f:	ff 75 0c             	pushl  0xc(%ebp)
c0028962:	e8 46 ff ff ff       	call   c00288ad <strchr>
c0028967:	83 c4 10             	add    $0x10,%esp
c002896a:	85 c0                	test   %eax,%eax
c002896c:	74 05                	je     c0028973 <strpbrk+0x28>
      return (char *) string;
c002896e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028971:	eb 11                	jmp    c0028984 <strpbrk+0x39>
  for (; *string != '\0'; string++)
c0028973:	ff 45 08             	incl   0x8(%ebp)
c0028976:	8b 45 08             	mov    0x8(%ebp),%eax
c0028979:	8a 00                	mov    (%eax),%al
c002897b:	84 c0                	test   %al,%al
c002897d:	75 d4                	jne    c0028953 <strpbrk+0x8>
  return NULL;
c002897f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028984:	c9                   	leave  
c0028985:	c3                   	ret    

c0028986 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028986:	55                   	push   %ebp
c0028987:	89 e5                	mov    %esp,%ebp
c0028989:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c002898c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002898f:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0028992:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c0028999:	eb 13                	jmp    c00289ae <strrchr+0x28>
    if (*string == c)
c002899b:	8b 45 08             	mov    0x8(%ebp),%eax
c002899e:	8a 00                	mov    (%eax),%al
c00289a0:	3a 45 fb             	cmp    -0x5(%ebp),%al
c00289a3:	75 06                	jne    c00289ab <strrchr+0x25>
      p = string;
c00289a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00289a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (; *string != '\0'; string++)
c00289ab:	ff 45 08             	incl   0x8(%ebp)
c00289ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00289b1:	8a 00                	mov    (%eax),%al
c00289b3:	84 c0                	test   %al,%al
c00289b5:	75 e4                	jne    c002899b <strrchr+0x15>
  return (char *) p;
c00289b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00289ba:	c9                   	leave  
c00289bb:	c3                   	ret    

c00289bc <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c00289bc:	55                   	push   %ebp
c00289bd:	89 e5                	mov    %esp,%ebp
c00289bf:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c00289c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00289c9:	eb 23                	jmp    c00289ee <strspn+0x32>
    if (strchr (skip, string[length]) == NULL)
c00289cb:	8b 55 08             	mov    0x8(%ebp),%edx
c00289ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289d1:	01 d0                	add    %edx,%eax
c00289d3:	8a 00                	mov    (%eax),%al
c00289d5:	0f be c0             	movsbl %al,%eax
c00289d8:	83 ec 08             	sub    $0x8,%esp
c00289db:	50                   	push   %eax
c00289dc:	ff 75 0c             	pushl  0xc(%ebp)
c00289df:	e8 c9 fe ff ff       	call   c00288ad <strchr>
c00289e4:	83 c4 10             	add    $0x10,%esp
c00289e7:	85 c0                	test   %eax,%eax
c00289e9:	74 13                	je     c00289fe <strspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c00289eb:	ff 45 f4             	incl   -0xc(%ebp)
c00289ee:	8b 55 08             	mov    0x8(%ebp),%edx
c00289f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289f4:	01 d0                	add    %edx,%eax
c00289f6:	8a 00                	mov    (%eax),%al
c00289f8:	84 c0                	test   %al,%al
c00289fa:	75 cf                	jne    c00289cb <strspn+0xf>
c00289fc:	eb 01                	jmp    c00289ff <strspn+0x43>
      break;
c00289fe:	90                   	nop
  return length;
c00289ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028a02:	c9                   	leave  
c0028a03:	c3                   	ret    

c0028a04 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c0028a04:	55                   	push   %ebp
c0028a05:	89 e5                	mov    %esp,%ebp
c0028a07:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c0028a0a:	83 ec 0c             	sub    $0xc,%esp
c0028a0d:	ff 75 08             	pushl  0x8(%ebp)
c0028a10:	e8 cc 01 00 00       	call   c0028be1 <strlen>
c0028a15:	83 c4 10             	add    $0x10,%esp
c0028a18:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c0028a1b:	83 ec 0c             	sub    $0xc,%esp
c0028a1e:	ff 75 0c             	pushl  0xc(%ebp)
c0028a21:	e8 bb 01 00 00       	call   c0028be1 <strlen>
c0028a26:	83 c4 10             	add    $0x10,%esp
c0028a29:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c0028a2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a2f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0028a32:	72 3f                	jb     c0028a73 <strstr+0x6f>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0028a34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028a3b:	eb 2b                	jmp    c0028a68 <strstr+0x64>
        if (!memcmp (haystack + i, needle, needle_len))
c0028a3d:	8b 55 08             	mov    0x8(%ebp),%edx
c0028a40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a43:	01 d0                	add    %edx,%eax
c0028a45:	83 ec 04             	sub    $0x4,%esp
c0028a48:	ff 75 ec             	pushl  -0x14(%ebp)
c0028a4b:	ff 75 0c             	pushl  0xc(%ebp)
c0028a4e:	50                   	push   %eax
c0028a4f:	e8 ad fc ff ff       	call   c0028701 <memcmp>
c0028a54:	83 c4 10             	add    $0x10,%esp
c0028a57:	85 c0                	test   %eax,%eax
c0028a59:	75 0a                	jne    c0028a65 <strstr+0x61>
          return (char *) haystack + i;
c0028a5b:	8b 55 08             	mov    0x8(%ebp),%edx
c0028a5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a61:	01 d0                	add    %edx,%eax
c0028a63:	eb 13                	jmp    c0028a78 <strstr+0x74>
      for (i = 0; i <= haystack_len - needle_len; i++)
c0028a65:	ff 45 f4             	incl   -0xc(%ebp)
c0028a68:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a6b:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028a6e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028a71:	73 ca                	jae    c0028a3d <strstr+0x39>
    }

  return NULL;
c0028a73:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028a78:	c9                   	leave  
c0028a79:	c3                   	ret    

c0028a7a <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028a7a:	55                   	push   %ebp
c0028a7b:	89 e5                	mov    %esp,%ebp
c0028a7d:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0028a80:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028a84:	75 21                	jne    c0028aa7 <strtok_r+0x2d>
c0028a86:	83 ec 0c             	sub    $0xc,%esp
c0028a89:	68 0c 1d 03 c0       	push   $0xc0031d0c
c0028a8e:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028a93:	68 84 1d 03 c0       	push   $0xc0031d84
c0028a98:	68 ef 00 00 00       	push   $0xef
c0028a9d:	68 74 1c 03 c0       	push   $0xc0031c74
c0028aa2:	e8 c7 0c 00 00       	call   c002976e <debug_panic>
  ASSERT (save_ptr != NULL);
c0028aa7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028aab:	75 21                	jne    c0028ace <strtok_r+0x54>
c0028aad:	83 ec 0c             	sub    $0xc,%esp
c0028ab0:	68 1f 1d 03 c0       	push   $0xc0031d1f
c0028ab5:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028aba:	68 84 1d 03 c0       	push   $0xc0031d84
c0028abf:	68 f0 00 00 00       	push   $0xf0
c0028ac4:	68 74 1c 03 c0       	push   $0xc0031c74
c0028ac9:	e8 a0 0c 00 00       	call   c002976e <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028ace:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028ad2:	75 08                	jne    c0028adc <strtok_r+0x62>
    s = *save_ptr;
c0028ad4:	8b 45 10             	mov    0x10(%ebp),%eax
c0028ad7:	8b 00                	mov    (%eax),%eax
c0028ad9:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c0028adc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028ae0:	75 3c                	jne    c0028b1e <strtok_r+0xa4>
c0028ae2:	83 ec 0c             	sub    $0xc,%esp
c0028ae5:	68 30 1d 03 c0       	push   $0xc0031d30
c0028aea:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028aef:	68 84 1d 03 c0       	push   $0xc0031d84
c0028af4:	68 f6 00 00 00       	push   $0xf6
c0028af9:	68 74 1c 03 c0       	push   $0xc0031c74
c0028afe:	e8 6b 0c 00 00       	call   c002976e <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028b03:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b06:	8a 00                	mov    (%eax),%al
c0028b08:	84 c0                	test   %al,%al
c0028b0a:	75 0f                	jne    c0028b1b <strtok_r+0xa1>
        {
          *save_ptr = s;
c0028b0c:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b0f:	8b 55 08             	mov    0x8(%ebp),%edx
c0028b12:	89 10                	mov    %edx,(%eax)
          return NULL;
c0028b14:	b8 00 00 00 00       	mov    $0x0,%eax
c0028b19:	eb 6b                	jmp    c0028b86 <strtok_r+0x10c>
        }

      s++;
c0028b1b:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) != NULL) 
c0028b1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b21:	8a 00                	mov    (%eax),%al
c0028b23:	0f be c0             	movsbl %al,%eax
c0028b26:	83 ec 08             	sub    $0x8,%esp
c0028b29:	50                   	push   %eax
c0028b2a:	ff 75 0c             	pushl  0xc(%ebp)
c0028b2d:	e8 7b fd ff ff       	call   c00288ad <strchr>
c0028b32:	83 c4 10             	add    $0x10,%esp
c0028b35:	85 c0                	test   %eax,%eax
c0028b37:	75 ca                	jne    c0028b03 <strtok_r+0x89>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c0028b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028b3f:	eb 03                	jmp    c0028b44 <strtok_r+0xca>
    s++;
c0028b41:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028b44:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b47:	8a 00                	mov    (%eax),%al
c0028b49:	0f be c0             	movsbl %al,%eax
c0028b4c:	83 ec 08             	sub    $0x8,%esp
c0028b4f:	50                   	push   %eax
c0028b50:	ff 75 0c             	pushl  0xc(%ebp)
c0028b53:	e8 55 fd ff ff       	call   c00288ad <strchr>
c0028b58:	83 c4 10             	add    $0x10,%esp
c0028b5b:	85 c0                	test   %eax,%eax
c0028b5d:	74 e2                	je     c0028b41 <strtok_r+0xc7>
  if (*s != '\0') 
c0028b5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b62:	8a 00                	mov    (%eax),%al
c0028b64:	84 c0                	test   %al,%al
c0028b66:	74 13                	je     c0028b7b <strtok_r+0x101>
    {
      *s = '\0';
c0028b68:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b6b:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028b6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b71:	8d 50 01             	lea    0x1(%eax),%edx
c0028b74:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b77:	89 10                	mov    %edx,(%eax)
c0028b79:	eb 08                	jmp    c0028b83 <strtok_r+0x109>
    }
  else 
    *save_ptr = s;
c0028b7b:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b7e:	8b 55 08             	mov    0x8(%ebp),%edx
c0028b81:	89 10                	mov    %edx,(%eax)
  return token;
c0028b83:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028b86:	c9                   	leave  
c0028b87:	c3                   	ret    

c0028b88 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028b88:	55                   	push   %ebp
c0028b89:	89 e5                	mov    %esp,%ebp
c0028b8b:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028b8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b91:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028b94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028b98:	75 35                	jne    c0028bcf <memset+0x47>
c0028b9a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b9e:	74 2f                	je     c0028bcf <memset+0x47>
c0028ba0:	83 ec 0c             	sub    $0xc,%esp
c0028ba3:	68 44 1c 03 c0       	push   $0xc0031c44
c0028ba8:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028bad:	68 90 1d 03 c0       	push   $0xc0031d90
c0028bb2:	68 1b 01 00 00       	push   $0x11b
c0028bb7:	68 74 1c 03 c0       	push   $0xc0031c74
c0028bbc:	e8 ad 0b 00 00       	call   c002976e <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0028bc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028bc4:	8d 50 01             	lea    0x1(%eax),%edx
c0028bc7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028bca:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028bcd:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0028bcf:	8b 45 10             	mov    0x10(%ebp),%eax
c0028bd2:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028bd5:	89 55 10             	mov    %edx,0x10(%ebp)
c0028bd8:	85 c0                	test   %eax,%eax
c0028bda:	75 e5                	jne    c0028bc1 <memset+0x39>

  return dst_;
c0028bdc:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028bdf:	c9                   	leave  
c0028be0:	c3                   	ret    

c0028be1 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0028be1:	55                   	push   %ebp
c0028be2:	89 e5                	mov    %esp,%ebp
c0028be4:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c0028be7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028beb:	75 21                	jne    c0028c0e <strlen+0x2d>
c0028bed:	83 ec 0c             	sub    $0xc,%esp
c0028bf0:	68 fd 1c 03 c0       	push   $0xc0031cfd
c0028bf5:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028bfa:	68 98 1d 03 c0       	push   $0xc0031d98
c0028bff:	68 29 01 00 00       	push   $0x129
c0028c04:	68 74 1c 03 c0       	push   $0xc0031c74
c0028c09:	e8 60 0b 00 00       	call   c002976e <debug_panic>

  for (p = string; *p != '\0'; p++)
c0028c0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c11:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028c14:	eb 03                	jmp    c0028c19 <strlen+0x38>
c0028c16:	ff 45 f4             	incl   -0xc(%ebp)
c0028c19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c1c:	8a 00                	mov    (%eax),%al
c0028c1e:	84 c0                	test   %al,%al
c0028c20:	75 f4                	jne    c0028c16 <strlen+0x35>
    continue;
  return p - string;
c0028c22:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028c25:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c28:	29 c2                	sub    %eax,%edx
c0028c2a:	89 d0                	mov    %edx,%eax
}
c0028c2c:	c9                   	leave  
c0028c2d:	c3                   	ret    

c0028c2e <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c0028c2e:	55                   	push   %ebp
c0028c2f:	89 e5                	mov    %esp,%ebp
c0028c31:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028c34:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028c3b:	eb 03                	jmp    c0028c40 <strnlen+0x12>
c0028c3d:	ff 45 fc             	incl   -0x4(%ebp)
c0028c40:	8b 55 08             	mov    0x8(%ebp),%edx
c0028c43:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028c46:	01 d0                	add    %edx,%eax
c0028c48:	8a 00                	mov    (%eax),%al
c0028c4a:	84 c0                	test   %al,%al
c0028c4c:	74 08                	je     c0028c56 <strnlen+0x28>
c0028c4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028c51:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028c54:	72 e7                	jb     c0028c3d <strnlen+0xf>
    continue;
  return length;
c0028c56:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028c59:	c9                   	leave  
c0028c5a:	c3                   	ret    

c0028c5b <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0028c5b:	55                   	push   %ebp
c0028c5c:	89 e5                	mov    %esp,%ebp
c0028c5e:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0028c61:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028c65:	75 21                	jne    c0028c88 <strlcpy+0x2d>
c0028c67:	83 ec 0c             	sub    $0xc,%esp
c0028c6a:	68 3a 1d 03 c0       	push   $0xc0031d3a
c0028c6f:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028c74:	68 a0 1d 03 c0       	push   $0xc0031da0
c0028c79:	68 4a 01 00 00       	push   $0x14a
c0028c7e:	68 74 1c 03 c0       	push   $0xc0031c74
c0028c83:	e8 e6 0a 00 00       	call   c002976e <debug_panic>
  ASSERT (src != NULL);
c0028c88:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028c8c:	75 21                	jne    c0028caf <strlcpy+0x54>
c0028c8e:	83 ec 0c             	sub    $0xc,%esp
c0028c91:	68 46 1d 03 c0       	push   $0xc0031d46
c0028c96:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028c9b:	68 a0 1d 03 c0       	push   $0xc0031da0
c0028ca0:	68 4b 01 00 00       	push   $0x14b
c0028ca5:	68 74 1c 03 c0       	push   $0xc0031c74
c0028caa:	e8 bf 0a 00 00       	call   c002976e <debug_panic>

  src_len = strlen (src);
c0028caf:	83 ec 0c             	sub    $0xc,%esp
c0028cb2:	ff 75 0c             	pushl  0xc(%ebp)
c0028cb5:	e8 27 ff ff ff       	call   c0028be1 <strlen>
c0028cba:	83 c4 10             	add    $0x10,%esp
c0028cbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c0028cc0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028cc4:	74 34                	je     c0028cfa <strlcpy+0x9f>
    {
      size_t dst_len = size - 1;
c0028cc6:	8b 45 10             	mov    0x10(%ebp),%eax
c0028cc9:	48                   	dec    %eax
c0028cca:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c0028ccd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028cd0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028cd3:	73 06                	jae    c0028cdb <strlcpy+0x80>
        dst_len = src_len;
c0028cd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028cd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c0028cdb:	83 ec 04             	sub    $0x4,%esp
c0028cde:	ff 75 f4             	pushl  -0xc(%ebp)
c0028ce1:	ff 75 0c             	pushl  0xc(%ebp)
c0028ce4:	ff 75 08             	pushl  0x8(%ebp)
c0028ce7:	e8 c2 f8 ff ff       	call   c00285ae <memcpy>
c0028cec:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c0028cef:	8b 55 08             	mov    0x8(%ebp),%edx
c0028cf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028cf5:	01 d0                	add    %edx,%eax
c0028cf7:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0028cfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028cfd:	c9                   	leave  
c0028cfe:	c3                   	ret    

c0028cff <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028cff:	55                   	push   %ebp
c0028d00:	89 e5                	mov    %esp,%ebp
c0028d02:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0028d05:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028d09:	75 21                	jne    c0028d2c <strlcat+0x2d>
c0028d0b:	83 ec 0c             	sub    $0xc,%esp
c0028d0e:	68 3a 1d 03 c0       	push   $0xc0031d3a
c0028d13:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028d18:	68 a8 1d 03 c0       	push   $0xc0031da8
c0028d1d:	68 68 01 00 00       	push   $0x168
c0028d22:	68 74 1c 03 c0       	push   $0xc0031c74
c0028d27:	e8 42 0a 00 00       	call   c002976e <debug_panic>
  ASSERT (src != NULL);
c0028d2c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028d30:	75 21                	jne    c0028d53 <strlcat+0x54>
c0028d32:	83 ec 0c             	sub    $0xc,%esp
c0028d35:	68 46 1d 03 c0       	push   $0xc0031d46
c0028d3a:	68 5d 1c 03 c0       	push   $0xc0031c5d
c0028d3f:	68 a8 1d 03 c0       	push   $0xc0031da8
c0028d44:	68 69 01 00 00       	push   $0x169
c0028d49:	68 74 1c 03 c0       	push   $0xc0031c74
c0028d4e:	e8 1b 0a 00 00       	call   c002976e <debug_panic>

  src_len = strlen (src);
c0028d53:	83 ec 0c             	sub    $0xc,%esp
c0028d56:	ff 75 0c             	pushl  0xc(%ebp)
c0028d59:	e8 83 fe ff ff       	call   c0028be1 <strlen>
c0028d5e:	83 c4 10             	add    $0x10,%esp
c0028d61:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0028d64:	83 ec 0c             	sub    $0xc,%esp
c0028d67:	ff 75 08             	pushl  0x8(%ebp)
c0028d6a:	e8 72 fe ff ff       	call   c0028be1 <strlen>
c0028d6f:	83 c4 10             	add    $0x10,%esp
c0028d72:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0028d75:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028d79:	74 4a                	je     c0028dc5 <strlcat+0xc6>
c0028d7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028d7e:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028d81:	73 42                	jae    c0028dc5 <strlcat+0xc6>
    {
      size_t copy_cnt = size - dst_len - 1;
c0028d83:	8b 45 10             	mov    0x10(%ebp),%eax
c0028d86:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028d89:	48                   	dec    %eax
c0028d8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c0028d8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028d90:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028d93:	73 06                	jae    c0028d9b <strlcat+0x9c>
        copy_cnt = src_len;
c0028d95:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028d98:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c0028d9b:	8b 55 08             	mov    0x8(%ebp),%edx
c0028d9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028da1:	01 d0                	add    %edx,%eax
c0028da3:	83 ec 04             	sub    $0x4,%esp
c0028da6:	ff 75 f4             	pushl  -0xc(%ebp)
c0028da9:	ff 75 0c             	pushl  0xc(%ebp)
c0028dac:	50                   	push   %eax
c0028dad:	e8 fc f7 ff ff       	call   c00285ae <memcpy>
c0028db2:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0028db5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028dbb:	01 c2                	add    %eax,%edx
c0028dbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dc0:	01 d0                	add    %edx,%eax
c0028dc2:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0028dc5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028dc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028dcb:	01 d0                	add    %edx,%eax
}
c0028dcd:	c9                   	leave  
c0028dce:	c3                   	ret    

c0028dcf <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c0028dcf:	55                   	push   %ebp
c0028dd0:	89 e5                	mov    %esp,%ebp
c0028dd2:	83 ec 18             	sub    $0x18,%esp
c0028dd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dd8:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028dde:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0028de1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028de4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028de7:	89 d0                	mov    %edx,%eax
c0028de9:	31 d2                	xor    %edx,%edx
c0028deb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c0028dee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028df1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0028df4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028df7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028dfa:	f7 75 10             	divl   0x10(%ebp)
c0028dfd:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028e00:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0028e03:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028e06:	c9                   	leave  
c0028e07:	c3                   	ret    

c0028e08 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0028e08:	55                   	push   %ebp
c0028e09:	89 e5                	mov    %esp,%ebp
c0028e0b:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c0028e0e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c0028e15:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c0028e1c:	77 08                	ja     c0028e26 <nlz+0x1e>
    {
      n += 16;
c0028e1e:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c0028e22:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c0028e26:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c0028e2d:	77 08                	ja     c0028e37 <nlz+0x2f>
    {
      n += 8;
c0028e2f:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c0028e33:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c0028e37:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c0028e3e:	77 08                	ja     c0028e48 <nlz+0x40>
    {
      n += 4;
c0028e40:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c0028e44:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c0028e48:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c0028e4f:	77 08                	ja     c0028e59 <nlz+0x51>
    {
      n += 2;
c0028e51:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c0028e55:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c0028e59:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e5c:	85 c0                	test   %eax,%eax
c0028e5e:	78 03                	js     c0028e63 <nlz+0x5b>
    n++;
c0028e60:	ff 45 fc             	incl   -0x4(%ebp)
  return n;
c0028e63:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028e66:	c9                   	leave  
c0028e67:	c3                   	ret    

c0028e68 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028e68:	55                   	push   %ebp
c0028e69:	89 e5                	mov    %esp,%ebp
c0028e6b:	57                   	push   %edi
c0028e6c:	56                   	push   %esi
c0028e6d:	53                   	push   %ebx
c0028e6e:	83 ec 44             	sub    $0x44,%esp
c0028e71:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e74:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0028e77:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e7a:	89 45 bc             	mov    %eax,-0x44(%ebp)
c0028e7d:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e80:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0028e83:	8b 45 14             	mov    0x14(%ebp),%eax
c0028e86:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c0028e89:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028e8c:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028e8f:	89 d0                	mov    %edx,%eax
c0028e91:	31 d2                	xor    %edx,%edx
c0028e93:	89 c7                	mov    %eax,%edi
c0028e95:	83 f7 00             	xor    $0x0,%edi
c0028e98:	89 f9                	mov    %edi,%ecx
c0028e9a:	89 d0                	mov    %edx,%eax
c0028e9c:	80 f4 00             	xor    $0x0,%ah
c0028e9f:	89 c3                	mov    %eax,%ebx
c0028ea1:	89 d8                	mov    %ebx,%eax
c0028ea3:	09 c8                	or     %ecx,%eax
c0028ea5:	85 c0                	test   %eax,%eax
c0028ea7:	0f 85 a3 00 00 00    	jne    c0028f50 <udiv64+0xe8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c0028ead:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0028eb4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c0028ebb:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028ebe:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028ec1:	89 d0                	mov    %edx,%eax
c0028ec3:	31 d2                	xor    %edx,%edx
c0028ec5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c0028ec8:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028ecb:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c0028ece:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028ed1:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028ed4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028ed7:	ba 00 00 00 00       	mov    $0x0,%edx
c0028edc:	f7 75 dc             	divl   -0x24(%ebp)
c0028edf:	89 d0                	mov    %edx,%eax
c0028ee1:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ee6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028ee9:	89 cb                	mov    %ecx,%ebx
c0028eeb:	0f af da             	imul   %edx,%ebx
c0028eee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0028ef1:	0f af c8             	imul   %eax,%ecx
c0028ef4:	01 d9                	add    %ebx,%ecx
c0028ef6:	f7 65 e8             	mull   -0x18(%ebp)
c0028ef9:	01 d1                	add    %edx,%ecx
c0028efb:	89 ca                	mov    %ecx,%edx
c0028efd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0028f00:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028f05:	01 c8                	add    %ecx,%eax
c0028f07:	11 da                	adc    %ebx,%edx
c0028f09:	83 ec 04             	sub    $0x4,%esp
c0028f0c:	ff 75 dc             	pushl  -0x24(%ebp)
c0028f0f:	52                   	push   %edx
c0028f10:	50                   	push   %eax
c0028f11:	e8 b9 fe ff ff       	call   c0028dcf <divl>
c0028f16:	83 c4 10             	add    $0x10,%esp
c0028f19:	89 c1                	mov    %eax,%ecx
c0028f1b:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028f20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028f23:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f28:	f7 75 dc             	divl   -0x24(%ebp)
c0028f2b:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f30:	8b 75 e8             	mov    -0x18(%ebp),%esi
c0028f33:	89 f7                	mov    %esi,%edi
c0028f35:	0f af fa             	imul   %edx,%edi
c0028f38:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0028f3b:	0f af f0             	imul   %eax,%esi
c0028f3e:	01 fe                	add    %edi,%esi
c0028f40:	f7 65 e8             	mull   -0x18(%ebp)
c0028f43:	01 d6                	add    %edx,%esi
c0028f45:	89 f2                	mov    %esi,%edx
c0028f47:	01 c8                	add    %ecx,%eax
c0028f49:	11 da                	adc    %ebx,%edx
c0028f4b:	e9 e7 00 00 00       	jmp    c0029037 <udiv64+0x1cf>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028f50:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028f53:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028f56:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028f59:	77 19                	ja     c0028f74 <udiv64+0x10c>
c0028f5b:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028f5e:	72 05                	jb     c0028f65 <udiv64+0xfd>
c0028f60:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028f63:	73 0f                	jae    c0028f74 <udiv64+0x10c>
        return 0;
c0028f65:	b8 00 00 00 00       	mov    $0x0,%eax
c0028f6a:	ba 00 00 00 00       	mov    $0x0,%edx
c0028f6f:	e9 c3 00 00 00       	jmp    c0029037 <udiv64+0x1cf>
      else 
        {
          uint32_t d1 = d >> 32;
c0028f74:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028f77:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028f7a:	89 d0                	mov    %edx,%eax
c0028f7c:	31 d2                	xor    %edx,%edx
c0028f7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c0028f81:	83 ec 04             	sub    $0x4,%esp
c0028f84:	ff 75 d8             	pushl  -0x28(%ebp)
c0028f87:	e8 7c fe ff ff       	call   c0028e08 <nlz>
c0028f8c:	83 c4 08             	add    $0x8,%esp
c0028f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028f92:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0028f95:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028f98:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028f9b:	0f a5 c2             	shld   %cl,%eax,%edx
c0028f9e:	d3 e0                	shl    %cl,%eax
c0028fa0:	f6 c1 20             	test   $0x20,%cl
c0028fa3:	74 04                	je     c0028fa9 <udiv64+0x141>
c0028fa5:	89 c2                	mov    %eax,%edx
c0028fa7:	31 c0                	xor    %eax,%eax
c0028fa9:	89 d0                	mov    %edx,%eax
c0028fab:	31 d2                	xor    %edx,%edx
c0028fad:	89 c1                	mov    %eax,%ecx
c0028faf:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028fb2:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028fb5:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0028fb9:	d1 ea                	shr    %edx
c0028fbb:	83 ec 04             	sub    $0x4,%esp
c0028fbe:	51                   	push   %ecx
c0028fbf:	52                   	push   %edx
c0028fc0:	50                   	push   %eax
c0028fc1:	e8 09 fe ff ff       	call   c0028dcf <divl>
c0028fc6:	83 c4 10             	add    $0x10,%esp
c0028fc9:	89 c2                	mov    %eax,%edx
c0028fcb:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0028fd0:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0028fd3:	88 c1                	mov    %al,%cl
c0028fd5:	d3 ea                	shr    %cl,%edx
c0028fd7:	89 d0                	mov    %edx,%eax
c0028fd9:	89 45 c8             	mov    %eax,-0x38(%ebp)
c0028fdc:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028fe3:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028fe6:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028fe9:	83 c0 ff             	add    $0xffffffff,%eax
c0028fec:	83 d2 ff             	adc    $0xffffffff,%edx
c0028fef:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0028ff2:	89 cb                	mov    %ecx,%ebx
c0028ff4:	0f af da             	imul   %edx,%ebx
c0028ff7:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c0028ffa:	0f af c8             	imul   %eax,%ecx
c0028ffd:	01 d9                	add    %ebx,%ecx
c0028fff:	f7 65 b0             	mull   -0x50(%ebp)
c0029002:	01 d1                	add    %edx,%ecx
c0029004:	89 ca                	mov    %ecx,%edx
c0029006:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0029009:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c002900c:	29 c1                	sub    %eax,%ecx
c002900e:	19 d3                	sbb    %edx,%ebx
c0029010:	89 c8                	mov    %ecx,%eax
c0029012:	89 da                	mov    %ebx,%edx
c0029014:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0029017:	77 18                	ja     c0029031 <udiv64+0x1c9>
c0029019:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c002901c:	72 05                	jb     c0029023 <udiv64+0x1bb>
c002901e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0029021:	73 0e                	jae    c0029031 <udiv64+0x1c9>
c0029023:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029026:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0029029:	83 c0 ff             	add    $0xffffffff,%eax
c002902c:	83 d2 ff             	adc    $0xffffffff,%edx
c002902f:	eb 06                	jmp    c0029037 <udiv64+0x1cf>
c0029031:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029034:	8b 55 cc             	mov    -0x34(%ebp),%edx
        }
    }
}
c0029037:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002903a:	5b                   	pop    %ebx
c002903b:	5e                   	pop    %esi
c002903c:	5f                   	pop    %edi
c002903d:	5d                   	pop    %ebp
c002903e:	c3                   	ret    

c002903f <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c002903f:	55                   	push   %ebp
c0029040:	89 e5                	mov    %esp,%ebp
c0029042:	53                   	push   %ebx
c0029043:	83 ec 14             	sub    $0x14,%esp
c0029046:	8b 45 08             	mov    0x8(%ebp),%eax
c0029049:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002904c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002904f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029052:	8b 45 10             	mov    0x10(%ebp),%eax
c0029055:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0029058:	8b 45 14             	mov    0x14(%ebp),%eax
c002905b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c002905e:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0029061:	ff 75 ec             	pushl  -0x14(%ebp)
c0029064:	ff 75 e8             	pushl  -0x18(%ebp)
c0029067:	ff 75 f4             	pushl  -0xc(%ebp)
c002906a:	ff 75 f0             	pushl  -0x10(%ebp)
c002906d:	e8 f6 fd ff ff       	call   c0028e68 <udiv64>
c0029072:	83 c4 10             	add    $0x10,%esp
c0029075:	89 c2                	mov    %eax,%edx
c0029077:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002907a:	0f af c2             	imul   %edx,%eax
c002907d:	29 c3                	sub    %eax,%ebx
c002907f:	89 d8                	mov    %ebx,%eax
}
c0029081:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029084:	c9                   	leave  
c0029085:	c3                   	ret    

c0029086 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0029086:	55                   	push   %ebp
c0029087:	89 e5                	mov    %esp,%ebp
c0029089:	83 ec 30             	sub    $0x30,%esp
c002908c:	8b 45 08             	mov    0x8(%ebp),%eax
c002908f:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0029092:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029095:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0029098:	8b 45 10             	mov    0x10(%ebp),%eax
c002909b:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002909e:	8b 45 14             	mov    0x14(%ebp),%eax
c00290a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c00290a4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00290a8:	79 0f                	jns    c00290b9 <sdiv64+0x33>
c00290aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00290ad:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00290b0:	f7 d8                	neg    %eax
c00290b2:	83 d2 00             	adc    $0x0,%edx
c00290b5:	f7 da                	neg    %edx
c00290b7:	eb 06                	jmp    c00290bf <sdiv64+0x39>
c00290b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00290bc:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00290bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00290c2:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c00290c5:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c00290c9:	79 0f                	jns    c00290da <sdiv64+0x54>
c00290cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00290ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00290d1:	f7 d8                	neg    %eax
c00290d3:	83 d2 00             	adc    $0x0,%edx
c00290d6:	f7 da                	neg    %edx
c00290d8:	eb 06                	jmp    c00290e0 <sdiv64+0x5a>
c00290da:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00290dd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00290e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00290e3:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c00290e6:	ff 75 f4             	pushl  -0xc(%ebp)
c00290e9:	ff 75 f0             	pushl  -0x10(%ebp)
c00290ec:	ff 75 fc             	pushl  -0x4(%ebp)
c00290ef:	ff 75 f8             	pushl  -0x8(%ebp)
c00290f2:	e8 71 fd ff ff       	call   c0028e68 <udiv64>
c00290f7:	83 c4 10             	add    $0x10,%esp
c00290fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00290fd:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0029100:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0029103:	f7 d0                	not    %eax
c0029105:	c1 e8 1f             	shr    $0x1f,%eax
c0029108:	88 c2                	mov    %al,%dl
c002910a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002910d:	c1 e8 1f             	shr    $0x1f,%eax
c0029110:	31 d0                	xor    %edx,%eax
c0029112:	84 c0                	test   %al,%al
c0029114:	74 08                	je     c002911e <sdiv64+0x98>
c0029116:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029119:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002911c:	eb 0d                	jmp    c002912b <sdiv64+0xa5>
c002911e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029121:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029124:	f7 d8                	neg    %eax
c0029126:	83 d2 00             	adc    $0x0,%edx
c0029129:	f7 da                	neg    %edx
}
c002912b:	c9                   	leave  
c002912c:	c3                   	ret    

c002912d <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c002912d:	55                   	push   %ebp
c002912e:	89 e5                	mov    %esp,%ebp
c0029130:	53                   	push   %ebx
c0029131:	83 ec 14             	sub    $0x14,%esp
c0029134:	8b 45 08             	mov    0x8(%ebp),%eax
c0029137:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002913a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002913d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029140:	8b 45 10             	mov    0x10(%ebp),%eax
c0029143:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0029146:	8b 45 14             	mov    0x14(%ebp),%eax
c0029149:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c002914c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c002914f:	ff 75 ec             	pushl  -0x14(%ebp)
c0029152:	ff 75 e8             	pushl  -0x18(%ebp)
c0029155:	ff 75 f4             	pushl  -0xc(%ebp)
c0029158:	ff 75 f0             	pushl  -0x10(%ebp)
c002915b:	e8 26 ff ff ff       	call   c0029086 <sdiv64>
c0029160:	83 c4 10             	add    $0x10,%esp
c0029163:	89 c2                	mov    %eax,%edx
c0029165:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029168:	0f af c2             	imul   %edx,%eax
c002916b:	29 c3                	sub    %eax,%ebx
c002916d:	89 d8                	mov    %ebx,%eax
}
c002916f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029172:	c9                   	leave  
c0029173:	c3                   	ret    

c0029174 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0029174:	55                   	push   %ebp
c0029175:	89 e5                	mov    %esp,%ebp
c0029177:	83 ec 10             	sub    $0x10,%esp
c002917a:	8b 45 08             	mov    0x8(%ebp),%eax
c002917d:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029180:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029183:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029186:	8b 45 10             	mov    0x10(%ebp),%eax
c0029189:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002918c:	8b 45 14             	mov    0x14(%ebp),%eax
c002918f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0029192:	ff 75 f4             	pushl  -0xc(%ebp)
c0029195:	ff 75 f0             	pushl  -0x10(%ebp)
c0029198:	ff 75 fc             	pushl  -0x4(%ebp)
c002919b:	ff 75 f8             	pushl  -0x8(%ebp)
c002919e:	e8 e3 fe ff ff       	call   c0029086 <sdiv64>
c00291a3:	83 c4 10             	add    $0x10,%esp
}
c00291a6:	c9                   	leave  
c00291a7:	c3                   	ret    

c00291a8 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c00291a8:	55                   	push   %ebp
c00291a9:	89 e5                	mov    %esp,%ebp
c00291ab:	83 ec 10             	sub    $0x10,%esp
c00291ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00291b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00291b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00291b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00291ba:	8b 45 10             	mov    0x10(%ebp),%eax
c00291bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00291c0:	8b 45 14             	mov    0x14(%ebp),%eax
c00291c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c00291c6:	ff 75 f4             	pushl  -0xc(%ebp)
c00291c9:	ff 75 f0             	pushl  -0x10(%ebp)
c00291cc:	ff 75 fc             	pushl  -0x4(%ebp)
c00291cf:	ff 75 f8             	pushl  -0x8(%ebp)
c00291d2:	e8 56 ff ff ff       	call   c002912d <smod64>
c00291d7:	83 c4 10             	add    $0x10,%esp
c00291da:	99                   	cltd   
}
c00291db:	c9                   	leave  
c00291dc:	c3                   	ret    

c00291dd <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c00291dd:	55                   	push   %ebp
c00291de:	89 e5                	mov    %esp,%ebp
c00291e0:	83 ec 10             	sub    $0x10,%esp
c00291e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00291e6:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00291e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00291ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00291ef:	8b 45 10             	mov    0x10(%ebp),%eax
c00291f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00291f5:	8b 45 14             	mov    0x14(%ebp),%eax
c00291f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c00291fb:	ff 75 f4             	pushl  -0xc(%ebp)
c00291fe:	ff 75 f0             	pushl  -0x10(%ebp)
c0029201:	ff 75 fc             	pushl  -0x4(%ebp)
c0029204:	ff 75 f8             	pushl  -0x8(%ebp)
c0029207:	e8 5c fc ff ff       	call   c0028e68 <udiv64>
c002920c:	83 c4 10             	add    $0x10,%esp
}
c002920f:	c9                   	leave  
c0029210:	c3                   	ret    

c0029211 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0029211:	55                   	push   %ebp
c0029212:	89 e5                	mov    %esp,%ebp
c0029214:	83 ec 10             	sub    $0x10,%esp
c0029217:	8b 45 08             	mov    0x8(%ebp),%eax
c002921a:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002921d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029220:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029223:	8b 45 10             	mov    0x10(%ebp),%eax
c0029226:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029229:	8b 45 14             	mov    0x14(%ebp),%eax
c002922c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c002922f:	ff 75 f4             	pushl  -0xc(%ebp)
c0029232:	ff 75 f0             	pushl  -0x10(%ebp)
c0029235:	ff 75 fc             	pushl  -0x4(%ebp)
c0029238:	ff 75 f8             	pushl  -0x8(%ebp)
c002923b:	e8 ff fd ff ff       	call   c002903f <umod64>
c0029240:	83 c4 10             	add    $0x10,%esp
c0029243:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0029248:	c9                   	leave  
c0029249:	c3                   	ret    

c002924a <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c002924a:	55                   	push   %ebp
c002924b:	89 e5                	mov    %esp,%ebp
c002924d:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c0029250:	8b 45 08             	mov    0x8(%ebp),%eax
c0029253:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c0029256:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002925d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0029264:	eb 57                	jmp    c00292bd <calculate_chksum+0x73>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c0029266:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c002926d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029270:	83 c0 08             	add    $0x8,%eax
c0029273:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c0029276:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029279:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002927c:	72 0f                	jb     c002928d <calculate_chksum+0x43>
c002927e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029281:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0029284:	73 07                	jae    c002928d <calculate_chksum+0x43>
c0029286:	b8 01 00 00 00       	mov    $0x1,%eax
c002928b:	eb 05                	jmp    c0029292 <calculate_chksum+0x48>
c002928d:	b8 00 00 00 00       	mov    $0x0,%eax
c0029292:	88 45 eb             	mov    %al,-0x15(%ebp)
c0029295:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c0029299:	8a 45 eb             	mov    -0x15(%ebp),%al
c002929c:	83 f0 01             	xor    $0x1,%eax
c002929f:	84 c0                	test   %al,%al
c00292a1:	74 0f                	je     c00292b2 <calculate_chksum+0x68>
c00292a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00292a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00292a9:	01 d0                	add    %edx,%eax
c00292ab:	8a 00                	mov    (%eax),%al
c00292ad:	0f b6 c0             	movzbl %al,%eax
c00292b0:	eb 05                	jmp    c00292b7 <calculate_chksum+0x6d>
c00292b2:	b8 20 00 00 00       	mov    $0x20,%eax
c00292b7:	01 45 fc             	add    %eax,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c00292ba:	ff 45 f8             	incl   -0x8(%ebp)
c00292bd:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c00292c4:	76 a0                	jbe    c0029266 <calculate_chksum+0x1c>
    }
  return chksum;
c00292c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00292c9:	c9                   	leave  
c00292ca:	c3                   	ret    

c00292cb <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c00292cb:	55                   	push   %ebp
c00292cc:	89 e5                	mov    %esp,%ebp
c00292ce:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c00292d1:	eb 14                	jmp    c00292e7 <strip_antisocial_prefixes+0x1c>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c00292d3:	83 ec 08             	sub    $0x8,%esp
c00292d6:	6a 2f                	push   $0x2f
c00292d8:	ff 75 08             	pushl  0x8(%ebp)
c00292db:	e8 cd f5 ff ff       	call   c00288ad <strchr>
c00292e0:	83 c4 10             	add    $0x10,%esp
c00292e3:	40                   	inc    %eax
c00292e4:	89 45 08             	mov    %eax,0x8(%ebp)
  while (*file_name == '/'
c00292e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00292ea:	8a 00                	mov    (%eax),%al
c00292ec:	3c 2f                	cmp    $0x2f,%al
c00292ee:	74 e3                	je     c00292d3 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c00292f0:	83 ec 04             	sub    $0x4,%esp
c00292f3:	6a 02                	push   $0x2
c00292f5:	68 b0 1d 03 c0       	push   $0xc0031db0
c00292fa:	ff 75 08             	pushl  0x8(%ebp)
c00292fd:	e8 ff f3 ff ff       	call   c0028701 <memcmp>
c0029302:	83 c4 10             	add    $0x10,%esp
c0029305:	85 c0                	test   %eax,%eax
c0029307:	74 ca                	je     c00292d3 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c0029309:	83 ec 04             	sub    $0x4,%esp
c002930c:	6a 03                	push   $0x3
c002930e:	68 b3 1d 03 c0       	push   $0xc0031db3
c0029313:	ff 75 08             	pushl  0x8(%ebp)
c0029316:	e8 e6 f3 ff ff       	call   c0028701 <memcmp>
c002931b:	83 c4 10             	add    $0x10,%esp
c002931e:	85 c0                	test   %eax,%eax
c0029320:	74 b1                	je     c00292d3 <strip_antisocial_prefixes+0x8>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c0029322:	8b 45 08             	mov    0x8(%ebp),%eax
c0029325:	8a 00                	mov    (%eax),%al
c0029327:	84 c0                	test   %al,%al
c0029329:	74 1c                	je     c0029347 <strip_antisocial_prefixes+0x7c>
c002932b:	83 ec 08             	sub    $0x8,%esp
c002932e:	68 b7 1d 03 c0       	push   $0xc0031db7
c0029333:	ff 75 08             	pushl  0x8(%ebp)
c0029336:	e8 70 f4 ff ff       	call   c00287ab <strcmp>
c002933b:	83 c4 10             	add    $0x10,%esp
c002933e:	85 c0                	test   %eax,%eax
c0029340:	74 05                	je     c0029347 <strip_antisocial_prefixes+0x7c>
c0029342:	8b 45 08             	mov    0x8(%ebp),%eax
c0029345:	eb 05                	jmp    c002934c <strip_antisocial_prefixes+0x81>
c0029347:	b8 ba 1d 03 c0       	mov    $0xc0031dba,%eax
}
c002934c:	c9                   	leave  
c002934d:	c3                   	ret    

c002934e <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c002934e:	55                   	push   %ebp
c002934f:	89 e5                	mov    %esp,%ebp
c0029351:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c0029354:	8b 45 14             	mov    0x14(%ebp),%eax
c0029357:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c002935a:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c002935e:	74 24                	je     c0029384 <ustar_make_header+0x36>
c0029360:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c0029364:	74 1e                	je     c0029384 <ustar_make_header+0x36>
c0029366:	83 ec 0c             	sub    $0xc,%esp
c0029369:	68 bc 1d 03 c0       	push   $0xc0031dbc
c002936e:	68 ed 1d 03 c0       	push   $0xc0031ded
c0029373:	68 f0 1e 03 c0       	push   $0xc0031ef0
c0029378:	6a 59                	push   $0x59
c002937a:	68 04 1e 03 c0       	push   $0xc0031e04
c002937f:	e8 ea 03 00 00       	call   c002976e <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c0029384:	83 ec 0c             	sub    $0xc,%esp
c0029387:	ff 75 08             	pushl  0x8(%ebp)
c002938a:	e8 3c ff ff ff       	call   c00292cb <strip_antisocial_prefixes>
c002938f:	83 c4 10             	add    $0x10,%esp
c0029392:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c0029395:	83 ec 0c             	sub    $0xc,%esp
c0029398:	ff 75 08             	pushl  0x8(%ebp)
c002939b:	e8 41 f8 ff ff       	call   c0028be1 <strlen>
c00293a0:	83 c4 10             	add    $0x10,%esp
c00293a3:	83 f8 63             	cmp    $0x63,%eax
c00293a6:	76 1a                	jbe    c00293c2 <ustar_make_header+0x74>
    {
      printf ("%s: file name too long\n", file_name);
c00293a8:	83 ec 08             	sub    $0x8,%esp
c00293ab:	ff 75 08             	pushl  0x8(%ebp)
c00293ae:	68 16 1e 03 c0       	push   $0xc0031e16
c00293b3:	e8 f7 df ff ff       	call   c00273af <printf>
c00293b8:	83 c4 10             	add    $0x10,%esp
      return false;
c00293bb:	b0 00                	mov    $0x0,%al
c00293bd:	e9 5f 01 00 00       	jmp    c0029521 <ustar_make_header+0x1d3>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c00293c2:	83 ec 04             	sub    $0x4,%esp
c00293c5:	68 00 02 00 00       	push   $0x200
c00293ca:	6a 00                	push   $0x0
c00293cc:	ff 75 f4             	pushl  -0xc(%ebp)
c00293cf:	e8 b4 f7 ff ff       	call   c0028b88 <memset>
c00293d4:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c00293d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293da:	83 ec 04             	sub    $0x4,%esp
c00293dd:	6a 64                	push   $0x64
c00293df:	ff 75 08             	pushl  0x8(%ebp)
c00293e2:	50                   	push   %eax
c00293e3:	e8 73 f8 ff ff       	call   c0028c5b <strlcpy>
c00293e8:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c00293eb:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c00293ef:	75 07                	jne    c00293f8 <ustar_make_header+0xaa>
c00293f1:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c00293f6:	eb 05                	jmp    c00293fd <ustar_make_header+0xaf>
c00293f8:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c00293fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029400:	83 c2 64             	add    $0x64,%edx
c0029403:	50                   	push   %eax
c0029404:	68 2e 1e 03 c0       	push   $0xc0031e2e
c0029409:	6a 08                	push   $0x8
c002940b:	52                   	push   %edx
c002940c:	e8 75 df ff ff       	call   c0027386 <snprintf>
c0029411:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c0029414:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029417:	83 c0 6c             	add    $0x6c,%eax
c002941a:	83 ec 04             	sub    $0x4,%esp
c002941d:	6a 08                	push   $0x8
c002941f:	68 33 1e 03 c0       	push   $0xc0031e33
c0029424:	50                   	push   %eax
c0029425:	e8 31 f8 ff ff       	call   c0028c5b <strlcpy>
c002942a:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c002942d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029430:	83 c0 74             	add    $0x74,%eax
c0029433:	83 ec 04             	sub    $0x4,%esp
c0029436:	6a 08                	push   $0x8
c0029438:	68 33 1e 03 c0       	push   $0xc0031e33
c002943d:	50                   	push   %eax
c002943e:	e8 18 f8 ff ff       	call   c0028c5b <strlcpy>
c0029443:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c0029446:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029449:	83 c0 7c             	add    $0x7c,%eax
c002944c:	ff 75 10             	pushl  0x10(%ebp)
c002944f:	68 3b 1e 03 c0       	push   $0xc0031e3b
c0029454:	6a 0c                	push   $0xc
c0029456:	50                   	push   %eax
c0029457:	e8 2a df ff ff       	call   c0027386 <snprintf>
c002945c:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c002945f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029462:	05 88 00 00 00       	add    $0x88,%eax
c0029467:	68 00 8c b7 43       	push   $0x43b78c00
c002946c:	68 3b 1e 03 c0       	push   $0xc0031e3b
c0029471:	6a 0c                	push   $0xc
c0029473:	50                   	push   %eax
c0029474:	e8 0d df ff ff       	call   c0027386 <snprintf>
c0029479:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c002947c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002947f:	88 c2                	mov    %al,%dl
c0029481:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029484:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c002948a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002948d:	05 01 01 00 00       	add    $0x101,%eax
c0029492:	83 ec 04             	sub    $0x4,%esp
c0029495:	6a 06                	push   $0x6
c0029497:	68 41 1e 03 c0       	push   $0xc0031e41
c002949c:	50                   	push   %eax
c002949d:	e8 b9 f7 ff ff       	call   c0028c5b <strlcpy>
c00294a2:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c00294a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294a8:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c00294af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294b2:	8a 90 08 01 00 00    	mov    0x108(%eax),%dl
c00294b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294bb:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c00294c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294c4:	05 29 01 00 00       	add    $0x129,%eax
c00294c9:	83 ec 04             	sub    $0x4,%esp
c00294cc:	6a 20                	push   $0x20
c00294ce:	68 47 1e 03 c0       	push   $0xc0031e47
c00294d3:	50                   	push   %eax
c00294d4:	e8 82 f7 ff ff       	call   c0028c5b <strlcpy>
c00294d9:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c00294dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294df:	05 09 01 00 00       	add    $0x109,%eax
c00294e4:	83 ec 04             	sub    $0x4,%esp
c00294e7:	6a 20                	push   $0x20
c00294e9:	68 47 1e 03 c0       	push   $0xc0031e47
c00294ee:	50                   	push   %eax
c00294ef:	e8 67 f7 ff ff       	call   c0028c5b <strlcpy>
c00294f4:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c00294f7:	83 ec 0c             	sub    $0xc,%esp
c00294fa:	ff 75 f4             	pushl  -0xc(%ebp)
c00294fd:	e8 48 fd ff ff       	call   c002924a <calculate_chksum>
c0029502:	83 c4 10             	add    $0x10,%esp
c0029505:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029508:	81 c2 94 00 00 00    	add    $0x94,%edx
c002950e:	50                   	push   %eax
c002950f:	68 2e 1e 03 c0       	push   $0xc0031e2e
c0029514:	6a 08                	push   $0x8
c0029516:	52                   	push   %edx
c0029517:	e8 6a de ff ff       	call   c0027386 <snprintf>
c002951c:	83 c4 10             	add    $0x10,%esp

  return true;
c002951f:	b0 01                	mov    $0x1,%al
}
c0029521:	c9                   	leave  
c0029522:	c3                   	ret    

c0029523 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c0029523:	55                   	push   %ebp
c0029524:	89 e5                	mov    %esp,%ebp
c0029526:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c0029529:	8b 45 10             	mov    0x10(%ebp),%eax
c002952c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c0029532:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0029539:	eb 5d                	jmp    c0029598 <parse_octal_field+0x75>
    {
      char c = s[ofs];
c002953b:	8b 55 08             	mov    0x8(%ebp),%edx
c002953e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029541:	01 d0                	add    %edx,%eax
c0029543:	8a 00                	mov    (%eax),%al
c0029545:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c0029548:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c002954c:	7e 31                	jle    c002957f <parse_octal_field+0x5c>
c002954e:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c0029552:	7f 2b                	jg     c002957f <parse_octal_field+0x5c>
        {
          if (*value > ULONG_MAX / 8)
c0029554:	8b 45 10             	mov    0x10(%ebp),%eax
c0029557:	8b 00                	mov    (%eax),%eax
c0029559:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c002955e:	76 04                	jbe    c0029564 <parse_octal_field+0x41>
            {
              /* Overflow. */
              return false;
c0029560:	b0 00                	mov    $0x0,%al
c0029562:	eb 3e                	jmp    c00295a2 <parse_octal_field+0x7f>
            }
          *value = c - '0' + *value * 8;
c0029564:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c0029568:	8b 45 10             	mov    0x10(%ebp),%eax
c002956b:	8b 00                	mov    (%eax),%eax
c002956d:	c1 e0 03             	shl    $0x3,%eax
c0029570:	01 d0                	add    %edx,%eax
c0029572:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029575:	8b 45 10             	mov    0x10(%ebp),%eax
c0029578:	89 10                	mov    %edx,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c002957a:	ff 45 fc             	incl   -0x4(%ebp)
c002957d:	eb 19                	jmp    c0029598 <parse_octal_field+0x75>
        }
      else if (c == ' ' || c == '\0')
c002957f:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c0029583:	74 06                	je     c002958b <parse_octal_field+0x68>
c0029585:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0029589:	75 09                	jne    c0029594 <parse_octal_field+0x71>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c002958b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c002958f:	0f 95 c0             	setne  %al
c0029592:	eb 0e                	jmp    c00295a2 <parse_octal_field+0x7f>
        }
      else
        {
          /* Bad character. */
          return false;
c0029594:	b0 00                	mov    $0x0,%al
c0029596:	eb 0a                	jmp    c00295a2 <parse_octal_field+0x7f>
  for (ofs = 0; ofs < size; ofs++)
c0029598:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002959b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002959e:	72 9b                	jb     c002953b <parse_octal_field+0x18>
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c00295a0:	b0 00                	mov    $0x0,%al
}
c00295a2:	c9                   	leave  
c00295a3:	c3                   	ret    

c00295a4 <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c00295a4:	55                   	push   %ebp
c00295a5:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c00295a7:	eb 13                	jmp    c00295bc <is_all_zeros+0x18>
    if (*block++ != 0)
c00295a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00295ac:	8d 50 01             	lea    0x1(%eax),%edx
c00295af:	89 55 08             	mov    %edx,0x8(%ebp)
c00295b2:	8a 00                	mov    (%eax),%al
c00295b4:	84 c0                	test   %al,%al
c00295b6:	74 04                	je     c00295bc <is_all_zeros+0x18>
      return false;
c00295b8:	b0 00                	mov    $0x0,%al
c00295ba:	eb 0f                	jmp    c00295cb <is_all_zeros+0x27>
  while (cnt-- > 0)
c00295bc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295bf:	8d 50 ff             	lea    -0x1(%eax),%edx
c00295c2:	89 55 0c             	mov    %edx,0xc(%ebp)
c00295c5:	85 c0                	test   %eax,%eax
c00295c7:	75 e0                	jne    c00295a9 <is_all_zeros+0x5>
  return true;
c00295c9:	b0 01                	mov    $0x1,%al
}
c00295cb:	5d                   	pop    %ebp
c00295cc:	c3                   	ret    

c00295cd <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c00295cd:	55                   	push   %ebp
c00295ce:	89 e5                	mov    %esp,%ebp
c00295d0:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c00295d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00295d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c00295d9:	68 00 02 00 00       	push   $0x200
c00295de:	ff 75 08             	pushl  0x8(%ebp)
c00295e1:	e8 be ff ff ff       	call   c00295a4 <is_all_zeros>
c00295e6:	83 c4 08             	add    $0x8,%esp
c00295e9:	84 c0                	test   %al,%al
c00295eb:	74 25                	je     c0029612 <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c00295ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00295f6:	8b 45 10             	mov    0x10(%ebp),%eax
c00295f9:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00295ff:	8b 45 14             	mov    0x14(%ebp),%eax
c0029602:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0029608:	b8 00 00 00 00       	mov    $0x0,%eax
c002960d:	e9 5a 01 00 00       	jmp    c002976c <ustar_parse_header+0x19f>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0029612:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029615:	05 01 01 00 00       	add    $0x101,%eax
c002961a:	83 ec 04             	sub    $0x4,%esp
c002961d:	6a 06                	push   $0x6
c002961f:	68 41 1e 03 c0       	push   $0xc0031e41
c0029624:	50                   	push   %eax
c0029625:	e8 d7 f0 ff ff       	call   c0028701 <memcmp>
c002962a:	83 c4 10             	add    $0x10,%esp
c002962d:	85 c0                	test   %eax,%eax
c002962f:	74 0a                	je     c002963b <ustar_parse_header+0x6e>
    return "not a ustar archive";
c0029631:	b8 4c 1e 03 c0       	mov    $0xc0031e4c,%eax
c0029636:	e9 31 01 00 00       	jmp    c002976c <ustar_parse_header+0x19f>
  else if (h->version[0] != '0' || h->version[1] != '0')
c002963b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002963e:	8a 80 07 01 00 00    	mov    0x107(%eax),%al
c0029644:	3c 30                	cmp    $0x30,%al
c0029646:	75 0d                	jne    c0029655 <ustar_parse_header+0x88>
c0029648:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002964b:	8a 80 08 01 00 00    	mov    0x108(%eax),%al
c0029651:	3c 30                	cmp    $0x30,%al
c0029653:	74 0a                	je     c002965f <ustar_parse_header+0x92>
    return "invalid ustar version";
c0029655:	b8 60 1e 03 c0       	mov    $0xc0031e60,%eax
c002965a:	e9 0d 01 00 00       	jmp    c002976c <ustar_parse_header+0x19f>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c002965f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029662:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029668:	83 ec 04             	sub    $0x4,%esp
c002966b:	8d 45 f0             	lea    -0x10(%ebp),%eax
c002966e:	50                   	push   %eax
c002966f:	6a 08                	push   $0x8
c0029671:	52                   	push   %edx
c0029672:	e8 ac fe ff ff       	call   c0029523 <parse_octal_field>
c0029677:	83 c4 10             	add    $0x10,%esp
c002967a:	83 f0 01             	xor    $0x1,%eax
c002967d:	84 c0                	test   %al,%al
c002967f:	74 0a                	je     c002968b <ustar_parse_header+0xbe>
    return "corrupt chksum field";
c0029681:	b8 76 1e 03 c0       	mov    $0xc0031e76,%eax
c0029686:	e9 e1 00 00 00       	jmp    c002976c <ustar_parse_header+0x19f>
  else if (chksum != calculate_chksum (h))
c002968b:	83 ec 0c             	sub    $0xc,%esp
c002968e:	ff 75 f4             	pushl  -0xc(%ebp)
c0029691:	e8 b4 fb ff ff       	call   c002924a <calculate_chksum>
c0029696:	83 c4 10             	add    $0x10,%esp
c0029699:	89 c2                	mov    %eax,%edx
c002969b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002969e:	39 c2                	cmp    %eax,%edx
c00296a0:	74 0a                	je     c00296ac <ustar_parse_header+0xdf>
    return "checksum mismatch";
c00296a2:	b8 8b 1e 03 c0       	mov    $0xc0031e8b,%eax
c00296a7:	e9 c0 00 00 00       	jmp    c002976c <ustar_parse_header+0x19f>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c00296ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296af:	8a 40 63             	mov    0x63(%eax),%al
c00296b2:	84 c0                	test   %al,%al
c00296b4:	75 0d                	jne    c00296c3 <ustar_parse_header+0xf6>
c00296b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296b9:	8a 80 59 01 00 00    	mov    0x159(%eax),%al
c00296bf:	84 c0                	test   %al,%al
c00296c1:	74 0a                	je     c00296cd <ustar_parse_header+0x100>
    return "file name too long";
c00296c3:	b8 9d 1e 03 c0       	mov    $0xc0031e9d,%eax
c00296c8:	e9 9f 00 00 00       	jmp    c002976c <ustar_parse_header+0x19f>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c00296cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296d0:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c00296d6:	3c 30                	cmp    $0x30,%al
c00296d8:	74 14                	je     c00296ee <ustar_parse_header+0x121>
c00296da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296dd:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c00296e3:	3c 35                	cmp    $0x35,%al
c00296e5:	74 07                	je     c00296ee <ustar_parse_header+0x121>
    return "unimplemented file type";
c00296e7:	b8 b0 1e 03 c0       	mov    $0xc0031eb0,%eax
c00296ec:	eb 7e                	jmp    c002976c <ustar_parse_header+0x19f>
  if (h->typeflag == USTAR_REGULAR)
c00296ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296f1:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c00296f7:	3c 30                	cmp    $0x30,%al
c00296f9:	75 34                	jne    c002972f <ustar_parse_header+0x162>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c00296fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00296fe:	8d 50 7c             	lea    0x7c(%eax),%edx
c0029701:	83 ec 04             	sub    $0x4,%esp
c0029704:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0029707:	50                   	push   %eax
c0029708:	6a 0c                	push   $0xc
c002970a:	52                   	push   %edx
c002970b:	e8 13 fe ff ff       	call   c0029523 <parse_octal_field>
c0029710:	83 c4 10             	add    $0x10,%esp
c0029713:	83 f0 01             	xor    $0x1,%eax
c0029716:	84 c0                	test   %al,%al
c0029718:	74 07                	je     c0029721 <ustar_parse_header+0x154>
        return "corrupt file size field";
c002971a:	b8 c8 1e 03 c0       	mov    $0xc0031ec8,%eax
c002971f:	eb 4b                	jmp    c002976c <ustar_parse_header+0x19f>
      else if (size_ul > INT_MAX)
c0029721:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029724:	85 c0                	test   %eax,%eax
c0029726:	79 0e                	jns    c0029736 <ustar_parse_header+0x169>
        return "file too large";
c0029728:	b8 e0 1e 03 c0       	mov    $0xc0031ee0,%eax
c002972d:	eb 3d                	jmp    c002976c <ustar_parse_header+0x19f>
    }
  else
    size_ul = 0;
c002972f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0029736:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029739:	83 ec 0c             	sub    $0xc,%esp
c002973c:	50                   	push   %eax
c002973d:	e8 89 fb ff ff       	call   c00292cb <strip_antisocial_prefixes>
c0029742:	83 c4 10             	add    $0x10,%esp
c0029745:	89 c2                	mov    %eax,%edx
c0029747:	8b 45 0c             	mov    0xc(%ebp),%eax
c002974a:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c002974c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002974f:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029755:	0f be d0             	movsbl %al,%edx
c0029758:	8b 45 10             	mov    0x10(%ebp),%eax
c002975b:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c002975d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029760:	89 c2                	mov    %eax,%edx
c0029762:	8b 45 14             	mov    0x14(%ebp),%eax
c0029765:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029767:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002976c:	c9                   	leave  
c002976d:	c3                   	ret    

c002976e <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c002976e:	55                   	push   %ebp
c002976f:	89 e5                	mov    %esp,%ebp
c0029771:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c0029774:	e8 4a 7e ff ff       	call   c00215c3 <intr_disable>
  console_panic ();
c0029779:	e8 89 21 00 00       	call   c002b907 <console_panic>

  level++;
c002977e:	a1 a4 a3 03 c0       	mov    0xc003a3a4,%eax
c0029783:	40                   	inc    %eax
c0029784:	a3 a4 a3 03 c0       	mov    %eax,0xc003a3a4
  if (level == 1) 
c0029789:	a1 a4 a3 03 c0       	mov    0xc003a3a4,%eax
c002978e:	83 f8 01             	cmp    $0x1,%eax
c0029791:	75 42                	jne    c00297d5 <debug_panic+0x67>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0029793:	ff 75 10             	pushl  0x10(%ebp)
c0029796:	ff 75 0c             	pushl  0xc(%ebp)
c0029799:	ff 75 08             	pushl  0x8(%ebp)
c002979c:	68 04 1f 03 c0       	push   $0xc0031f04
c00297a1:	e8 09 dc ff ff       	call   c00273af <printf>
c00297a6:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c00297a9:	8d 45 18             	lea    0x18(%ebp),%eax
c00297ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c00297af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00297b2:	83 ec 08             	sub    $0x8,%esp
c00297b5:	50                   	push   %eax
c00297b6:	ff 75 14             	pushl  0x14(%ebp)
c00297b9:	e8 4f 22 00 00       	call   c002ba0d <vprintf>
c00297be:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c00297c1:	83 ec 0c             	sub    $0xc,%esp
c00297c4:	6a 0a                	push   $0xa
c00297c6:	e8 fa 22 00 00       	call   c002bac5 <putchar>
c00297cb:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c00297ce:	e8 cf d8 ff ff       	call   c00270a2 <debug_backtrace>
c00297d3:	eb 20                	jmp    c00297f5 <debug_panic+0x87>
    }
  else if (level == 2)
c00297d5:	a1 a4 a3 03 c0       	mov    0xc003a3a4,%eax
c00297da:	83 f8 02             	cmp    $0x2,%eax
c00297dd:	75 16                	jne    c00297f5 <debug_panic+0x87>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c00297df:	ff 75 10             	pushl  0x10(%ebp)
c00297e2:	ff 75 0c             	pushl  0xc(%ebp)
c00297e5:	ff 75 08             	pushl  0x8(%ebp)
c00297e8:	68 24 1f 03 c0       	push   $0xc0031f24
c00297ed:	e8 bd db ff ff       	call   c00273af <printf>
c00297f2:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c00297f5:	e8 71 b4 ff ff       	call   c0024c6b <serial_flush>
  shutdown ();
c00297fa:	e8 03 d6 ff ff       	call   c0026e02 <shutdown>
  for (;;);
c00297ff:	eb fe                	jmp    c00297ff <debug_panic+0x91>

c0029801 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0029801:	55                   	push   %ebp
c0029802:	89 e5                	mov    %esp,%ebp
c0029804:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c0029807:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002980e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c0029815:	c7 45 ec 4e 1f 03 c0 	movl   $0xc0031f4e,-0x14(%ebp)

  switch (t->status) {
c002981c:	8b 45 08             	mov    0x8(%ebp),%eax
c002981f:	8b 40 04             	mov    0x4(%eax),%eax
c0029822:	83 f8 01             	cmp    $0x1,%eax
c0029825:	74 15                	je     c002983c <print_stacktrace+0x3b>
c0029827:	83 f8 01             	cmp    $0x1,%eax
c002982a:	72 07                	jb     c0029833 <print_stacktrace+0x32>
c002982c:	83 f8 02             	cmp    $0x2,%eax
c002982f:	74 14                	je     c0029845 <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c0029831:	eb 1a                	jmp    c002984d <print_stacktrace+0x4c>
      status = "RUNNING";
c0029833:	c7 45 ec 56 1f 03 c0 	movl   $0xc0031f56,-0x14(%ebp)
      break;
c002983a:	eb 11                	jmp    c002984d <print_stacktrace+0x4c>
      status = "READY";
c002983c:	c7 45 ec 5e 1f 03 c0 	movl   $0xc0031f5e,-0x14(%ebp)
      break;
c0029843:	eb 08                	jmp    c002984d <print_stacktrace+0x4c>
      status = "BLOCKED";
c0029845:	c7 45 ec 64 1f 03 c0 	movl   $0xc0031f64,-0x14(%ebp)
      break;
c002984c:	90                   	nop
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c002984d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029850:	83 c0 08             	add    $0x8,%eax
c0029853:	83 ec 04             	sub    $0x4,%esp
c0029856:	ff 75 ec             	pushl  -0x14(%ebp)
c0029859:	50                   	push   %eax
c002985a:	68 6c 1f 03 c0       	push   $0xc0031f6c
c002985f:	e8 4b db ff ff       	call   c00273af <printf>
c0029864:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c0029867:	e8 f4 75 ff ff       	call   c0020e60 <thread_current>
c002986c:	3b 45 08             	cmp    0x8(%ebp),%eax
c002986f:	75 0e                	jne    c002987f <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c0029871:	8b 45 00             	mov    0x0(%ebp),%eax
c0029874:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c0029877:	8b 45 04             	mov    0x4(%ebp),%eax
c002987a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002987d:	eb 4d                	jmp    c00298cc <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c002987f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029882:	8b 40 18             	mov    0x18(%eax),%eax
c0029885:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029888:	8b 45 08             	mov    0x8(%ebp),%eax
c002988b:	8b 40 18             	mov    0x18(%eax),%eax
c002988e:	8b 55 08             	mov    0x8(%ebp),%edx
c0029891:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0029897:	39 d0                	cmp    %edx,%eax
c0029899:	74 0d                	je     c00298a8 <print_stacktrace+0xa7>
c002989b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002989e:	8b 40 10             	mov    0x10(%eax),%eax
c00298a1:	3d 24 15 02 c0       	cmp    $0xc0021524,%eax
c00298a6:	75 12                	jne    c00298ba <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c00298a8:	83 ec 0c             	sub    $0xc,%esp
c00298ab:	68 93 1f 03 c0       	push   $0xc0031f93
c00298b0:	e8 8b 21 00 00       	call   c002ba40 <puts>
c00298b5:	83 c4 10             	add    $0x10,%esp
          return;
c00298b8:	eb 6b                	jmp    c0029925 <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c00298ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298bd:	8b 40 08             	mov    0x8(%eax),%eax
c00298c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c00298c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00298c6:	8b 40 10             	mov    0x10(%eax),%eax
c00298c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c00298cc:	83 ec 08             	sub    $0x8,%esp
c00298cf:	ff 75 f4             	pushl  -0xc(%ebp)
c00298d2:	68 b0 1f 03 c0       	push   $0xc0031fb0
c00298d7:	e8 d3 da ff ff       	call   c00273af <printf>
c00298dc:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00298df:	eb 21                	jmp    c0029902 <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c00298e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00298e4:	83 c0 04             	add    $0x4,%eax
c00298e7:	8b 00                	mov    (%eax),%eax
c00298e9:	83 ec 08             	sub    $0x8,%esp
c00298ec:	50                   	push   %eax
c00298ed:	68 b0 1f 03 c0       	push   $0xc0031fb0
c00298f2:	e8 b8 da ff ff       	call   c00273af <printf>
c00298f7:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00298fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00298fd:	8b 00                	mov    (%eax),%eax
c00298ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029902:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029905:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002990a:	76 09                	jbe    c0029915 <print_stacktrace+0x114>
c002990c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002990f:	8b 00                	mov    (%eax),%eax
c0029911:	85 c0                	test   %eax,%eax
c0029913:	75 cc                	jne    c00298e1 <print_stacktrace+0xe0>
  printf (".\n");
c0029915:	83 ec 0c             	sub    $0xc,%esp
c0029918:	68 b4 1f 03 c0       	push   $0xc0031fb4
c002991d:	e8 1e 21 00 00       	call   c002ba40 <puts>
c0029922:	83 c4 10             	add    $0x10,%esp
}
c0029925:	c9                   	leave  
c0029926:	c3                   	ret    

c0029927 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0029927:	55                   	push   %ebp
c0029928:	89 e5                	mov    %esp,%ebp
c002992a:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c002992d:	e8 91 7c ff ff       	call   c00215c3 <intr_disable>
c0029932:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c0029935:	83 ec 08             	sub    $0x8,%esp
c0029938:	6a 00                	push   $0x0
c002993a:	68 01 98 02 c0       	push   $0xc0029801
c002993f:	e8 9b 76 ff ff       	call   c0020fdf <thread_foreach>
c0029944:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c0029947:	83 ec 0c             	sub    $0xc,%esp
c002994a:	ff 75 f4             	pushl  -0xc(%ebp)
c002994d:	e8 19 7c ff ff       	call   c002156b <intr_set_level>
c0029952:	83 c4 10             	add    $0x10,%esp
}
c0029955:	90                   	nop
c0029956:	c9                   	leave  
c0029957:	c3                   	ret    

c0029958 <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c0029958:	55                   	push   %ebp
c0029959:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c002995b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002995f:	74 1a                	je     c002997b <is_head+0x23>
c0029961:	8b 45 08             	mov    0x8(%ebp),%eax
c0029964:	8b 00                	mov    (%eax),%eax
c0029966:	85 c0                	test   %eax,%eax
c0029968:	75 11                	jne    c002997b <is_head+0x23>
c002996a:	8b 45 08             	mov    0x8(%ebp),%eax
c002996d:	8b 40 04             	mov    0x4(%eax),%eax
c0029970:	85 c0                	test   %eax,%eax
c0029972:	74 07                	je     c002997b <is_head+0x23>
c0029974:	b8 01 00 00 00       	mov    $0x1,%eax
c0029979:	eb 05                	jmp    c0029980 <is_head+0x28>
c002997b:	b8 00 00 00 00       	mov    $0x0,%eax
c0029980:	83 e0 01             	and    $0x1,%eax
}
c0029983:	5d                   	pop    %ebp
c0029984:	c3                   	ret    

c0029985 <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c0029985:	55                   	push   %ebp
c0029986:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029988:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002998c:	74 1a                	je     c00299a8 <is_interior+0x23>
c002998e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029991:	8b 00                	mov    (%eax),%eax
c0029993:	85 c0                	test   %eax,%eax
c0029995:	74 11                	je     c00299a8 <is_interior+0x23>
c0029997:	8b 45 08             	mov    0x8(%ebp),%eax
c002999a:	8b 40 04             	mov    0x4(%eax),%eax
c002999d:	85 c0                	test   %eax,%eax
c002999f:	74 07                	je     c00299a8 <is_interior+0x23>
c00299a1:	b8 01 00 00 00       	mov    $0x1,%eax
c00299a6:	eb 05                	jmp    c00299ad <is_interior+0x28>
c00299a8:	b8 00 00 00 00       	mov    $0x0,%eax
c00299ad:	83 e0 01             	and    $0x1,%eax
}
c00299b0:	5d                   	pop    %ebp
c00299b1:	c3                   	ret    

c00299b2 <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c00299b2:	55                   	push   %ebp
c00299b3:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c00299b5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00299b9:	74 1a                	je     c00299d5 <is_tail+0x23>
c00299bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00299be:	8b 00                	mov    (%eax),%eax
c00299c0:	85 c0                	test   %eax,%eax
c00299c2:	74 11                	je     c00299d5 <is_tail+0x23>
c00299c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00299c7:	8b 40 04             	mov    0x4(%eax),%eax
c00299ca:	85 c0                	test   %eax,%eax
c00299cc:	75 07                	jne    c00299d5 <is_tail+0x23>
c00299ce:	b8 01 00 00 00       	mov    $0x1,%eax
c00299d3:	eb 05                	jmp    c00299da <is_tail+0x28>
c00299d5:	b8 00 00 00 00       	mov    $0x0,%eax
c00299da:	83 e0 01             	and    $0x1,%eax
}
c00299dd:	5d                   	pop    %ebp
c00299de:	c3                   	ret    

c00299df <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c00299df:	55                   	push   %ebp
c00299e0:	89 e5                	mov    %esp,%ebp
c00299e2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00299e5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00299e9:	75 1e                	jne    c0029a09 <list_init+0x2a>
c00299eb:	83 ec 0c             	sub    $0xc,%esp
c00299ee:	68 b8 1f 03 c0       	push   $0xc0031fb8
c00299f3:	68 c5 1f 03 c0       	push   $0xc0031fc5
c00299f8:	68 90 21 03 c0       	push   $0xc0032190
c00299fd:	6a 3f                	push   $0x3f
c00299ff:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029a04:	e8 65 fd ff ff       	call   c002976e <debug_panic>
  list->head.prev = NULL;
c0029a09:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a0c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0029a12:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a15:	8d 50 08             	lea    0x8(%eax),%edx
c0029a18:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a1b:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0029a1e:	8b 55 08             	mov    0x8(%ebp),%edx
c0029a21:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a24:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c0029a27:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a2a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029a31:	90                   	nop
c0029a32:	c9                   	leave  
c0029a33:	c3                   	ret    

c0029a34 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0029a34:	55                   	push   %ebp
c0029a35:	89 e5                	mov    %esp,%ebp
c0029a37:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029a3a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029a3e:	75 1e                	jne    c0029a5e <list_begin+0x2a>
c0029a40:	83 ec 0c             	sub    $0xc,%esp
c0029a43:	68 b8 1f 03 c0       	push   $0xc0031fb8
c0029a48:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029a4d:	68 9c 21 03 c0       	push   $0xc003219c
c0029a52:	6a 4a                	push   $0x4a
c0029a54:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029a59:	e8 10 fd ff ff       	call   c002976e <debug_panic>
  return list->head.next;
c0029a5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a61:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029a64:	c9                   	leave  
c0029a65:	c3                   	ret    

c0029a66 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0029a66:	55                   	push   %ebp
c0029a67:	89 e5                	mov    %esp,%ebp
c0029a69:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029a6c:	ff 75 08             	pushl  0x8(%ebp)
c0029a6f:	e8 e4 fe ff ff       	call   c0029958 <is_head>
c0029a74:	83 c4 04             	add    $0x4,%esp
c0029a77:	84 c0                	test   %al,%al
c0029a79:	75 2d                	jne    c0029aa8 <list_next+0x42>
c0029a7b:	ff 75 08             	pushl  0x8(%ebp)
c0029a7e:	e8 02 ff ff ff       	call   c0029985 <is_interior>
c0029a83:	83 c4 04             	add    $0x4,%esp
c0029a86:	84 c0                	test   %al,%al
c0029a88:	75 1e                	jne    c0029aa8 <list_next+0x42>
c0029a8a:	83 ec 0c             	sub    $0xc,%esp
c0029a8d:	68 f4 1f 03 c0       	push   $0xc0031ff4
c0029a92:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029a97:	68 a8 21 03 c0       	push   $0xc00321a8
c0029a9c:	6a 54                	push   $0x54
c0029a9e:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029aa3:	e8 c6 fc ff ff       	call   c002976e <debug_panic>
  return elem->next;
c0029aa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0029aab:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029aae:	c9                   	leave  
c0029aaf:	c3                   	ret    

c0029ab0 <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029ab0:	55                   	push   %ebp
c0029ab1:	89 e5                	mov    %esp,%ebp
c0029ab3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ab6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029aba:	75 1e                	jne    c0029ada <list_end+0x2a>
c0029abc:	83 ec 0c             	sub    $0xc,%esp
c0029abf:	68 b8 1f 03 c0       	push   $0xc0031fb8
c0029ac4:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029ac9:	68 b4 21 03 c0       	push   $0xc00321b4
c0029ace:	6a 60                	push   $0x60
c0029ad0:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029ad5:	e8 94 fc ff ff       	call   c002976e <debug_panic>
  return &list->tail;
c0029ada:	8b 45 08             	mov    0x8(%ebp),%eax
c0029add:	83 c0 08             	add    $0x8,%eax
}
c0029ae0:	c9                   	leave  
c0029ae1:	c3                   	ret    

c0029ae2 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0029ae2:	55                   	push   %ebp
c0029ae3:	89 e5                	mov    %esp,%ebp
c0029ae5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ae8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029aec:	75 1e                	jne    c0029b0c <list_rbegin+0x2a>
c0029aee:	83 ec 0c             	sub    $0xc,%esp
c0029af1:	68 b8 1f 03 c0       	push   $0xc0031fb8
c0029af6:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029afb:	68 c0 21 03 c0       	push   $0xc00321c0
c0029b00:	6a 69                	push   $0x69
c0029b02:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029b07:	e8 62 fc ff ff       	call   c002976e <debug_panic>
  return list->tail.prev;
c0029b0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b0f:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029b12:	c9                   	leave  
c0029b13:	c3                   	ret    

c0029b14 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c0029b14:	55                   	push   %ebp
c0029b15:	89 e5                	mov    %esp,%ebp
c0029b17:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c0029b1a:	ff 75 08             	pushl  0x8(%ebp)
c0029b1d:	e8 63 fe ff ff       	call   c0029985 <is_interior>
c0029b22:	83 c4 04             	add    $0x4,%esp
c0029b25:	84 c0                	test   %al,%al
c0029b27:	75 2d                	jne    c0029b56 <list_prev+0x42>
c0029b29:	ff 75 08             	pushl  0x8(%ebp)
c0029b2c:	e8 81 fe ff ff       	call   c00299b2 <is_tail>
c0029b31:	83 c4 04             	add    $0x4,%esp
c0029b34:	84 c0                	test   %al,%al
c0029b36:	75 1e                	jne    c0029b56 <list_prev+0x42>
c0029b38:	83 ec 0c             	sub    $0xc,%esp
c0029b3b:	68 1c 20 03 c0       	push   $0xc003201c
c0029b40:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029b45:	68 cc 21 03 c0       	push   $0xc00321cc
c0029b4a:	6a 73                	push   $0x73
c0029b4c:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029b51:	e8 18 fc ff ff       	call   c002976e <debug_panic>
  return elem->prev;
c0029b56:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b59:	8b 00                	mov    (%eax),%eax
}
c0029b5b:	c9                   	leave  
c0029b5c:	c3                   	ret    

c0029b5d <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0029b5d:	55                   	push   %ebp
c0029b5e:	89 e5                	mov    %esp,%ebp
c0029b60:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029b63:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029b67:	75 21                	jne    c0029b8a <list_rend+0x2d>
c0029b69:	83 ec 0c             	sub    $0xc,%esp
c0029b6c:	68 b8 1f 03 c0       	push   $0xc0031fb8
c0029b71:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029b76:	68 d8 21 03 c0       	push   $0xc00321d8
c0029b7b:	68 87 00 00 00       	push   $0x87
c0029b80:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029b85:	e8 e4 fb ff ff       	call   c002976e <debug_panic>
  return &list->head;
c0029b8a:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029b8d:	c9                   	leave  
c0029b8e:	c3                   	ret    

c0029b8f <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0029b8f:	55                   	push   %ebp
c0029b90:	89 e5                	mov    %esp,%ebp
c0029b92:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029b95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029b99:	75 21                	jne    c0029bbc <list_head+0x2d>
c0029b9b:	83 ec 0c             	sub    $0xc,%esp
c0029b9e:	68 b8 1f 03 c0       	push   $0xc0031fb8
c0029ba3:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029ba8:	68 e4 21 03 c0       	push   $0xc00321e4
c0029bad:	68 99 00 00 00       	push   $0x99
c0029bb2:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029bb7:	e8 b2 fb ff ff       	call   c002976e <debug_panic>
  return &list->head;
c0029bbc:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029bbf:	c9                   	leave  
c0029bc0:	c3                   	ret    

c0029bc1 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c0029bc1:	55                   	push   %ebp
c0029bc2:	89 e5                	mov    %esp,%ebp
c0029bc4:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029bc7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029bcb:	75 21                	jne    c0029bee <list_tail+0x2d>
c0029bcd:	83 ec 0c             	sub    $0xc,%esp
c0029bd0:	68 b8 1f 03 c0       	push   $0xc0031fb8
c0029bd5:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029bda:	68 f0 21 03 c0       	push   $0xc00321f0
c0029bdf:	68 a1 00 00 00       	push   $0xa1
c0029be4:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029be9:	e8 80 fb ff ff       	call   c002976e <debug_panic>
  return &list->tail;
c0029bee:	8b 45 08             	mov    0x8(%ebp),%eax
c0029bf1:	83 c0 08             	add    $0x8,%eax
}
c0029bf4:	c9                   	leave  
c0029bf5:	c3                   	ret    

c0029bf6 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c0029bf6:	55                   	push   %ebp
c0029bf7:	89 e5                	mov    %esp,%ebp
c0029bf9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029bfc:	ff 75 08             	pushl  0x8(%ebp)
c0029bff:	e8 81 fd ff ff       	call   c0029985 <is_interior>
c0029c04:	83 c4 04             	add    $0x4,%esp
c0029c07:	84 c0                	test   %al,%al
c0029c09:	75 30                	jne    c0029c3b <list_insert+0x45>
c0029c0b:	ff 75 08             	pushl  0x8(%ebp)
c0029c0e:	e8 9f fd ff ff       	call   c00299b2 <is_tail>
c0029c13:	83 c4 04             	add    $0x4,%esp
c0029c16:	84 c0                	test   %al,%al
c0029c18:	75 21                	jne    c0029c3b <list_insert+0x45>
c0029c1a:	83 ec 0c             	sub    $0xc,%esp
c0029c1d:	68 44 20 03 c0       	push   $0xc0032044
c0029c22:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029c27:	68 fc 21 03 c0       	push   $0xc00321fc
c0029c2c:	68 ab 00 00 00       	push   $0xab
c0029c31:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029c36:	e8 33 fb ff ff       	call   c002976e <debug_panic>
  ASSERT (elem != NULL);
c0029c3b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029c3f:	75 21                	jne    c0029c62 <list_insert+0x6c>
c0029c41:	83 ec 0c             	sub    $0xc,%esp
c0029c44:	68 6d 20 03 c0       	push   $0xc003206d
c0029c49:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029c4e:	68 fc 21 03 c0       	push   $0xc00321fc
c0029c53:	68 ac 00 00 00       	push   $0xac
c0029c58:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029c5d:	e8 0c fb ff ff       	call   c002976e <debug_panic>

  elem->prev = before->prev;
c0029c62:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c65:	8b 10                	mov    (%eax),%edx
c0029c67:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c6a:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c0029c6c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029c6f:	8b 55 08             	mov    0x8(%ebp),%edx
c0029c72:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c0029c75:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c78:	8b 00                	mov    (%eax),%eax
c0029c7a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029c7d:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c0029c80:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c83:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029c86:	89 10                	mov    %edx,(%eax)
}
c0029c88:	90                   	nop
c0029c89:	c9                   	leave  
c0029c8a:	c3                   	ret    

c0029c8b <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c0029c8b:	55                   	push   %ebp
c0029c8c:	89 e5                	mov    %esp,%ebp
c0029c8e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029c91:	ff 75 08             	pushl  0x8(%ebp)
c0029c94:	e8 ec fc ff ff       	call   c0029985 <is_interior>
c0029c99:	83 c4 04             	add    $0x4,%esp
c0029c9c:	84 c0                	test   %al,%al
c0029c9e:	75 30                	jne    c0029cd0 <list_splice+0x45>
c0029ca0:	ff 75 08             	pushl  0x8(%ebp)
c0029ca3:	e8 0a fd ff ff       	call   c00299b2 <is_tail>
c0029ca8:	83 c4 04             	add    $0x4,%esp
c0029cab:	84 c0                	test   %al,%al
c0029cad:	75 21                	jne    c0029cd0 <list_splice+0x45>
c0029caf:	83 ec 0c             	sub    $0xc,%esp
c0029cb2:	68 44 20 03 c0       	push   $0xc0032044
c0029cb7:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029cbc:	68 08 22 03 c0       	push   $0xc0032208
c0029cc1:	68 bb 00 00 00       	push   $0xbb
c0029cc6:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029ccb:	e8 9e fa ff ff       	call   c002976e <debug_panic>
  if (first == last)
c0029cd0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029cd3:	3b 45 10             	cmp    0x10(%ebp),%eax
c0029cd6:	0f 84 ba 00 00 00    	je     c0029d96 <list_splice+0x10b>
    return;
  last = list_prev (last);
c0029cdc:	83 ec 0c             	sub    $0xc,%esp
c0029cdf:	ff 75 10             	pushl  0x10(%ebp)
c0029ce2:	e8 2d fe ff ff       	call   c0029b14 <list_prev>
c0029ce7:	83 c4 10             	add    $0x10,%esp
c0029cea:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c0029ced:	83 ec 0c             	sub    $0xc,%esp
c0029cf0:	ff 75 0c             	pushl  0xc(%ebp)
c0029cf3:	e8 8d fc ff ff       	call   c0029985 <is_interior>
c0029cf8:	83 c4 10             	add    $0x10,%esp
c0029cfb:	84 c0                	test   %al,%al
c0029cfd:	75 21                	jne    c0029d20 <list_splice+0x95>
c0029cff:	83 ec 0c             	sub    $0xc,%esp
c0029d02:	68 7a 20 03 c0       	push   $0xc003207a
c0029d07:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029d0c:	68 08 22 03 c0       	push   $0xc0032208
c0029d11:	68 c0 00 00 00       	push   $0xc0
c0029d16:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029d1b:	e8 4e fa ff ff       	call   c002976e <debug_panic>
  ASSERT (is_interior (last));
c0029d20:	83 ec 0c             	sub    $0xc,%esp
c0029d23:	ff 75 10             	pushl  0x10(%ebp)
c0029d26:	e8 5a fc ff ff       	call   c0029985 <is_interior>
c0029d2b:	83 c4 10             	add    $0x10,%esp
c0029d2e:	84 c0                	test   %al,%al
c0029d30:	75 21                	jne    c0029d53 <list_splice+0xc8>
c0029d32:	83 ec 0c             	sub    $0xc,%esp
c0029d35:	68 8e 20 03 c0       	push   $0xc003208e
c0029d3a:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029d3f:	68 08 22 03 c0       	push   $0xc0032208
c0029d44:	68 c1 00 00 00       	push   $0xc1
c0029d49:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029d4e:	e8 1b fa ff ff       	call   c002976e <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c0029d53:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d56:	8b 00                	mov    (%eax),%eax
c0029d58:	8b 55 10             	mov    0x10(%ebp),%edx
c0029d5b:	8b 52 04             	mov    0x4(%edx),%edx
c0029d5e:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c0029d61:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d64:	8b 40 04             	mov    0x4(%eax),%eax
c0029d67:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029d6a:	8b 12                	mov    (%edx),%edx
c0029d6c:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c0029d6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d71:	8b 10                	mov    (%eax),%edx
c0029d73:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d76:	89 10                	mov    %edx,(%eax)
  last->next = before;
c0029d78:	8b 45 10             	mov    0x10(%ebp),%eax
c0029d7b:	8b 55 08             	mov    0x8(%ebp),%edx
c0029d7e:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c0029d81:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d84:	8b 00                	mov    (%eax),%eax
c0029d86:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029d89:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c0029d8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d8f:	8b 55 10             	mov    0x10(%ebp),%edx
c0029d92:	89 10                	mov    %edx,(%eax)
c0029d94:	eb 01                	jmp    c0029d97 <list_splice+0x10c>
    return;
c0029d96:	90                   	nop
}
c0029d97:	c9                   	leave  
c0029d98:	c3                   	ret    

c0029d99 <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c0029d99:	55                   	push   %ebp
c0029d9a:	89 e5                	mov    %esp,%ebp
c0029d9c:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c0029d9f:	83 ec 0c             	sub    $0xc,%esp
c0029da2:	ff 75 08             	pushl  0x8(%ebp)
c0029da5:	e8 8a fc ff ff       	call   c0029a34 <list_begin>
c0029daa:	83 c4 10             	add    $0x10,%esp
c0029dad:	83 ec 08             	sub    $0x8,%esp
c0029db0:	ff 75 0c             	pushl  0xc(%ebp)
c0029db3:	50                   	push   %eax
c0029db4:	e8 3d fe ff ff       	call   c0029bf6 <list_insert>
c0029db9:	83 c4 10             	add    $0x10,%esp
}
c0029dbc:	90                   	nop
c0029dbd:	c9                   	leave  
c0029dbe:	c3                   	ret    

c0029dbf <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c0029dbf:	55                   	push   %ebp
c0029dc0:	89 e5                	mov    %esp,%ebp
c0029dc2:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c0029dc5:	83 ec 0c             	sub    $0xc,%esp
c0029dc8:	ff 75 08             	pushl  0x8(%ebp)
c0029dcb:	e8 e0 fc ff ff       	call   c0029ab0 <list_end>
c0029dd0:	83 c4 10             	add    $0x10,%esp
c0029dd3:	83 ec 08             	sub    $0x8,%esp
c0029dd6:	ff 75 0c             	pushl  0xc(%ebp)
c0029dd9:	50                   	push   %eax
c0029dda:	e8 17 fe ff ff       	call   c0029bf6 <list_insert>
c0029ddf:	83 c4 10             	add    $0x10,%esp
}
c0029de2:	90                   	nop
c0029de3:	c9                   	leave  
c0029de4:	c3                   	ret    

c0029de5 <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c0029de5:	55                   	push   %ebp
c0029de6:	89 e5                	mov    %esp,%ebp
c0029de8:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c0029deb:	ff 75 08             	pushl  0x8(%ebp)
c0029dee:	e8 92 fb ff ff       	call   c0029985 <is_interior>
c0029df3:	83 c4 04             	add    $0x4,%esp
c0029df6:	84 c0                	test   %al,%al
c0029df8:	75 21                	jne    c0029e1b <list_remove+0x36>
c0029dfa:	83 ec 0c             	sub    $0xc,%esp
c0029dfd:	68 a1 20 03 c0       	push   $0xc00320a1
c0029e02:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029e07:	68 14 22 03 c0       	push   $0xc0032214
c0029e0c:	68 fb 00 00 00       	push   $0xfb
c0029e11:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029e16:	e8 53 f9 ff ff       	call   c002976e <debug_panic>
  elem->prev->next = elem->next;
c0029e1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e1e:	8b 00                	mov    (%eax),%eax
c0029e20:	8b 55 08             	mov    0x8(%ebp),%edx
c0029e23:	8b 52 04             	mov    0x4(%edx),%edx
c0029e26:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c0029e29:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e2c:	8b 40 04             	mov    0x4(%eax),%eax
c0029e2f:	8b 55 08             	mov    0x8(%ebp),%edx
c0029e32:	8b 12                	mov    (%edx),%edx
c0029e34:	89 10                	mov    %edx,(%eax)
  return elem->next;
c0029e36:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e39:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029e3c:	c9                   	leave  
c0029e3d:	c3                   	ret    

c0029e3e <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c0029e3e:	55                   	push   %ebp
c0029e3f:	89 e5                	mov    %esp,%ebp
c0029e41:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c0029e44:	83 ec 0c             	sub    $0xc,%esp
c0029e47:	ff 75 08             	pushl  0x8(%ebp)
c0029e4a:	e8 43 00 00 00       	call   c0029e92 <list_front>
c0029e4f:	83 c4 10             	add    $0x10,%esp
c0029e52:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c0029e55:	83 ec 0c             	sub    $0xc,%esp
c0029e58:	ff 75 f4             	pushl  -0xc(%ebp)
c0029e5b:	e8 85 ff ff ff       	call   c0029de5 <list_remove>
c0029e60:	83 c4 10             	add    $0x10,%esp
  return front;
c0029e63:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029e66:	c9                   	leave  
c0029e67:	c3                   	ret    

c0029e68 <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c0029e68:	55                   	push   %ebp
c0029e69:	89 e5                	mov    %esp,%ebp
c0029e6b:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c0029e6e:	83 ec 0c             	sub    $0xc,%esp
c0029e71:	ff 75 08             	pushl  0x8(%ebp)
c0029e74:	e8 5d 00 00 00       	call   c0029ed6 <list_back>
c0029e79:	83 c4 10             	add    $0x10,%esp
c0029e7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c0029e7f:	83 ec 0c             	sub    $0xc,%esp
c0029e82:	ff 75 f4             	pushl  -0xc(%ebp)
c0029e85:	e8 5b ff ff ff       	call   c0029de5 <list_remove>
c0029e8a:	83 c4 10             	add    $0x10,%esp
  return back;
c0029e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029e90:	c9                   	leave  
c0029e91:	c3                   	ret    

c0029e92 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c0029e92:	55                   	push   %ebp
c0029e93:	89 e5                	mov    %esp,%ebp
c0029e95:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029e98:	83 ec 0c             	sub    $0xc,%esp
c0029e9b:	ff 75 08             	pushl  0x8(%ebp)
c0029e9e:	e8 c3 00 00 00       	call   c0029f66 <list_empty>
c0029ea3:	83 c4 10             	add    $0x10,%esp
c0029ea6:	83 f0 01             	xor    $0x1,%eax
c0029ea9:	84 c0                	test   %al,%al
c0029eab:	75 21                	jne    c0029ece <list_front+0x3c>
c0029ead:	83 ec 0c             	sub    $0xc,%esp
c0029eb0:	68 b4 20 03 c0       	push   $0xc00320b4
c0029eb5:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029eba:	68 20 22 03 c0       	push   $0xc0032220
c0029ebf:	68 1a 01 00 00       	push   $0x11a
c0029ec4:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029ec9:	e8 a0 f8 ff ff       	call   c002976e <debug_panic>
  return list->head.next;
c0029ece:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ed1:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029ed4:	c9                   	leave  
c0029ed5:	c3                   	ret    

c0029ed6 <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c0029ed6:	55                   	push   %ebp
c0029ed7:	89 e5                	mov    %esp,%ebp
c0029ed9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029edc:	83 ec 0c             	sub    $0xc,%esp
c0029edf:	ff 75 08             	pushl  0x8(%ebp)
c0029ee2:	e8 7f 00 00 00       	call   c0029f66 <list_empty>
c0029ee7:	83 c4 10             	add    $0x10,%esp
c0029eea:	83 f0 01             	xor    $0x1,%eax
c0029eed:	84 c0                	test   %al,%al
c0029eef:	75 21                	jne    c0029f12 <list_back+0x3c>
c0029ef1:	83 ec 0c             	sub    $0xc,%esp
c0029ef4:	68 b4 20 03 c0       	push   $0xc00320b4
c0029ef9:	68 c5 1f 03 c0       	push   $0xc0031fc5
c0029efe:	68 2c 22 03 c0       	push   $0xc003222c
c0029f03:	68 23 01 00 00       	push   $0x123
c0029f08:	68 dc 1f 03 c0       	push   $0xc0031fdc
c0029f0d:	e8 5c f8 ff ff       	call   c002976e <debug_panic>
  return list->tail.prev;
c0029f12:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f15:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029f18:	c9                   	leave  
c0029f19:	c3                   	ret    

c0029f1a <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c0029f1a:	55                   	push   %ebp
c0029f1b:	89 e5                	mov    %esp,%ebp
c0029f1d:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c0029f20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029f27:	83 ec 0c             	sub    $0xc,%esp
c0029f2a:	ff 75 08             	pushl  0x8(%ebp)
c0029f2d:	e8 02 fb ff ff       	call   c0029a34 <list_begin>
c0029f32:	83 c4 10             	add    $0x10,%esp
c0029f35:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029f38:	eb 14                	jmp    c0029f4e <list_size+0x34>
    cnt++;
c0029f3a:	ff 45 f0             	incl   -0x10(%ebp)
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029f3d:	83 ec 0c             	sub    $0xc,%esp
c0029f40:	ff 75 f4             	pushl  -0xc(%ebp)
c0029f43:	e8 1e fb ff ff       	call   c0029a66 <list_next>
c0029f48:	83 c4 10             	add    $0x10,%esp
c0029f4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029f4e:	83 ec 0c             	sub    $0xc,%esp
c0029f51:	ff 75 08             	pushl  0x8(%ebp)
c0029f54:	e8 57 fb ff ff       	call   c0029ab0 <list_end>
c0029f59:	83 c4 10             	add    $0x10,%esp
c0029f5c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029f5f:	75 d9                	jne    c0029f3a <list_size+0x20>
  return cnt;
c0029f61:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029f64:	c9                   	leave  
c0029f65:	c3                   	ret    

c0029f66 <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c0029f66:	55                   	push   %ebp
c0029f67:	89 e5                	mov    %esp,%ebp
c0029f69:	53                   	push   %ebx
c0029f6a:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c0029f6d:	83 ec 0c             	sub    $0xc,%esp
c0029f70:	ff 75 08             	pushl  0x8(%ebp)
c0029f73:	e8 bc fa ff ff       	call   c0029a34 <list_begin>
c0029f78:	83 c4 10             	add    $0x10,%esp
c0029f7b:	89 c3                	mov    %eax,%ebx
c0029f7d:	83 ec 0c             	sub    $0xc,%esp
c0029f80:	ff 75 08             	pushl  0x8(%ebp)
c0029f83:	e8 28 fb ff ff       	call   c0029ab0 <list_end>
c0029f88:	83 c4 10             	add    $0x10,%esp
c0029f8b:	39 c3                	cmp    %eax,%ebx
c0029f8d:	0f 94 c0             	sete   %al
}
c0029f90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029f93:	c9                   	leave  
c0029f94:	c3                   	ret    

c0029f95 <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c0029f95:	55                   	push   %ebp
c0029f96:	89 e5                	mov    %esp,%ebp
c0029f98:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c0029f9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f9e:	8b 00                	mov    (%eax),%eax
c0029fa0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c0029fa3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029fa6:	8b 10                	mov    (%eax),%edx
c0029fa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fab:	89 10                	mov    %edx,(%eax)
  *b = t;
c0029fad:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029fb0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029fb3:	89 10                	mov    %edx,(%eax)
}
c0029fb5:	90                   	nop
c0029fb6:	c9                   	leave  
c0029fb7:	c3                   	ret    

c0029fb8 <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c0029fb8:	55                   	push   %ebp
c0029fb9:	89 e5                	mov    %esp,%ebp
c0029fbb:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c0029fbe:	83 ec 0c             	sub    $0xc,%esp
c0029fc1:	ff 75 08             	pushl  0x8(%ebp)
c0029fc4:	e8 9d ff ff ff       	call   c0029f66 <list_empty>
c0029fc9:	83 c4 10             	add    $0x10,%esp
c0029fcc:	83 f0 01             	xor    $0x1,%eax
c0029fcf:	84 c0                	test   %al,%al
c0029fd1:	74 79                	je     c002a04c <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029fd3:	83 ec 0c             	sub    $0xc,%esp
c0029fd6:	ff 75 08             	pushl  0x8(%ebp)
c0029fd9:	e8 56 fa ff ff       	call   c0029a34 <list_begin>
c0029fde:	83 c4 10             	add    $0x10,%esp
c0029fe1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029fe4:	eb 1e                	jmp    c002a004 <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c0029fe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029fe9:	8d 50 04             	lea    0x4(%eax),%edx
c0029fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029fef:	83 ec 08             	sub    $0x8,%esp
c0029ff2:	52                   	push   %edx
c0029ff3:	50                   	push   %eax
c0029ff4:	e8 9c ff ff ff       	call   c0029f95 <swap>
c0029ff9:	83 c4 10             	add    $0x10,%esp
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029ffc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029fff:	8b 00                	mov    (%eax),%eax
c002a001:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a004:	83 ec 0c             	sub    $0xc,%esp
c002a007:	ff 75 08             	pushl  0x8(%ebp)
c002a00a:	e8 a1 fa ff ff       	call   c0029ab0 <list_end>
c002a00f:	83 c4 10             	add    $0x10,%esp
c002a012:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a015:	75 cf                	jne    c0029fe6 <list_reverse+0x2e>
      swap (&list->head.next, &list->tail.prev);
c002a017:	8b 45 08             	mov    0x8(%ebp),%eax
c002a01a:	8d 50 08             	lea    0x8(%eax),%edx
c002a01d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a020:	83 c0 04             	add    $0x4,%eax
c002a023:	83 ec 08             	sub    $0x8,%esp
c002a026:	52                   	push   %edx
c002a027:	50                   	push   %eax
c002a028:	e8 68 ff ff ff       	call   c0029f95 <swap>
c002a02d:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c002a030:	8b 45 08             	mov    0x8(%ebp),%eax
c002a033:	8b 40 08             	mov    0x8(%eax),%eax
c002a036:	8d 50 04             	lea    0x4(%eax),%edx
c002a039:	8b 45 08             	mov    0x8(%ebp),%eax
c002a03c:	8b 40 04             	mov    0x4(%eax),%eax
c002a03f:	83 ec 08             	sub    $0x8,%esp
c002a042:	52                   	push   %edx
c002a043:	50                   	push   %eax
c002a044:	e8 4c ff ff ff       	call   c0029f95 <swap>
c002a049:	83 c4 10             	add    $0x10,%esp
    }
}
c002a04c:	90                   	nop
c002a04d:	c9                   	leave  
c002a04e:	c3                   	ret    

c002a04f <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c002a04f:	55                   	push   %ebp
c002a050:	89 e5                	mov    %esp,%ebp
c002a052:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c002a055:	8b 45 08             	mov    0x8(%ebp),%eax
c002a058:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a05b:	74 43                	je     c002a0a0 <is_sorted+0x51>
    while ((a = list_next (a)) != b) 
c002a05d:	eb 28                	jmp    c002a087 <is_sorted+0x38>
      if (less (a, list_prev (a), aux))
c002a05f:	83 ec 0c             	sub    $0xc,%esp
c002a062:	ff 75 08             	pushl  0x8(%ebp)
c002a065:	e8 aa fa ff ff       	call   c0029b14 <list_prev>
c002a06a:	83 c4 10             	add    $0x10,%esp
c002a06d:	83 ec 04             	sub    $0x4,%esp
c002a070:	ff 75 14             	pushl  0x14(%ebp)
c002a073:	50                   	push   %eax
c002a074:	ff 75 08             	pushl  0x8(%ebp)
c002a077:	8b 45 10             	mov    0x10(%ebp),%eax
c002a07a:	ff d0                	call   *%eax
c002a07c:	83 c4 10             	add    $0x10,%esp
c002a07f:	84 c0                	test   %al,%al
c002a081:	74 04                	je     c002a087 <is_sorted+0x38>
        return false;
c002a083:	b0 00                	mov    $0x0,%al
c002a085:	eb 1b                	jmp    c002a0a2 <is_sorted+0x53>
    while ((a = list_next (a)) != b) 
c002a087:	83 ec 0c             	sub    $0xc,%esp
c002a08a:	ff 75 08             	pushl  0x8(%ebp)
c002a08d:	e8 d4 f9 ff ff       	call   c0029a66 <list_next>
c002a092:	83 c4 10             	add    $0x10,%esp
c002a095:	89 45 08             	mov    %eax,0x8(%ebp)
c002a098:	8b 45 08             	mov    0x8(%ebp),%eax
c002a09b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a09e:	75 bf                	jne    c002a05f <is_sorted+0x10>
  return true;
c002a0a0:	b0 01                	mov    $0x1,%al
}
c002a0a2:	c9                   	leave  
c002a0a3:	c3                   	ret    

c002a0a4 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002a0a4:	55                   	push   %ebp
c002a0a5:	89 e5                	mov    %esp,%ebp
c002a0a7:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c002a0aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a0ae:	75 21                	jne    c002a0d1 <find_end_of_run+0x2d>
c002a0b0:	83 ec 0c             	sub    $0xc,%esp
c002a0b3:	68 c7 20 03 c0       	push   $0xc00320c7
c002a0b8:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a0bd:	68 38 22 03 c0       	push   $0xc0032238
c002a0c2:	68 69 01 00 00       	push   $0x169
c002a0c7:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a0cc:	e8 9d f6 ff ff       	call   c002976e <debug_panic>
  ASSERT (b != NULL);
c002a0d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a0d5:	75 21                	jne    c002a0f8 <find_end_of_run+0x54>
c002a0d7:	83 ec 0c             	sub    $0xc,%esp
c002a0da:	68 d1 20 03 c0       	push   $0xc00320d1
c002a0df:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a0e4:	68 38 22 03 c0       	push   $0xc0032238
c002a0e9:	68 6a 01 00 00       	push   $0x16a
c002a0ee:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a0f3:	e8 76 f6 ff ff       	call   c002976e <debug_panic>
  ASSERT (less != NULL);
c002a0f8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a0fc:	75 21                	jne    c002a11f <find_end_of_run+0x7b>
c002a0fe:	83 ec 0c             	sub    $0xc,%esp
c002a101:	68 db 20 03 c0       	push   $0xc00320db
c002a106:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a10b:	68 38 22 03 c0       	push   $0xc0032238
c002a110:	68 6b 01 00 00       	push   $0x16b
c002a115:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a11a:	e8 4f f6 ff ff       	call   c002976e <debug_panic>
  ASSERT (a != b);
c002a11f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a122:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a125:	75 21                	jne    c002a148 <find_end_of_run+0xa4>
c002a127:	83 ec 0c             	sub    $0xc,%esp
c002a12a:	68 e8 20 03 c0       	push   $0xc00320e8
c002a12f:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a134:	68 38 22 03 c0       	push   $0xc0032238
c002a139:	68 6c 01 00 00       	push   $0x16c
c002a13e:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a143:	e8 26 f6 ff ff       	call   c002976e <debug_panic>
  
  do 
    {
      a = list_next (a);
c002a148:	83 ec 0c             	sub    $0xc,%esp
c002a14b:	ff 75 08             	pushl  0x8(%ebp)
c002a14e:	e8 13 f9 ff ff       	call   c0029a66 <list_next>
c002a153:	83 c4 10             	add    $0x10,%esp
c002a156:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002a159:	8b 45 08             	mov    0x8(%ebp),%eax
c002a15c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a15f:	74 27                	je     c002a188 <find_end_of_run+0xe4>
c002a161:	83 ec 0c             	sub    $0xc,%esp
c002a164:	ff 75 08             	pushl  0x8(%ebp)
c002a167:	e8 a8 f9 ff ff       	call   c0029b14 <list_prev>
c002a16c:	83 c4 10             	add    $0x10,%esp
c002a16f:	83 ec 04             	sub    $0x4,%esp
c002a172:	ff 75 14             	pushl  0x14(%ebp)
c002a175:	50                   	push   %eax
c002a176:	ff 75 08             	pushl  0x8(%ebp)
c002a179:	8b 45 10             	mov    0x10(%ebp),%eax
c002a17c:	ff d0                	call   *%eax
c002a17e:	83 c4 10             	add    $0x10,%esp
c002a181:	83 f0 01             	xor    $0x1,%eax
c002a184:	84 c0                	test   %al,%al
c002a186:	75 c0                	jne    c002a148 <find_end_of_run+0xa4>
  return a;
c002a188:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a18b:	c9                   	leave  
c002a18c:	c3                   	ret    

c002a18d <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002a18d:	55                   	push   %ebp
c002a18e:	89 e5                	mov    %esp,%ebp
c002a190:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c002a193:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a197:	75 21                	jne    c002a1ba <inplace_merge+0x2d>
c002a199:	83 ec 0c             	sub    $0xc,%esp
c002a19c:	68 ef 20 03 c0       	push   $0xc00320ef
c002a1a1:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a1a6:	68 48 22 03 c0       	push   $0xc0032248
c002a1ab:	68 80 01 00 00       	push   $0x180
c002a1b0:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a1b5:	e8 b4 f5 ff ff       	call   c002976e <debug_panic>
  ASSERT (a1b0 != NULL);
c002a1ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a1be:	75 21                	jne    c002a1e1 <inplace_merge+0x54>
c002a1c0:	83 ec 0c             	sub    $0xc,%esp
c002a1c3:	68 fa 20 03 c0       	push   $0xc00320fa
c002a1c8:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a1cd:	68 48 22 03 c0       	push   $0xc0032248
c002a1d2:	68 81 01 00 00       	push   $0x181
c002a1d7:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a1dc:	e8 8d f5 ff ff       	call   c002976e <debug_panic>
  ASSERT (b1 != NULL);
c002a1e1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a1e5:	75 21                	jne    c002a208 <inplace_merge+0x7b>
c002a1e7:	83 ec 0c             	sub    $0xc,%esp
c002a1ea:	68 07 21 03 c0       	push   $0xc0032107
c002a1ef:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a1f4:	68 48 22 03 c0       	push   $0xc0032248
c002a1f9:	68 82 01 00 00       	push   $0x182
c002a1fe:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a203:	e8 66 f5 ff ff       	call   c002976e <debug_panic>
  ASSERT (less != NULL);
c002a208:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002a20c:	75 21                	jne    c002a22f <inplace_merge+0xa2>
c002a20e:	83 ec 0c             	sub    $0xc,%esp
c002a211:	68 db 20 03 c0       	push   $0xc00320db
c002a216:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a21b:	68 48 22 03 c0       	push   $0xc0032248
c002a220:	68 83 01 00 00       	push   $0x183
c002a225:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a22a:	e8 3f f5 ff ff       	call   c002976e <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002a22f:	ff 75 18             	pushl  0x18(%ebp)
c002a232:	ff 75 14             	pushl  0x14(%ebp)
c002a235:	ff 75 0c             	pushl  0xc(%ebp)
c002a238:	ff 75 08             	pushl  0x8(%ebp)
c002a23b:	e8 0f fe ff ff       	call   c002a04f <is_sorted>
c002a240:	83 c4 10             	add    $0x10,%esp
c002a243:	84 c0                	test   %al,%al
c002a245:	75 21                	jne    c002a268 <inplace_merge+0xdb>
c002a247:	83 ec 0c             	sub    $0xc,%esp
c002a24a:	68 14 21 03 c0       	push   $0xc0032114
c002a24f:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a254:	68 48 22 03 c0       	push   $0xc0032248
c002a259:	68 84 01 00 00       	push   $0x184
c002a25e:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a263:	e8 06 f5 ff ff       	call   c002976e <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a268:	ff 75 18             	pushl  0x18(%ebp)
c002a26b:	ff 75 14             	pushl  0x14(%ebp)
c002a26e:	ff 75 10             	pushl  0x10(%ebp)
c002a271:	ff 75 0c             	pushl  0xc(%ebp)
c002a274:	e8 d6 fd ff ff       	call   c002a04f <is_sorted>
c002a279:	83 c4 10             	add    $0x10,%esp
c002a27c:	84 c0                	test   %al,%al
c002a27e:	0f 85 80 00 00 00    	jne    c002a304 <inplace_merge+0x177>
c002a284:	83 ec 0c             	sub    $0xc,%esp
c002a287:	68 34 21 03 c0       	push   $0xc0032134
c002a28c:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a291:	68 48 22 03 c0       	push   $0xc0032248
c002a296:	68 85 01 00 00       	push   $0x185
c002a29b:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a2a0:	e8 c9 f4 ff ff       	call   c002976e <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a2a5:	83 ec 04             	sub    $0x4,%esp
c002a2a8:	ff 75 18             	pushl  0x18(%ebp)
c002a2ab:	ff 75 08             	pushl  0x8(%ebp)
c002a2ae:	ff 75 0c             	pushl  0xc(%ebp)
c002a2b1:	8b 45 14             	mov    0x14(%ebp),%eax
c002a2b4:	ff d0                	call   *%eax
c002a2b6:	83 c4 10             	add    $0x10,%esp
c002a2b9:	83 f0 01             	xor    $0x1,%eax
c002a2bc:	84 c0                	test   %al,%al
c002a2be:	74 13                	je     c002a2d3 <inplace_merge+0x146>
      a0 = list_next (a0);
c002a2c0:	83 ec 0c             	sub    $0xc,%esp
c002a2c3:	ff 75 08             	pushl  0x8(%ebp)
c002a2c6:	e8 9b f7 ff ff       	call   c0029a66 <list_next>
c002a2cb:	83 c4 10             	add    $0x10,%esp
c002a2ce:	89 45 08             	mov    %eax,0x8(%ebp)
c002a2d1:	eb 31                	jmp    c002a304 <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a2d3:	83 ec 0c             	sub    $0xc,%esp
c002a2d6:	ff 75 0c             	pushl  0xc(%ebp)
c002a2d9:	e8 88 f7 ff ff       	call   c0029a66 <list_next>
c002a2de:	83 c4 10             	add    $0x10,%esp
c002a2e1:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a2e4:	83 ec 0c             	sub    $0xc,%esp
c002a2e7:	ff 75 0c             	pushl  0xc(%ebp)
c002a2ea:	e8 25 f8 ff ff       	call   c0029b14 <list_prev>
c002a2ef:	83 c4 10             	add    $0x10,%esp
c002a2f2:	83 ec 04             	sub    $0x4,%esp
c002a2f5:	ff 75 0c             	pushl  0xc(%ebp)
c002a2f8:	50                   	push   %eax
c002a2f9:	ff 75 08             	pushl  0x8(%ebp)
c002a2fc:	e8 8a f9 ff ff       	call   c0029c8b <list_splice>
c002a301:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002a304:	8b 45 08             	mov    0x8(%ebp),%eax
c002a307:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a30a:	74 08                	je     c002a314 <inplace_merge+0x187>
c002a30c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a30f:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a312:	75 91                	jne    c002a2a5 <inplace_merge+0x118>
      }
}
c002a314:	90                   	nop
c002a315:	c9                   	leave  
c002a316:	c3                   	ret    

c002a317 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a317:	55                   	push   %ebp
c002a318:	89 e5                	mov    %esp,%ebp
c002a31a:	53                   	push   %ebx
c002a31b:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a31e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a322:	75 21                	jne    c002a345 <list_sort+0x2e>
c002a324:	83 ec 0c             	sub    $0xc,%esp
c002a327:	68 b8 1f 03 c0       	push   $0xc0031fb8
c002a32c:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a331:	68 58 22 03 c0       	push   $0xc0032258
c002a336:	68 99 01 00 00       	push   $0x199
c002a33b:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a340:	e8 29 f4 ff ff       	call   c002976e <debug_panic>
  ASSERT (less != NULL);
c002a345:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a349:	75 21                	jne    c002a36c <list_sort+0x55>
c002a34b:	83 ec 0c             	sub    $0xc,%esp
c002a34e:	68 db 20 03 c0       	push   $0xc00320db
c002a353:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a358:	68 58 22 03 c0       	push   $0xc0032258
c002a35d:	68 9a 01 00 00       	push   $0x19a
c002a362:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a367:	e8 02 f4 ff ff       	call   c002976e <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a36c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a373:	83 ec 0c             	sub    $0xc,%esp
c002a376:	ff 75 08             	pushl  0x8(%ebp)
c002a379:	e8 b6 f6 ff ff       	call   c0029a34 <list_begin>
c002a37e:	83 c4 10             	add    $0x10,%esp
c002a381:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a384:	eb 7c                	jmp    c002a402 <list_sort+0xeb>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a386:	ff 45 f4             	incl   -0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a389:	83 ec 0c             	sub    $0xc,%esp
c002a38c:	ff 75 08             	pushl  0x8(%ebp)
c002a38f:	e8 1c f7 ff ff       	call   c0029ab0 <list_end>
c002a394:	83 c4 10             	add    $0x10,%esp
c002a397:	ff 75 10             	pushl  0x10(%ebp)
c002a39a:	ff 75 0c             	pushl  0xc(%ebp)
c002a39d:	50                   	push   %eax
c002a39e:	ff 75 f0             	pushl  -0x10(%ebp)
c002a3a1:	e8 fe fc ff ff       	call   c002a0a4 <find_end_of_run>
c002a3a6:	83 c4 10             	add    $0x10,%esp
c002a3a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a3ac:	83 ec 0c             	sub    $0xc,%esp
c002a3af:	ff 75 08             	pushl  0x8(%ebp)
c002a3b2:	e8 f9 f6 ff ff       	call   c0029ab0 <list_end>
c002a3b7:	83 c4 10             	add    $0x10,%esp
c002a3ba:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a3bd:	74 5c                	je     c002a41b <list_sort+0x104>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a3bf:	83 ec 0c             	sub    $0xc,%esp
c002a3c2:	ff 75 08             	pushl  0x8(%ebp)
c002a3c5:	e8 e6 f6 ff ff       	call   c0029ab0 <list_end>
c002a3ca:	83 c4 10             	add    $0x10,%esp
c002a3cd:	ff 75 10             	pushl  0x10(%ebp)
c002a3d0:	ff 75 0c             	pushl  0xc(%ebp)
c002a3d3:	50                   	push   %eax
c002a3d4:	ff 75 ec             	pushl  -0x14(%ebp)
c002a3d7:	e8 c8 fc ff ff       	call   c002a0a4 <find_end_of_run>
c002a3dc:	83 c4 10             	add    $0x10,%esp
c002a3df:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a3e2:	83 ec 0c             	sub    $0xc,%esp
c002a3e5:	ff 75 10             	pushl  0x10(%ebp)
c002a3e8:	ff 75 0c             	pushl  0xc(%ebp)
c002a3eb:	ff 75 e8             	pushl  -0x18(%ebp)
c002a3ee:	ff 75 ec             	pushl  -0x14(%ebp)
c002a3f1:	ff 75 f0             	pushl  -0x10(%ebp)
c002a3f4:	e8 94 fd ff ff       	call   c002a18d <inplace_merge>
c002a3f9:	83 c4 20             	add    $0x20,%esp
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a3fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a3ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a402:	83 ec 0c             	sub    $0xc,%esp
c002a405:	ff 75 08             	pushl  0x8(%ebp)
c002a408:	e8 a3 f6 ff ff       	call   c0029ab0 <list_end>
c002a40d:	83 c4 10             	add    $0x10,%esp
c002a410:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a413:	0f 85 6d ff ff ff    	jne    c002a386 <list_sort+0x6f>
c002a419:	eb 01                	jmp    c002a41c <list_sort+0x105>
            break;
c002a41b:	90                   	nop
        }
    }
  while (output_run_cnt > 1);
c002a41c:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a420:	0f 87 46 ff ff ff    	ja     c002a36c <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a426:	83 ec 0c             	sub    $0xc,%esp
c002a429:	ff 75 08             	pushl  0x8(%ebp)
c002a42c:	e8 7f f6 ff ff       	call   c0029ab0 <list_end>
c002a431:	83 c4 10             	add    $0x10,%esp
c002a434:	89 c3                	mov    %eax,%ebx
c002a436:	83 ec 0c             	sub    $0xc,%esp
c002a439:	ff 75 08             	pushl  0x8(%ebp)
c002a43c:	e8 f3 f5 ff ff       	call   c0029a34 <list_begin>
c002a441:	83 c4 10             	add    $0x10,%esp
c002a444:	ff 75 10             	pushl  0x10(%ebp)
c002a447:	ff 75 0c             	pushl  0xc(%ebp)
c002a44a:	53                   	push   %ebx
c002a44b:	50                   	push   %eax
c002a44c:	e8 fe fb ff ff       	call   c002a04f <is_sorted>
c002a451:	83 c4 10             	add    $0x10,%esp
c002a454:	84 c0                	test   %al,%al
c002a456:	75 21                	jne    c002a479 <list_sort+0x162>
c002a458:	83 ec 0c             	sub    $0xc,%esp
c002a45b:	68 54 21 03 c0       	push   $0xc0032154
c002a460:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a465:	68 58 22 03 c0       	push   $0xc0032258
c002a46a:	68 b7 01 00 00       	push   $0x1b7
c002a46f:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a474:	e8 f5 f2 ff ff       	call   c002976e <debug_panic>
}
c002a479:	90                   	nop
c002a47a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a47d:	c9                   	leave  
c002a47e:	c3                   	ret    

c002a47f <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a47f:	55                   	push   %ebp
c002a480:	89 e5                	mov    %esp,%ebp
c002a482:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a485:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a489:	75 21                	jne    c002a4ac <list_insert_ordered+0x2d>
c002a48b:	83 ec 0c             	sub    $0xc,%esp
c002a48e:	68 b8 1f 03 c0       	push   $0xc0031fb8
c002a493:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a498:	68 64 22 03 c0       	push   $0xc0032264
c002a49d:	68 c3 01 00 00       	push   $0x1c3
c002a4a2:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a4a7:	e8 c2 f2 ff ff       	call   c002976e <debug_panic>
  ASSERT (elem != NULL);
c002a4ac:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a4b0:	75 21                	jne    c002a4d3 <list_insert_ordered+0x54>
c002a4b2:	83 ec 0c             	sub    $0xc,%esp
c002a4b5:	68 6d 20 03 c0       	push   $0xc003206d
c002a4ba:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a4bf:	68 64 22 03 c0       	push   $0xc0032264
c002a4c4:	68 c4 01 00 00       	push   $0x1c4
c002a4c9:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a4ce:	e8 9b f2 ff ff       	call   c002976e <debug_panic>
  ASSERT (less != NULL);
c002a4d3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a4d7:	75 21                	jne    c002a4fa <list_insert_ordered+0x7b>
c002a4d9:	83 ec 0c             	sub    $0xc,%esp
c002a4dc:	68 db 20 03 c0       	push   $0xc00320db
c002a4e1:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a4e6:	68 64 22 03 c0       	push   $0xc0032264
c002a4eb:	68 c5 01 00 00       	push   $0x1c5
c002a4f0:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a4f5:	e8 74 f2 ff ff       	call   c002976e <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a4fa:	83 ec 0c             	sub    $0xc,%esp
c002a4fd:	ff 75 08             	pushl  0x8(%ebp)
c002a500:	e8 2f f5 ff ff       	call   c0029a34 <list_begin>
c002a505:	83 c4 10             	add    $0x10,%esp
c002a508:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a50b:	eb 29                	jmp    c002a536 <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a50d:	83 ec 04             	sub    $0x4,%esp
c002a510:	ff 75 14             	pushl  0x14(%ebp)
c002a513:	ff 75 f4             	pushl  -0xc(%ebp)
c002a516:	ff 75 0c             	pushl  0xc(%ebp)
c002a519:	8b 45 10             	mov    0x10(%ebp),%eax
c002a51c:	ff d0                	call   *%eax
c002a51e:	83 c4 10             	add    $0x10,%esp
c002a521:	84 c0                	test   %al,%al
c002a523:	75 26                	jne    c002a54b <list_insert_ordered+0xcc>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a525:	83 ec 0c             	sub    $0xc,%esp
c002a528:	ff 75 f4             	pushl  -0xc(%ebp)
c002a52b:	e8 36 f5 ff ff       	call   c0029a66 <list_next>
c002a530:	83 c4 10             	add    $0x10,%esp
c002a533:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a536:	83 ec 0c             	sub    $0xc,%esp
c002a539:	ff 75 08             	pushl  0x8(%ebp)
c002a53c:	e8 6f f5 ff ff       	call   c0029ab0 <list_end>
c002a541:	83 c4 10             	add    $0x10,%esp
c002a544:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a547:	75 c4                	jne    c002a50d <list_insert_ordered+0x8e>
c002a549:	eb 01                	jmp    c002a54c <list_insert_ordered+0xcd>
      break;
c002a54b:	90                   	nop
  return list_insert (e, elem);
c002a54c:	83 ec 08             	sub    $0x8,%esp
c002a54f:	ff 75 0c             	pushl  0xc(%ebp)
c002a552:	ff 75 f4             	pushl  -0xc(%ebp)
c002a555:	e8 9c f6 ff ff       	call   c0029bf6 <list_insert>
c002a55a:	83 c4 10             	add    $0x10,%esp
}
c002a55d:	c9                   	leave  
c002a55e:	c3                   	ret    

c002a55f <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002a55f:	55                   	push   %ebp
c002a560:	89 e5                	mov    %esp,%ebp
c002a562:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002a565:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a569:	75 21                	jne    c002a58c <list_unique+0x2d>
c002a56b:	83 ec 0c             	sub    $0xc,%esp
c002a56e:	68 b8 1f 03 c0       	push   $0xc0031fb8
c002a573:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a578:	68 78 22 03 c0       	push   $0xc0032278
c002a57d:	68 d7 01 00 00       	push   $0x1d7
c002a582:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a587:	e8 e2 f1 ff ff       	call   c002976e <debug_panic>
  ASSERT (less != NULL);
c002a58c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a590:	75 21                	jne    c002a5b3 <list_unique+0x54>
c002a592:	83 ec 0c             	sub    $0xc,%esp
c002a595:	68 db 20 03 c0       	push   $0xc00320db
c002a59a:	68 c5 1f 03 c0       	push   $0xc0031fc5
c002a59f:	68 78 22 03 c0       	push   $0xc0032278
c002a5a4:	68 d8 01 00 00       	push   $0x1d8
c002a5a9:	68 dc 1f 03 c0       	push   $0xc0031fdc
c002a5ae:	e8 bb f1 ff ff       	call   c002976e <debug_panic>
  if (list_empty (list))
c002a5b3:	83 ec 0c             	sub    $0xc,%esp
c002a5b6:	ff 75 08             	pushl  0x8(%ebp)
c002a5b9:	e8 a8 f9 ff ff       	call   c0029f66 <list_empty>
c002a5be:	83 c4 10             	add    $0x10,%esp
c002a5c1:	84 c0                	test   %al,%al
c002a5c3:	0f 85 a0 00 00 00    	jne    c002a669 <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002a5c9:	83 ec 0c             	sub    $0xc,%esp
c002a5cc:	ff 75 08             	pushl  0x8(%ebp)
c002a5cf:	e8 60 f4 ff ff       	call   c0029a34 <list_begin>
c002a5d4:	83 c4 10             	add    $0x10,%esp
c002a5d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a5da:	eb 63                	jmp    c002a63f <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002a5dc:	83 ec 04             	sub    $0x4,%esp
c002a5df:	ff 75 14             	pushl  0x14(%ebp)
c002a5e2:	ff 75 f0             	pushl  -0x10(%ebp)
c002a5e5:	ff 75 f4             	pushl  -0xc(%ebp)
c002a5e8:	8b 45 10             	mov    0x10(%ebp),%eax
c002a5eb:	ff d0                	call   *%eax
c002a5ed:	83 c4 10             	add    $0x10,%esp
c002a5f0:	83 f0 01             	xor    $0x1,%eax
c002a5f3:	84 c0                	test   %al,%al
c002a5f5:	74 42                	je     c002a639 <list_unique+0xda>
c002a5f7:	83 ec 04             	sub    $0x4,%esp
c002a5fa:	ff 75 14             	pushl  0x14(%ebp)
c002a5fd:	ff 75 f4             	pushl  -0xc(%ebp)
c002a600:	ff 75 f0             	pushl  -0x10(%ebp)
c002a603:	8b 45 10             	mov    0x10(%ebp),%eax
c002a606:	ff d0                	call   *%eax
c002a608:	83 c4 10             	add    $0x10,%esp
c002a60b:	83 f0 01             	xor    $0x1,%eax
c002a60e:	84 c0                	test   %al,%al
c002a610:	74 27                	je     c002a639 <list_unique+0xda>
      {
        list_remove (next);
c002a612:	83 ec 0c             	sub    $0xc,%esp
c002a615:	ff 75 f0             	pushl  -0x10(%ebp)
c002a618:	e8 c8 f7 ff ff       	call   c0029de5 <list_remove>
c002a61d:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a620:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a624:	74 19                	je     c002a63f <list_unique+0xe0>
          list_push_back (duplicates, next);
c002a626:	83 ec 08             	sub    $0x8,%esp
c002a629:	ff 75 f0             	pushl  -0x10(%ebp)
c002a62c:	ff 75 0c             	pushl  0xc(%ebp)
c002a62f:	e8 8b f7 ff ff       	call   c0029dbf <list_push_back>
c002a634:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a637:	eb 06                	jmp    c002a63f <list_unique+0xe0>
      }
    else
      elem = next;
c002a639:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a63c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a63f:	83 ec 0c             	sub    $0xc,%esp
c002a642:	ff 75 f4             	pushl  -0xc(%ebp)
c002a645:	e8 1c f4 ff ff       	call   c0029a66 <list_next>
c002a64a:	83 c4 10             	add    $0x10,%esp
c002a64d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a650:	83 ec 0c             	sub    $0xc,%esp
c002a653:	ff 75 08             	pushl  0x8(%ebp)
c002a656:	e8 55 f4 ff ff       	call   c0029ab0 <list_end>
c002a65b:	83 c4 10             	add    $0x10,%esp
c002a65e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a661:	0f 85 75 ff ff ff    	jne    c002a5dc <list_unique+0x7d>
c002a667:	eb 01                	jmp    c002a66a <list_unique+0x10b>
    return;
c002a669:	90                   	nop
}
c002a66a:	c9                   	leave  
c002a66b:	c3                   	ret    

c002a66c <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002a66c:	55                   	push   %ebp
c002a66d:	89 e5                	mov    %esp,%ebp
c002a66f:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002a672:	83 ec 0c             	sub    $0xc,%esp
c002a675:	ff 75 08             	pushl  0x8(%ebp)
c002a678:	e8 b7 f3 ff ff       	call   c0029a34 <list_begin>
c002a67d:	83 c4 10             	add    $0x10,%esp
c002a680:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002a683:	83 ec 0c             	sub    $0xc,%esp
c002a686:	ff 75 08             	pushl  0x8(%ebp)
c002a689:	e8 22 f4 ff ff       	call   c0029ab0 <list_end>
c002a68e:	83 c4 10             	add    $0x10,%esp
c002a691:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a694:	74 55                	je     c002a6eb <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a696:	83 ec 0c             	sub    $0xc,%esp
c002a699:	ff 75 f4             	pushl  -0xc(%ebp)
c002a69c:	e8 c5 f3 ff ff       	call   c0029a66 <list_next>
c002a6a1:	83 c4 10             	add    $0x10,%esp
c002a6a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a6a7:	eb 2f                	jmp    c002a6d8 <list_max+0x6c>
        if (less (max, e, aux))
c002a6a9:	83 ec 04             	sub    $0x4,%esp
c002a6ac:	ff 75 10             	pushl  0x10(%ebp)
c002a6af:	ff 75 f0             	pushl  -0x10(%ebp)
c002a6b2:	ff 75 f4             	pushl  -0xc(%ebp)
c002a6b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a6b8:	ff d0                	call   *%eax
c002a6ba:	83 c4 10             	add    $0x10,%esp
c002a6bd:	84 c0                	test   %al,%al
c002a6bf:	74 06                	je     c002a6c7 <list_max+0x5b>
          max = e; 
c002a6c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a6c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a6c7:	83 ec 0c             	sub    $0xc,%esp
c002a6ca:	ff 75 f0             	pushl  -0x10(%ebp)
c002a6cd:	e8 94 f3 ff ff       	call   c0029a66 <list_next>
c002a6d2:	83 c4 10             	add    $0x10,%esp
c002a6d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a6d8:	83 ec 0c             	sub    $0xc,%esp
c002a6db:	ff 75 08             	pushl  0x8(%ebp)
c002a6de:	e8 cd f3 ff ff       	call   c0029ab0 <list_end>
c002a6e3:	83 c4 10             	add    $0x10,%esp
c002a6e6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a6e9:	75 be                	jne    c002a6a9 <list_max+0x3d>
    }
  return max;
c002a6eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a6ee:	c9                   	leave  
c002a6ef:	c3                   	ret    

c002a6f0 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002a6f0:	55                   	push   %ebp
c002a6f1:	89 e5                	mov    %esp,%ebp
c002a6f3:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002a6f6:	83 ec 0c             	sub    $0xc,%esp
c002a6f9:	ff 75 08             	pushl  0x8(%ebp)
c002a6fc:	e8 33 f3 ff ff       	call   c0029a34 <list_begin>
c002a701:	83 c4 10             	add    $0x10,%esp
c002a704:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002a707:	83 ec 0c             	sub    $0xc,%esp
c002a70a:	ff 75 08             	pushl  0x8(%ebp)
c002a70d:	e8 9e f3 ff ff       	call   c0029ab0 <list_end>
c002a712:	83 c4 10             	add    $0x10,%esp
c002a715:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a718:	74 55                	je     c002a76f <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a71a:	83 ec 0c             	sub    $0xc,%esp
c002a71d:	ff 75 f4             	pushl  -0xc(%ebp)
c002a720:	e8 41 f3 ff ff       	call   c0029a66 <list_next>
c002a725:	83 c4 10             	add    $0x10,%esp
c002a728:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a72b:	eb 2f                	jmp    c002a75c <list_min+0x6c>
        if (less (e, min, aux))
c002a72d:	83 ec 04             	sub    $0x4,%esp
c002a730:	ff 75 10             	pushl  0x10(%ebp)
c002a733:	ff 75 f4             	pushl  -0xc(%ebp)
c002a736:	ff 75 f0             	pushl  -0x10(%ebp)
c002a739:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a73c:	ff d0                	call   *%eax
c002a73e:	83 c4 10             	add    $0x10,%esp
c002a741:	84 c0                	test   %al,%al
c002a743:	74 06                	je     c002a74b <list_min+0x5b>
          min = e; 
c002a745:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a748:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a74b:	83 ec 0c             	sub    $0xc,%esp
c002a74e:	ff 75 f0             	pushl  -0x10(%ebp)
c002a751:	e8 10 f3 ff ff       	call   c0029a66 <list_next>
c002a756:	83 c4 10             	add    $0x10,%esp
c002a759:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a75c:	83 ec 0c             	sub    $0xc,%esp
c002a75f:	ff 75 08             	pushl  0x8(%ebp)
c002a762:	e8 49 f3 ff ff       	call   c0029ab0 <list_end>
c002a767:	83 c4 10             	add    $0x10,%esp
c002a76a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a76d:	75 be                	jne    c002a72d <list_min+0x3d>
    }
  return min;
c002a76f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a772:	c9                   	leave  
c002a773:	c3                   	ret    

c002a774 <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002a774:	55                   	push   %ebp
c002a775:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002a777:	8b 45 08             	mov    0x8(%ebp),%eax
c002a77a:	c1 e8 05             	shr    $0x5,%eax
}
c002a77d:	5d                   	pop    %ebp
c002a77e:	c3                   	ret    

c002a77f <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002a77f:	55                   	push   %ebp
c002a780:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a782:	8b 45 08             	mov    0x8(%ebp),%eax
c002a785:	83 e0 1f             	and    $0x1f,%eax
c002a788:	ba 01 00 00 00       	mov    $0x1,%edx
c002a78d:	88 c1                	mov    %al,%cl
c002a78f:	d3 e2                	shl    %cl,%edx
c002a791:	89 d0                	mov    %edx,%eax
}
c002a793:	5d                   	pop    %ebp
c002a794:	c3                   	ret    

c002a795 <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002a795:	55                   	push   %ebp
c002a796:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a798:	8b 45 08             	mov    0x8(%ebp),%eax
c002a79b:	83 c0 1f             	add    $0x1f,%eax
c002a79e:	c1 e8 05             	shr    $0x5,%eax
}
c002a7a1:	5d                   	pop    %ebp
c002a7a2:	c3                   	ret    

c002a7a3 <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002a7a3:	55                   	push   %ebp
c002a7a4:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a7a6:	ff 75 08             	pushl  0x8(%ebp)
c002a7a9:	e8 e7 ff ff ff       	call   c002a795 <elem_cnt>
c002a7ae:	83 c4 04             	add    $0x4,%esp
c002a7b1:	c1 e0 02             	shl    $0x2,%eax
}
c002a7b4:	c9                   	leave  
c002a7b5:	c3                   	ret    

c002a7b6 <last_mask>:

/* Returns a bit mask in which the bits actually used in the last
   element of B's bits are set to 1 and the rest are set to 0. */
static inline elem_type
last_mask (const struct bitmap *b) 
{
c002a7b6:	55                   	push   %ebp
c002a7b7:	89 e5                	mov    %esp,%ebp
c002a7b9:	83 ec 10             	sub    $0x10,%esp
  int last_bits = b->bit_cnt % ELEM_BITS;
c002a7bc:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7bf:	8b 00                	mov    (%eax),%eax
c002a7c1:	83 e0 1f             	and    $0x1f,%eax
c002a7c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return last_bits ? ((elem_type) 1 << last_bits) - 1 : (elem_type) -1;
c002a7c7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c002a7cb:	74 11                	je     c002a7de <last_mask+0x28>
c002a7cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002a7d0:	ba 01 00 00 00       	mov    $0x1,%edx
c002a7d5:	88 c1                	mov    %al,%cl
c002a7d7:	d3 e2                	shl    %cl,%edx
c002a7d9:	89 d0                	mov    %edx,%eax
c002a7db:	48                   	dec    %eax
c002a7dc:	eb 05                	jmp    c002a7e3 <last_mask+0x2d>
c002a7de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002a7e3:	c9                   	leave  
c002a7e4:	c3                   	ret    

c002a7e5 <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002a7e5:	55                   	push   %ebp
c002a7e6:	89 e5                	mov    %esp,%ebp
c002a7e8:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002a7eb:	83 ec 0c             	sub    $0xc,%esp
c002a7ee:	6a 08                	push   $0x8
c002a7f0:	e8 9d 8e ff ff       	call   c0023692 <malloc>
c002a7f5:	83 c4 10             	add    $0x10,%esp
c002a7f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002a7fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a7ff:	74 5d                	je     c002a85e <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002a801:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a804:	8b 55 08             	mov    0x8(%ebp),%edx
c002a807:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a809:	83 ec 0c             	sub    $0xc,%esp
c002a80c:	ff 75 08             	pushl  0x8(%ebp)
c002a80f:	e8 8f ff ff ff       	call   c002a7a3 <byte_cnt>
c002a814:	83 c4 10             	add    $0x10,%esp
c002a817:	83 ec 0c             	sub    $0xc,%esp
c002a81a:	50                   	push   %eax
c002a81b:	e8 72 8e ff ff       	call   c0023692 <malloc>
c002a820:	83 c4 10             	add    $0x10,%esp
c002a823:	89 c2                	mov    %eax,%edx
c002a825:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a828:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002a82b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a82e:	8b 40 04             	mov    0x4(%eax),%eax
c002a831:	85 c0                	test   %eax,%eax
c002a833:	75 06                	jne    c002a83b <bitmap_create+0x56>
c002a835:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a839:	75 15                	jne    c002a850 <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002a83b:	83 ec 08             	sub    $0x8,%esp
c002a83e:	6a 00                	push   $0x0
c002a840:	ff 75 f4             	pushl  -0xc(%ebp)
c002a843:	e8 92 02 00 00       	call   c002aada <bitmap_set_all>
c002a848:	83 c4 10             	add    $0x10,%esp
          return b;
c002a84b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a84e:	eb 13                	jmp    c002a863 <bitmap_create+0x7e>
        }
      free (b);
c002a850:	83 ec 0c             	sub    $0xc,%esp
c002a853:	ff 75 f4             	pushl  -0xc(%ebp)
c002a856:	e8 31 91 ff ff       	call   c002398c <free>
c002a85b:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002a85e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a863:	c9                   	leave  
c002a864:	c3                   	ret    

c002a865 <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002a865:	55                   	push   %ebp
c002a866:	89 e5                	mov    %esp,%ebp
c002a868:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002a86b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a86e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a871:	83 ec 0c             	sub    $0xc,%esp
c002a874:	ff 75 08             	pushl  0x8(%ebp)
c002a877:	e8 4f 00 00 00       	call   c002a8cb <bitmap_buf_size>
c002a87c:	83 c4 10             	add    $0x10,%esp
c002a87f:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a882:	76 1e                	jbe    c002a8a2 <bitmap_create_in_buf+0x3d>
c002a884:	83 ec 0c             	sub    $0xc,%esp
c002a887:	68 84 22 03 c0       	push   $0xc0032284
c002a88c:	68 ac 22 03 c0       	push   $0xc00322ac
c002a891:	68 28 23 03 c0       	push   $0xc0032328
c002a896:	6a 68                	push   $0x68
c002a898:	68 c3 22 03 c0       	push   $0xc00322c3
c002a89d:	e8 cc ee ff ff       	call   c002976e <debug_panic>

  b->bit_cnt = bit_cnt;
c002a8a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a8a5:	8b 55 08             	mov    0x8(%ebp),%edx
c002a8a8:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002a8aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a8ad:	8d 50 08             	lea    0x8(%eax),%edx
c002a8b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a8b3:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002a8b6:	83 ec 08             	sub    $0x8,%esp
c002a8b9:	6a 00                	push   $0x0
c002a8bb:	ff 75 f4             	pushl  -0xc(%ebp)
c002a8be:	e8 17 02 00 00       	call   c002aada <bitmap_set_all>
c002a8c3:	83 c4 10             	add    $0x10,%esp
  return b;
c002a8c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a8c9:	c9                   	leave  
c002a8ca:	c3                   	ret    

c002a8cb <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002a8cb:	55                   	push   %ebp
c002a8cc:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002a8ce:	ff 75 08             	pushl  0x8(%ebp)
c002a8d1:	e8 cd fe ff ff       	call   c002a7a3 <byte_cnt>
c002a8d6:	83 c4 04             	add    $0x4,%esp
c002a8d9:	83 c0 08             	add    $0x8,%eax
}
c002a8dc:	c9                   	leave  
c002a8dd:	c3                   	ret    

c002a8de <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002a8de:	55                   	push   %ebp
c002a8df:	89 e5                	mov    %esp,%ebp
c002a8e1:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002a8e4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a8e8:	74 20                	je     c002a90a <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002a8ea:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8ed:	8b 40 04             	mov    0x4(%eax),%eax
c002a8f0:	83 ec 0c             	sub    $0xc,%esp
c002a8f3:	50                   	push   %eax
c002a8f4:	e8 93 90 ff ff       	call   c002398c <free>
c002a8f9:	83 c4 10             	add    $0x10,%esp
      free (b);
c002a8fc:	83 ec 0c             	sub    $0xc,%esp
c002a8ff:	ff 75 08             	pushl  0x8(%ebp)
c002a902:	e8 85 90 ff ff       	call   c002398c <free>
c002a907:	83 c4 10             	add    $0x10,%esp
    }
}
c002a90a:	90                   	nop
c002a90b:	c9                   	leave  
c002a90c:	c3                   	ret    

c002a90d <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002a90d:	55                   	push   %ebp
c002a90e:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002a910:	8b 45 08             	mov    0x8(%ebp),%eax
c002a913:	8b 00                	mov    (%eax),%eax
}
c002a915:	5d                   	pop    %ebp
c002a916:	c3                   	ret    

c002a917 <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002a917:	55                   	push   %ebp
c002a918:	89 e5                	mov    %esp,%ebp
c002a91a:	83 ec 18             	sub    $0x18,%esp
c002a91d:	8b 45 10             	mov    0x10(%ebp),%eax
c002a920:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a923:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a927:	75 21                	jne    c002a94a <bitmap_set+0x33>
c002a929:	83 ec 0c             	sub    $0xc,%esp
c002a92c:	68 dd 22 03 c0       	push   $0xc00322dd
c002a931:	68 ac 22 03 c0       	push   $0xc00322ac
c002a936:	68 40 23 03 c0       	push   $0xc0032340
c002a93b:	68 93 00 00 00       	push   $0x93
c002a940:	68 c3 22 03 c0       	push   $0xc00322c3
c002a945:	e8 24 ee ff ff       	call   c002976e <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a94a:	8b 45 08             	mov    0x8(%ebp),%eax
c002a94d:	8b 00                	mov    (%eax),%eax
c002a94f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a952:	77 21                	ja     c002a975 <bitmap_set+0x5e>
c002a954:	83 ec 0c             	sub    $0xc,%esp
c002a957:	68 e7 22 03 c0       	push   $0xc00322e7
c002a95c:	68 ac 22 03 c0       	push   $0xc00322ac
c002a961:	68 40 23 03 c0       	push   $0xc0032340
c002a966:	68 94 00 00 00       	push   $0x94
c002a96b:	68 c3 22 03 c0       	push   $0xc00322c3
c002a970:	e8 f9 ed ff ff       	call   c002976e <debug_panic>
  if (value)
c002a975:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002a979:	74 13                	je     c002a98e <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002a97b:	83 ec 08             	sub    $0x8,%esp
c002a97e:	ff 75 0c             	pushl  0xc(%ebp)
c002a981:	ff 75 08             	pushl  0x8(%ebp)
c002a984:	e8 19 00 00 00       	call   c002a9a2 <bitmap_mark>
c002a989:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002a98c:	eb 11                	jmp    c002a99f <bitmap_set+0x88>
    bitmap_reset (b, idx);
c002a98e:	83 ec 08             	sub    $0x8,%esp
c002a991:	ff 75 0c             	pushl  0xc(%ebp)
c002a994:	ff 75 08             	pushl  0x8(%ebp)
c002a997:	e8 3e 00 00 00       	call   c002a9da <bitmap_reset>
c002a99c:	83 c4 10             	add    $0x10,%esp
}
c002a99f:	90                   	nop
c002a9a0:	c9                   	leave  
c002a9a1:	c3                   	ret    

c002a9a2 <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a9a2:	55                   	push   %ebp
c002a9a3:	89 e5                	mov    %esp,%ebp
c002a9a5:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a9a8:	ff 75 0c             	pushl  0xc(%ebp)
c002a9ab:	e8 c4 fd ff ff       	call   c002a774 <elem_idx>
c002a9b0:	83 c4 04             	add    $0x4,%esp
c002a9b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a9b6:	ff 75 0c             	pushl  0xc(%ebp)
c002a9b9:	e8 c1 fd ff ff       	call   c002a77f <bit_mask>
c002a9be:	83 c4 04             	add    $0x4,%esp
c002a9c1:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a9c4:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9c7:	8b 40 04             	mov    0x4(%eax),%eax
c002a9ca:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a9cd:	c1 e2 02             	shl    $0x2,%edx
c002a9d0:	01 c2                	add    %eax,%edx
c002a9d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a9d5:	09 02                	or     %eax,(%edx)
}
c002a9d7:	90                   	nop
c002a9d8:	c9                   	leave  
c002a9d9:	c3                   	ret    

c002a9da <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a9da:	55                   	push   %ebp
c002a9db:	89 e5                	mov    %esp,%ebp
c002a9dd:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a9e0:	ff 75 0c             	pushl  0xc(%ebp)
c002a9e3:	e8 8c fd ff ff       	call   c002a774 <elem_idx>
c002a9e8:	83 c4 04             	add    $0x4,%esp
c002a9eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a9ee:	ff 75 0c             	pushl  0xc(%ebp)
c002a9f1:	e8 89 fd ff ff       	call   c002a77f <bit_mask>
c002a9f6:	83 c4 04             	add    $0x4,%esp
c002a9f9:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a9fc:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9ff:	8b 40 04             	mov    0x4(%eax),%eax
c002aa02:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002aa05:	c1 e2 02             	shl    $0x2,%edx
c002aa08:	01 d0                	add    %edx,%eax
c002aa0a:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002aa0d:	f7 d2                	not    %edx
c002aa0f:	21 10                	and    %edx,(%eax)
}
c002aa11:	90                   	nop
c002aa12:	c9                   	leave  
c002aa13:	c3                   	ret    

c002aa14 <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002aa14:	55                   	push   %ebp
c002aa15:	89 e5                	mov    %esp,%ebp
c002aa17:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002aa1a:	ff 75 0c             	pushl  0xc(%ebp)
c002aa1d:	e8 52 fd ff ff       	call   c002a774 <elem_idx>
c002aa22:	83 c4 04             	add    $0x4,%esp
c002aa25:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002aa28:	ff 75 0c             	pushl  0xc(%ebp)
c002aa2b:	e8 4f fd ff ff       	call   c002a77f <bit_mask>
c002aa30:	83 c4 04             	add    $0x4,%esp
c002aa33:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002aa36:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa39:	8b 40 04             	mov    0x4(%eax),%eax
c002aa3c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002aa3f:	c1 e2 02             	shl    $0x2,%edx
c002aa42:	01 c2                	add    %eax,%edx
c002aa44:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002aa47:	31 02                	xor    %eax,(%edx)
}
c002aa49:	90                   	nop
c002aa4a:	c9                   	leave  
c002aa4b:	c3                   	ret    

c002aa4c <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002aa4c:	55                   	push   %ebp
c002aa4d:	89 e5                	mov    %esp,%ebp
c002aa4f:	53                   	push   %ebx
c002aa50:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002aa53:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa57:	75 21                	jne    c002aa7a <bitmap_test+0x2e>
c002aa59:	83 ec 0c             	sub    $0xc,%esp
c002aa5c:	68 dd 22 03 c0       	push   $0xc00322dd
c002aa61:	68 ac 22 03 c0       	push   $0xc00322ac
c002aa66:	68 4c 23 03 c0       	push   $0xc003234c
c002aa6b:	68 c8 00 00 00       	push   $0xc8
c002aa70:	68 c3 22 03 c0       	push   $0xc00322c3
c002aa75:	e8 f4 ec ff ff       	call   c002976e <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002aa7a:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa7d:	8b 00                	mov    (%eax),%eax
c002aa7f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aa82:	77 21                	ja     c002aaa5 <bitmap_test+0x59>
c002aa84:	83 ec 0c             	sub    $0xc,%esp
c002aa87:	68 e7 22 03 c0       	push   $0xc00322e7
c002aa8c:	68 ac 22 03 c0       	push   $0xc00322ac
c002aa91:	68 4c 23 03 c0       	push   $0xc003234c
c002aa96:	68 c9 00 00 00       	push   $0xc9
c002aa9b:	68 c3 22 03 c0       	push   $0xc00322c3
c002aaa0:	e8 c9 ec ff ff       	call   c002976e <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002aaa5:	8b 45 08             	mov    0x8(%ebp),%eax
c002aaa8:	8b 58 04             	mov    0x4(%eax),%ebx
c002aaab:	83 ec 0c             	sub    $0xc,%esp
c002aaae:	ff 75 0c             	pushl  0xc(%ebp)
c002aab1:	e8 be fc ff ff       	call   c002a774 <elem_idx>
c002aab6:	83 c4 10             	add    $0x10,%esp
c002aab9:	c1 e0 02             	shl    $0x2,%eax
c002aabc:	01 d8                	add    %ebx,%eax
c002aabe:	8b 18                	mov    (%eax),%ebx
c002aac0:	83 ec 0c             	sub    $0xc,%esp
c002aac3:	ff 75 0c             	pushl  0xc(%ebp)
c002aac6:	e8 b4 fc ff ff       	call   c002a77f <bit_mask>
c002aacb:	83 c4 10             	add    $0x10,%esp
c002aace:	21 d8                	and    %ebx,%eax
c002aad0:	85 c0                	test   %eax,%eax
c002aad2:	0f 95 c0             	setne  %al
}
c002aad5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002aad8:	c9                   	leave  
c002aad9:	c3                   	ret    

c002aada <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002aada:	55                   	push   %ebp
c002aadb:	89 e5                	mov    %esp,%ebp
c002aadd:	53                   	push   %ebx
c002aade:	83 ec 14             	sub    $0x14,%esp
c002aae1:	8b 45 0c             	mov    0xc(%ebp),%eax
c002aae4:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002aae7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aaeb:	75 21                	jne    c002ab0e <bitmap_set_all+0x34>
c002aaed:	83 ec 0c             	sub    $0xc,%esp
c002aaf0:	68 dd 22 03 c0       	push   $0xc00322dd
c002aaf5:	68 ac 22 03 c0       	push   $0xc00322ac
c002aafa:	68 58 23 03 c0       	push   $0xc0032358
c002aaff:	68 d3 00 00 00       	push   $0xd3
c002ab04:	68 c3 22 03 c0       	push   $0xc00322c3
c002ab09:	e8 60 ec ff ff       	call   c002976e <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002ab0e:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002ab12:	83 ec 0c             	sub    $0xc,%esp
c002ab15:	ff 75 08             	pushl  0x8(%ebp)
c002ab18:	e8 f0 fd ff ff       	call   c002a90d <bitmap_size>
c002ab1d:	83 c4 10             	add    $0x10,%esp
c002ab20:	53                   	push   %ebx
c002ab21:	50                   	push   %eax
c002ab22:	6a 00                	push   $0x0
c002ab24:	ff 75 08             	pushl  0x8(%ebp)
c002ab27:	e8 09 00 00 00       	call   c002ab35 <bitmap_set_multiple>
c002ab2c:	83 c4 10             	add    $0x10,%esp
}
c002ab2f:	90                   	nop
c002ab30:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ab33:	c9                   	leave  
c002ab34:	c3                   	ret    

c002ab35 <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002ab35:	55                   	push   %ebp
c002ab36:	89 e5                	mov    %esp,%ebp
c002ab38:	83 ec 28             	sub    $0x28,%esp
c002ab3b:	8b 45 14             	mov    0x14(%ebp),%eax
c002ab3e:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002ab41:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ab45:	75 21                	jne    c002ab68 <bitmap_set_multiple+0x33>
c002ab47:	83 ec 0c             	sub    $0xc,%esp
c002ab4a:	68 dd 22 03 c0       	push   $0xc00322dd
c002ab4f:	68 ac 22 03 c0       	push   $0xc00322ac
c002ab54:	68 68 23 03 c0       	push   $0xc0032368
c002ab59:	68 de 00 00 00       	push   $0xde
c002ab5e:	68 c3 22 03 c0       	push   $0xc00322c3
c002ab63:	e8 06 ec ff ff       	call   c002976e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ab68:	8b 45 08             	mov    0x8(%ebp),%eax
c002ab6b:	8b 00                	mov    (%eax),%eax
c002ab6d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ab70:	73 21                	jae    c002ab93 <bitmap_set_multiple+0x5e>
c002ab72:	83 ec 0c             	sub    $0xc,%esp
c002ab75:	68 f8 22 03 c0       	push   $0xc00322f8
c002ab7a:	68 ac 22 03 c0       	push   $0xc00322ac
c002ab7f:	68 68 23 03 c0       	push   $0xc0032368
c002ab84:	68 df 00 00 00       	push   $0xdf
c002ab89:	68 c3 22 03 c0       	push   $0xc00322c3
c002ab8e:	e8 db eb ff ff       	call   c002976e <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002ab93:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ab96:	8b 45 10             	mov    0x10(%ebp),%eax
c002ab99:	01 c2                	add    %eax,%edx
c002ab9b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ab9e:	8b 00                	mov    (%eax),%eax
c002aba0:	39 c2                	cmp    %eax,%edx
c002aba2:	76 21                	jbe    c002abc5 <bitmap_set_multiple+0x90>
c002aba4:	83 ec 0c             	sub    $0xc,%esp
c002aba7:	68 0c 23 03 c0       	push   $0xc003230c
c002abac:	68 ac 22 03 c0       	push   $0xc00322ac
c002abb1:	68 68 23 03 c0       	push   $0xc0032368
c002abb6:	68 e0 00 00 00       	push   $0xe0
c002abbb:	68 c3 22 03 c0       	push   $0xc00322c3
c002abc0:	e8 a9 eb ff ff       	call   c002976e <debug_panic>

  for (i = 0; i < cnt; i++)
c002abc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002abcc:	eb 1f                	jmp    c002abed <bitmap_set_multiple+0xb8>
    bitmap_set (b, start + i, value);
c002abce:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002abd2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002abd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002abd8:	01 ca                	add    %ecx,%edx
c002abda:	83 ec 04             	sub    $0x4,%esp
c002abdd:	50                   	push   %eax
c002abde:	52                   	push   %edx
c002abdf:	ff 75 08             	pushl  0x8(%ebp)
c002abe2:	e8 30 fd ff ff       	call   c002a917 <bitmap_set>
c002abe7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < cnt; i++)
c002abea:	ff 45 f4             	incl   -0xc(%ebp)
c002abed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002abf0:	3b 45 10             	cmp    0x10(%ebp),%eax
c002abf3:	72 d9                	jb     c002abce <bitmap_set_multiple+0x99>
}
c002abf5:	90                   	nop
c002abf6:	c9                   	leave  
c002abf7:	c3                   	ret    

c002abf8 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002abf8:	55                   	push   %ebp
c002abf9:	89 e5                	mov    %esp,%ebp
c002abfb:	83 ec 28             	sub    $0x28,%esp
c002abfe:	8b 45 14             	mov    0x14(%ebp),%eax
c002ac01:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002ac04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ac08:	75 21                	jne    c002ac2b <bitmap_count+0x33>
c002ac0a:	83 ec 0c             	sub    $0xc,%esp
c002ac0d:	68 dd 22 03 c0       	push   $0xc00322dd
c002ac12:	68 ac 22 03 c0       	push   $0xc00322ac
c002ac17:	68 7c 23 03 c0       	push   $0xc003237c
c002ac1c:	68 ed 00 00 00       	push   $0xed
c002ac21:	68 c3 22 03 c0       	push   $0xc00322c3
c002ac26:	e8 43 eb ff ff       	call   c002976e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ac2b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac2e:	8b 00                	mov    (%eax),%eax
c002ac30:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ac33:	73 21                	jae    c002ac56 <bitmap_count+0x5e>
c002ac35:	83 ec 0c             	sub    $0xc,%esp
c002ac38:	68 f8 22 03 c0       	push   $0xc00322f8
c002ac3d:	68 ac 22 03 c0       	push   $0xc00322ac
c002ac42:	68 7c 23 03 c0       	push   $0xc003237c
c002ac47:	68 ee 00 00 00       	push   $0xee
c002ac4c:	68 c3 22 03 c0       	push   $0xc00322c3
c002ac51:	e8 18 eb ff ff       	call   c002976e <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002ac56:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ac59:	8b 45 10             	mov    0x10(%ebp),%eax
c002ac5c:	01 c2                	add    %eax,%edx
c002ac5e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac61:	8b 00                	mov    (%eax),%eax
c002ac63:	39 c2                	cmp    %eax,%edx
c002ac65:	76 21                	jbe    c002ac88 <bitmap_count+0x90>
c002ac67:	83 ec 0c             	sub    $0xc,%esp
c002ac6a:	68 0c 23 03 c0       	push   $0xc003230c
c002ac6f:	68 ac 22 03 c0       	push   $0xc00322ac
c002ac74:	68 7c 23 03 c0       	push   $0xc003237c
c002ac79:	68 ef 00 00 00       	push   $0xef
c002ac7e:	68 c3 22 03 c0       	push   $0xc00322c3
c002ac83:	e8 e6 ea ff ff       	call   c002976e <debug_panic>

  value_cnt = 0;
c002ac88:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002ac8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ac96:	eb 22                	jmp    c002acba <bitmap_count+0xc2>
    if (bitmap_test (b, start + i) == value)
c002ac98:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ac9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac9e:	01 d0                	add    %edx,%eax
c002aca0:	83 ec 08             	sub    $0x8,%esp
c002aca3:	50                   	push   %eax
c002aca4:	ff 75 08             	pushl  0x8(%ebp)
c002aca7:	e8 a0 fd ff ff       	call   c002aa4c <bitmap_test>
c002acac:	83 c4 10             	add    $0x10,%esp
c002acaf:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002acb2:	75 03                	jne    c002acb7 <bitmap_count+0xbf>
      value_cnt++;
c002acb4:	ff 45 f0             	incl   -0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002acb7:	ff 45 f4             	incl   -0xc(%ebp)
c002acba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002acbd:	3b 45 10             	cmp    0x10(%ebp),%eax
c002acc0:	72 d6                	jb     c002ac98 <bitmap_count+0xa0>
  return value_cnt;
c002acc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002acc5:	c9                   	leave  
c002acc6:	c3                   	ret    

c002acc7 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002acc7:	55                   	push   %ebp
c002acc8:	89 e5                	mov    %esp,%ebp
c002acca:	83 ec 28             	sub    $0x28,%esp
c002accd:	8b 45 14             	mov    0x14(%ebp),%eax
c002acd0:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002acd3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002acd7:	75 21                	jne    c002acfa <bitmap_contains+0x33>
c002acd9:	83 ec 0c             	sub    $0xc,%esp
c002acdc:	68 dd 22 03 c0       	push   $0xc00322dd
c002ace1:	68 ac 22 03 c0       	push   $0xc00322ac
c002ace6:	68 8c 23 03 c0       	push   $0xc003238c
c002aceb:	68 ff 00 00 00       	push   $0xff
c002acf0:	68 c3 22 03 c0       	push   $0xc00322c3
c002acf5:	e8 74 ea ff ff       	call   c002976e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002acfa:	8b 45 08             	mov    0x8(%ebp),%eax
c002acfd:	8b 00                	mov    (%eax),%eax
c002acff:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ad02:	73 21                	jae    c002ad25 <bitmap_contains+0x5e>
c002ad04:	83 ec 0c             	sub    $0xc,%esp
c002ad07:	68 f8 22 03 c0       	push   $0xc00322f8
c002ad0c:	68 ac 22 03 c0       	push   $0xc00322ac
c002ad11:	68 8c 23 03 c0       	push   $0xc003238c
c002ad16:	68 00 01 00 00       	push   $0x100
c002ad1b:	68 c3 22 03 c0       	push   $0xc00322c3
c002ad20:	e8 49 ea ff ff       	call   c002976e <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002ad25:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ad28:	8b 45 10             	mov    0x10(%ebp),%eax
c002ad2b:	01 c2                	add    %eax,%edx
c002ad2d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad30:	8b 00                	mov    (%eax),%eax
c002ad32:	39 c2                	cmp    %eax,%edx
c002ad34:	76 21                	jbe    c002ad57 <bitmap_contains+0x90>
c002ad36:	83 ec 0c             	sub    $0xc,%esp
c002ad39:	68 0c 23 03 c0       	push   $0xc003230c
c002ad3e:	68 ac 22 03 c0       	push   $0xc00322ac
c002ad43:	68 8c 23 03 c0       	push   $0xc003238c
c002ad48:	68 01 01 00 00       	push   $0x101
c002ad4d:	68 c3 22 03 c0       	push   $0xc00322c3
c002ad52:	e8 17 ea ff ff       	call   c002976e <debug_panic>

  for (i = 0; i < cnt; i++)
c002ad57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ad5e:	eb 23                	jmp    c002ad83 <bitmap_contains+0xbc>
    if (bitmap_test (b, start + i) == value)
c002ad60:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ad63:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad66:	01 d0                	add    %edx,%eax
c002ad68:	83 ec 08             	sub    $0x8,%esp
c002ad6b:	50                   	push   %eax
c002ad6c:	ff 75 08             	pushl  0x8(%ebp)
c002ad6f:	e8 d8 fc ff ff       	call   c002aa4c <bitmap_test>
c002ad74:	83 c4 10             	add    $0x10,%esp
c002ad77:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002ad7a:	75 04                	jne    c002ad80 <bitmap_contains+0xb9>
      return true;
c002ad7c:	b0 01                	mov    $0x1,%al
c002ad7e:	eb 0d                	jmp    c002ad8d <bitmap_contains+0xc6>
  for (i = 0; i < cnt; i++)
c002ad80:	ff 45 f4             	incl   -0xc(%ebp)
c002ad83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad86:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ad89:	72 d5                	jb     c002ad60 <bitmap_contains+0x99>
  return false;
c002ad8b:	b0 00                	mov    $0x0,%al
}
c002ad8d:	c9                   	leave  
c002ad8e:	c3                   	ret    

c002ad8f <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ad8f:	55                   	push   %ebp
c002ad90:	89 e5                	mov    %esp,%ebp
c002ad92:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002ad95:	6a 01                	push   $0x1
c002ad97:	ff 75 10             	pushl  0x10(%ebp)
c002ad9a:	ff 75 0c             	pushl  0xc(%ebp)
c002ad9d:	ff 75 08             	pushl  0x8(%ebp)
c002ada0:	e8 22 ff ff ff       	call   c002acc7 <bitmap_contains>
c002ada5:	83 c4 10             	add    $0x10,%esp
}
c002ada8:	c9                   	leave  
c002ada9:	c3                   	ret    

c002adaa <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002adaa:	55                   	push   %ebp
c002adab:	89 e5                	mov    %esp,%ebp
c002adad:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002adb0:	6a 01                	push   $0x1
c002adb2:	ff 75 10             	pushl  0x10(%ebp)
c002adb5:	ff 75 0c             	pushl  0xc(%ebp)
c002adb8:	ff 75 08             	pushl  0x8(%ebp)
c002adbb:	e8 07 ff ff ff       	call   c002acc7 <bitmap_contains>
c002adc0:	83 c4 10             	add    $0x10,%esp
c002adc3:	0f b6 c0             	movzbl %al,%eax
c002adc6:	85 c0                	test   %eax,%eax
c002adc8:	0f 95 c0             	setne  %al
c002adcb:	83 f0 01             	xor    $0x1,%eax
c002adce:	0f b6 c0             	movzbl %al,%eax
c002add1:	83 e0 01             	and    $0x1,%eax
}
c002add4:	c9                   	leave  
c002add5:	c3                   	ret    

c002add6 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002add6:	55                   	push   %ebp
c002add7:	89 e5                	mov    %esp,%ebp
c002add9:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002addc:	6a 00                	push   $0x0
c002adde:	ff 75 10             	pushl  0x10(%ebp)
c002ade1:	ff 75 0c             	pushl  0xc(%ebp)
c002ade4:	ff 75 08             	pushl  0x8(%ebp)
c002ade7:	e8 db fe ff ff       	call   c002acc7 <bitmap_contains>
c002adec:	83 c4 10             	add    $0x10,%esp
c002adef:	0f b6 c0             	movzbl %al,%eax
c002adf2:	85 c0                	test   %eax,%eax
c002adf4:	0f 95 c0             	setne  %al
c002adf7:	83 f0 01             	xor    $0x1,%eax
c002adfa:	0f b6 c0             	movzbl %al,%eax
c002adfd:	83 e0 01             	and    $0x1,%eax
}
c002ae00:	c9                   	leave  
c002ae01:	c3                   	ret    

c002ae02 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002ae02:	55                   	push   %ebp
c002ae03:	89 e5                	mov    %esp,%ebp
c002ae05:	83 ec 28             	sub    $0x28,%esp
c002ae08:	8b 45 14             	mov    0x14(%ebp),%eax
c002ae0b:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002ae0e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ae12:	75 21                	jne    c002ae35 <bitmap_scan+0x33>
c002ae14:	83 ec 0c             	sub    $0xc,%esp
c002ae17:	68 dd 22 03 c0       	push   $0xc00322dd
c002ae1c:	68 ac 22 03 c0       	push   $0xc00322ac
c002ae21:	68 9c 23 03 c0       	push   $0xc003239c
c002ae26:	68 2a 01 00 00       	push   $0x12a
c002ae2b:	68 c3 22 03 c0       	push   $0xc00322c3
c002ae30:	e8 39 e9 ff ff       	call   c002976e <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002ae35:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae38:	8b 00                	mov    (%eax),%eax
c002ae3a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002ae3d:	73 21                	jae    c002ae60 <bitmap_scan+0x5e>
c002ae3f:	83 ec 0c             	sub    $0xc,%esp
c002ae42:	68 f8 22 03 c0       	push   $0xc00322f8
c002ae47:	68 ac 22 03 c0       	push   $0xc00322ac
c002ae4c:	68 9c 23 03 c0       	push   $0xc003239c
c002ae51:	68 2b 01 00 00       	push   $0x12b
c002ae56:	68 c3 22 03 c0       	push   $0xc00322c3
c002ae5b:	e8 0e e9 ff ff       	call   c002976e <debug_panic>

  if (cnt <= b->bit_cnt) 
c002ae60:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae63:	8b 00                	mov    (%eax),%eax
c002ae65:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ae68:	72 51                	jb     c002aebb <bitmap_scan+0xb9>
    {
      size_t last = b->bit_cnt - cnt;
c002ae6a:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae6d:	8b 00                	mov    (%eax),%eax
c002ae6f:	2b 45 10             	sub    0x10(%ebp),%eax
c002ae72:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002ae75:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ae78:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ae7b:	eb 36                	jmp    c002aeb3 <bitmap_scan+0xb1>
        if (!bitmap_contains (b, i, cnt, !value))
c002ae7d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ae81:	85 c0                	test   %eax,%eax
c002ae83:	0f 95 c0             	setne  %al
c002ae86:	83 f0 01             	xor    $0x1,%eax
c002ae89:	0f b6 c0             	movzbl %al,%eax
c002ae8c:	83 e0 01             	and    $0x1,%eax
c002ae8f:	0f b6 c0             	movzbl %al,%eax
c002ae92:	50                   	push   %eax
c002ae93:	ff 75 10             	pushl  0x10(%ebp)
c002ae96:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae99:	ff 75 08             	pushl  0x8(%ebp)
c002ae9c:	e8 26 fe ff ff       	call   c002acc7 <bitmap_contains>
c002aea1:	83 c4 10             	add    $0x10,%esp
c002aea4:	83 f0 01             	xor    $0x1,%eax
c002aea7:	84 c0                	test   %al,%al
c002aea9:	74 05                	je     c002aeb0 <bitmap_scan+0xae>
          return i; 
c002aeab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aeae:	eb 10                	jmp    c002aec0 <bitmap_scan+0xbe>
      for (i = start; i <= last; i++)
c002aeb0:	ff 45 f4             	incl   -0xc(%ebp)
c002aeb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aeb6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002aeb9:	76 c2                	jbe    c002ae7d <bitmap_scan+0x7b>
    }
  return BITMAP_ERROR;
c002aebb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002aec0:	c9                   	leave  
c002aec1:	c3                   	ret    

c002aec2 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002aec2:	55                   	push   %ebp
c002aec3:	89 e5                	mov    %esp,%ebp
c002aec5:	83 ec 28             	sub    $0x28,%esp
c002aec8:	8b 45 14             	mov    0x14(%ebp),%eax
c002aecb:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002aece:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002aed2:	50                   	push   %eax
c002aed3:	ff 75 10             	pushl  0x10(%ebp)
c002aed6:	ff 75 0c             	pushl  0xc(%ebp)
c002aed9:	ff 75 08             	pushl  0x8(%ebp)
c002aedc:	e8 21 ff ff ff       	call   c002ae02 <bitmap_scan>
c002aee1:	83 c4 10             	add    $0x10,%esp
c002aee4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002aee7:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002aeeb:	74 27                	je     c002af14 <bitmap_scan_and_flip+0x52>
    bitmap_set_multiple (b, idx, cnt, !value);
c002aeed:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002aef1:	85 c0                	test   %eax,%eax
c002aef3:	0f 95 c0             	setne  %al
c002aef6:	83 f0 01             	xor    $0x1,%eax
c002aef9:	0f b6 c0             	movzbl %al,%eax
c002aefc:	83 e0 01             	and    $0x1,%eax
c002aeff:	0f b6 c0             	movzbl %al,%eax
c002af02:	50                   	push   %eax
c002af03:	ff 75 10             	pushl  0x10(%ebp)
c002af06:	ff 75 f4             	pushl  -0xc(%ebp)
c002af09:	ff 75 08             	pushl  0x8(%ebp)
c002af0c:	e8 24 fc ff ff       	call   c002ab35 <bitmap_set_multiple>
c002af11:	83 c4 10             	add    $0x10,%esp
  return idx;
c002af14:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002af17:	c9                   	leave  
c002af18:	c3                   	ret    

c002af19 <bitmap_file_size>:

#ifdef FILESYS
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size (const struct bitmap *b) 
{
c002af19:	55                   	push   %ebp
c002af1a:	89 e5                	mov    %esp,%ebp
  return byte_cnt (b->bit_cnt);
c002af1c:	8b 45 08             	mov    0x8(%ebp),%eax
c002af1f:	8b 00                	mov    (%eax),%eax
c002af21:	50                   	push   %eax
c002af22:	e8 7c f8 ff ff       	call   c002a7a3 <byte_cnt>
c002af27:	83 c4 04             	add    $0x4,%esp
}
c002af2a:	c9                   	leave  
c002af2b:	c3                   	ret    

c002af2c <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool
bitmap_read (struct bitmap *b, struct file *file) 
{
c002af2c:	55                   	push   %ebp
c002af2d:	89 e5                	mov    %esp,%ebp
c002af2f:	56                   	push   %esi
c002af30:	53                   	push   %ebx
c002af31:	83 ec 10             	sub    $0x10,%esp
  bool success = true;
c002af34:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
  if (b->bit_cnt > 0) 
c002af38:	8b 45 08             	mov    0x8(%ebp),%eax
c002af3b:	8b 00                	mov    (%eax),%eax
c002af3d:	85 c0                	test   %eax,%eax
c002af3f:	74 7a                	je     c002afbb <bitmap_read+0x8f>
    {
      off_t size = byte_cnt (b->bit_cnt);
c002af41:	8b 45 08             	mov    0x8(%ebp),%eax
c002af44:	8b 00                	mov    (%eax),%eax
c002af46:	50                   	push   %eax
c002af47:	e8 57 f8 ff ff       	call   c002a7a3 <byte_cnt>
c002af4c:	83 c4 04             	add    $0x4,%esp
c002af4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      success = file_read_at (file, b->bits, size, 0) == size;
c002af52:	8b 45 08             	mov    0x8(%ebp),%eax
c002af55:	8b 40 04             	mov    0x4(%eax),%eax
c002af58:	6a 00                	push   $0x0
c002af5a:	ff 75 f0             	pushl  -0x10(%ebp)
c002af5d:	50                   	push   %eax
c002af5e:	ff 75 0c             	pushl  0xc(%ebp)
c002af61:	e8 b0 30 00 00       	call   c002e016 <file_read_at>
c002af66:	83 c4 10             	add    $0x10,%esp
c002af69:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002af6c:	0f 94 c0             	sete   %al
c002af6f:	88 45 f7             	mov    %al,-0x9(%ebp)
      b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
c002af72:	83 ec 0c             	sub    $0xc,%esp
c002af75:	ff 75 08             	pushl  0x8(%ebp)
c002af78:	e8 39 f8 ff ff       	call   c002a7b6 <last_mask>
c002af7d:	83 c4 10             	add    $0x10,%esp
c002af80:	89 c3                	mov    %eax,%ebx
c002af82:	8b 45 08             	mov    0x8(%ebp),%eax
c002af85:	8b 70 04             	mov    0x4(%eax),%esi
c002af88:	8b 45 08             	mov    0x8(%ebp),%eax
c002af8b:	8b 00                	mov    (%eax),%eax
c002af8d:	83 ec 0c             	sub    $0xc,%esp
c002af90:	50                   	push   %eax
c002af91:	e8 ff f7 ff ff       	call   c002a795 <elem_cnt>
c002af96:	83 c4 10             	add    $0x10,%esp
c002af99:	8d 90 ff ff ff 3f    	lea    0x3fffffff(%eax),%edx
c002af9f:	c1 e2 02             	shl    $0x2,%edx
c002afa2:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
c002afa5:	8b 55 08             	mov    0x8(%ebp),%edx
c002afa8:	8b 52 04             	mov    0x4(%edx),%edx
c002afab:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002afb0:	c1 e0 02             	shl    $0x2,%eax
c002afb3:	01 d0                	add    %edx,%eax
c002afb5:	8b 00                	mov    (%eax),%eax
c002afb7:	21 d8                	and    %ebx,%eax
c002afb9:	89 01                	mov    %eax,(%ecx)
    }
  return success;
c002afbb:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002afbe:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002afc1:	5b                   	pop    %ebx
c002afc2:	5e                   	pop    %esi
c002afc3:	5d                   	pop    %ebp
c002afc4:	c3                   	ret    

c002afc5 <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool
bitmap_write (const struct bitmap *b, struct file *file)
{
c002afc5:	55                   	push   %ebp
c002afc6:	89 e5                	mov    %esp,%ebp
c002afc8:	83 ec 18             	sub    $0x18,%esp
  off_t size = byte_cnt (b->bit_cnt);
c002afcb:	8b 45 08             	mov    0x8(%ebp),%eax
c002afce:	8b 00                	mov    (%eax),%eax
c002afd0:	50                   	push   %eax
c002afd1:	e8 cd f7 ff ff       	call   c002a7a3 <byte_cnt>
c002afd6:	83 c4 04             	add    $0x4,%esp
c002afd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return file_write_at (file, b->bits, size, 0) == size;
c002afdc:	8b 45 08             	mov    0x8(%ebp),%eax
c002afdf:	8b 40 04             	mov    0x4(%eax),%eax
c002afe2:	6a 00                	push   $0x0
c002afe4:	ff 75 f4             	pushl  -0xc(%ebp)
c002afe7:	50                   	push   %eax
c002afe8:	ff 75 0c             	pushl  0xc(%ebp)
c002afeb:	e8 7f 30 00 00       	call   c002e06f <file_write_at>
c002aff0:	83 c4 10             	add    $0x10,%esp
c002aff3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002aff6:	0f 94 c0             	sete   %al
}
c002aff9:	c9                   	leave  
c002affa:	c3                   	ret    

c002affb <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002affb:	55                   	push   %ebp
c002affc:	89 e5                	mov    %esp,%ebp
c002affe:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002b001:	8b 45 08             	mov    0x8(%ebp),%eax
c002b004:	8b 00                	mov    (%eax),%eax
c002b006:	50                   	push   %eax
c002b007:	e8 97 f7 ff ff       	call   c002a7a3 <byte_cnt>
c002b00c:	83 c4 04             	add    $0x4,%esp
c002b00f:	89 c2                	mov    %eax,%edx
c002b011:	8b 45 08             	mov    0x8(%ebp),%eax
c002b014:	8b 40 04             	mov    0x4(%eax),%eax
c002b017:	6a 00                	push   $0x0
c002b019:	52                   	push   %edx
c002b01a:	50                   	push   %eax
c002b01b:	6a 00                	push   $0x0
c002b01d:	e8 c4 ce ff ff       	call   c0027ee6 <hex_dump>
c002b022:	83 c4 10             	add    $0x10,%esp
}
c002b025:	90                   	nop
c002b026:	c9                   	leave  
c002b027:	c3                   	ret    

c002b028 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002b028:	55                   	push   %ebp
c002b029:	89 e5                	mov    %esp,%ebp
c002b02b:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002b02e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b031:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002b037:	8b 45 08             	mov    0x8(%ebp),%eax
c002b03a:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002b041:	8b 45 08             	mov    0x8(%ebp),%eax
c002b044:	8b 40 04             	mov    0x4(%eax),%eax
c002b047:	c1 e0 04             	shl    $0x4,%eax
c002b04a:	83 ec 0c             	sub    $0xc,%esp
c002b04d:	50                   	push   %eax
c002b04e:	e8 3f 86 ff ff       	call   c0023692 <malloc>
c002b053:	83 c4 10             	add    $0x10,%esp
c002b056:	89 c2                	mov    %eax,%edx
c002b058:	8b 45 08             	mov    0x8(%ebp),%eax
c002b05b:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002b05e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b061:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b064:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002b067:	8b 45 08             	mov    0x8(%ebp),%eax
c002b06a:	8b 55 10             	mov    0x10(%ebp),%edx
c002b06d:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002b070:	8b 45 08             	mov    0x8(%ebp),%eax
c002b073:	8b 55 14             	mov    0x14(%ebp),%edx
c002b076:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002b079:	8b 45 08             	mov    0x8(%ebp),%eax
c002b07c:	8b 40 08             	mov    0x8(%eax),%eax
c002b07f:	85 c0                	test   %eax,%eax
c002b081:	74 14                	je     c002b097 <hash_init+0x6f>
    {
      hash_clear (h, NULL);
c002b083:	83 ec 08             	sub    $0x8,%esp
c002b086:	6a 00                	push   $0x0
c002b088:	ff 75 08             	pushl  0x8(%ebp)
c002b08b:	e8 0b 00 00 00       	call   c002b09b <hash_clear>
c002b090:	83 c4 10             	add    $0x10,%esp
      return true;
c002b093:	b0 01                	mov    $0x1,%al
c002b095:	eb 02                	jmp    c002b099 <hash_init+0x71>
    }
  else
    return false;
c002b097:	b0 00                	mov    $0x0,%al
}
c002b099:	c9                   	leave  
c002b09a:	c3                   	ret    

c002b09b <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002b09b:	55                   	push   %ebp
c002b09c:	89 e5                	mov    %esp,%ebp
c002b09e:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002b0a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b0a8:	eb 71                	jmp    c002b11b <hash_clear+0x80>
    {
      struct list *bucket = &h->buckets[i];
c002b0aa:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0ad:	8b 40 08             	mov    0x8(%eax),%eax
c002b0b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b0b3:	c1 e2 04             	shl    $0x4,%edx
c002b0b6:	01 d0                	add    %edx,%eax
c002b0b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002b0bb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b0bf:	74 49                	je     c002b10a <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002b0c1:	eb 32                	jmp    c002b0f5 <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002b0c3:	83 ec 0c             	sub    $0xc,%esp
c002b0c6:	ff 75 f0             	pushl  -0x10(%ebp)
c002b0c9:	e8 70 ed ff ff       	call   c0029e3e <list_pop_front>
c002b0ce:	83 c4 10             	add    $0x10,%esp
c002b0d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002b0d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b0d7:	83 c0 04             	add    $0x4,%eax
c002b0da:	83 e8 04             	sub    $0x4,%eax
c002b0dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002b0e0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0e3:	8b 40 14             	mov    0x14(%eax),%eax
c002b0e6:	83 ec 08             	sub    $0x8,%esp
c002b0e9:	50                   	push   %eax
c002b0ea:	ff 75 e8             	pushl  -0x18(%ebp)
c002b0ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b0f0:	ff d0                	call   *%eax
c002b0f2:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002b0f5:	83 ec 0c             	sub    $0xc,%esp
c002b0f8:	ff 75 f0             	pushl  -0x10(%ebp)
c002b0fb:	e8 66 ee ff ff       	call   c0029f66 <list_empty>
c002b100:	83 c4 10             	add    $0x10,%esp
c002b103:	83 f0 01             	xor    $0x1,%eax
c002b106:	84 c0                	test   %al,%al
c002b108:	75 b9                	jne    c002b0c3 <hash_clear+0x28>
          }

      list_init (bucket); 
c002b10a:	83 ec 0c             	sub    $0xc,%esp
c002b10d:	ff 75 f0             	pushl  -0x10(%ebp)
c002b110:	e8 ca e8 ff ff       	call   c00299df <list_init>
c002b115:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
c002b118:	ff 45 f4             	incl   -0xc(%ebp)
c002b11b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b11e:	8b 40 04             	mov    0x4(%eax),%eax
c002b121:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b124:	77 84                	ja     c002b0aa <hash_clear+0xf>
    }    

  h->elem_cnt = 0;
c002b126:	8b 45 08             	mov    0x8(%ebp),%eax
c002b129:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002b12f:	90                   	nop
c002b130:	c9                   	leave  
c002b131:	c3                   	ret    

c002b132 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002b132:	55                   	push   %ebp
c002b133:	89 e5                	mov    %esp,%ebp
c002b135:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002b138:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b13c:	74 11                	je     c002b14f <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002b13e:	83 ec 08             	sub    $0x8,%esp
c002b141:	ff 75 0c             	pushl  0xc(%ebp)
c002b144:	ff 75 08             	pushl  0x8(%ebp)
c002b147:	e8 4f ff ff ff       	call   c002b09b <hash_clear>
c002b14c:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002b14f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b152:	8b 40 08             	mov    0x8(%eax),%eax
c002b155:	83 ec 0c             	sub    $0xc,%esp
c002b158:	50                   	push   %eax
c002b159:	e8 2e 88 ff ff       	call   c002398c <free>
c002b15e:	83 c4 10             	add    $0x10,%esp
}
c002b161:	90                   	nop
c002b162:	c9                   	leave  
c002b163:	c3                   	ret    

c002b164 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002b164:	55                   	push   %ebp
c002b165:	89 e5                	mov    %esp,%ebp
c002b167:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b16a:	83 ec 08             	sub    $0x8,%esp
c002b16d:	ff 75 0c             	pushl  0xc(%ebp)
c002b170:	ff 75 08             	pushl  0x8(%ebp)
c002b173:	e8 7e 04 00 00       	call   c002b5f6 <find_bucket>
c002b178:	83 c4 10             	add    $0x10,%esp
c002b17b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b17e:	83 ec 04             	sub    $0x4,%esp
c002b181:	ff 75 0c             	pushl  0xc(%ebp)
c002b184:	ff 75 f4             	pushl  -0xc(%ebp)
c002b187:	ff 75 08             	pushl  0x8(%ebp)
c002b18a:	e8 a3 04 00 00       	call   c002b632 <find_elem>
c002b18f:	83 c4 10             	add    $0x10,%esp
c002b192:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002b195:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b199:	75 14                	jne    c002b1af <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002b19b:	83 ec 04             	sub    $0x4,%esp
c002b19e:	ff 75 0c             	pushl  0xc(%ebp)
c002b1a1:	ff 75 f4             	pushl  -0xc(%ebp)
c002b1a4:	ff 75 08             	pushl  0x8(%ebp)
c002b1a7:	e8 ee 06 00 00       	call   c002b89a <insert_elem>
c002b1ac:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b1af:	83 ec 0c             	sub    $0xc,%esp
c002b1b2:	ff 75 08             	pushl  0x8(%ebp)
c002b1b5:	e8 43 05 00 00       	call   c002b6fd <rehash>
c002b1ba:	83 c4 10             	add    $0x10,%esp

  return old; 
c002b1bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b1c0:	c9                   	leave  
c002b1c1:	c3                   	ret    

c002b1c2 <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002b1c2:	55                   	push   %ebp
c002b1c3:	89 e5                	mov    %esp,%ebp
c002b1c5:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b1c8:	83 ec 08             	sub    $0x8,%esp
c002b1cb:	ff 75 0c             	pushl  0xc(%ebp)
c002b1ce:	ff 75 08             	pushl  0x8(%ebp)
c002b1d1:	e8 20 04 00 00       	call   c002b5f6 <find_bucket>
c002b1d6:	83 c4 10             	add    $0x10,%esp
c002b1d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b1dc:	83 ec 04             	sub    $0x4,%esp
c002b1df:	ff 75 0c             	pushl  0xc(%ebp)
c002b1e2:	ff 75 f4             	pushl  -0xc(%ebp)
c002b1e5:	ff 75 08             	pushl  0x8(%ebp)
c002b1e8:	e8 45 04 00 00       	call   c002b632 <find_elem>
c002b1ed:	83 c4 10             	add    $0x10,%esp
c002b1f0:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002b1f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b1f7:	74 11                	je     c002b20a <hash_replace+0x48>
    remove_elem (h, old);
c002b1f9:	83 ec 08             	sub    $0x8,%esp
c002b1fc:	ff 75 f0             	pushl  -0x10(%ebp)
c002b1ff:	ff 75 08             	pushl  0x8(%ebp)
c002b202:	e8 bb 06 00 00       	call   c002b8c2 <remove_elem>
c002b207:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002b20a:	83 ec 04             	sub    $0x4,%esp
c002b20d:	ff 75 0c             	pushl  0xc(%ebp)
c002b210:	ff 75 f4             	pushl  -0xc(%ebp)
c002b213:	ff 75 08             	pushl  0x8(%ebp)
c002b216:	e8 7f 06 00 00       	call   c002b89a <insert_elem>
c002b21b:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b21e:	83 ec 0c             	sub    $0xc,%esp
c002b221:	ff 75 08             	pushl  0x8(%ebp)
c002b224:	e8 d4 04 00 00       	call   c002b6fd <rehash>
c002b229:	83 c4 10             	add    $0x10,%esp

  return old;
c002b22c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b22f:	c9                   	leave  
c002b230:	c3                   	ret    

c002b231 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002b231:	55                   	push   %ebp
c002b232:	89 e5                	mov    %esp,%ebp
c002b234:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002b237:	83 ec 08             	sub    $0x8,%esp
c002b23a:	ff 75 0c             	pushl  0xc(%ebp)
c002b23d:	ff 75 08             	pushl  0x8(%ebp)
c002b240:	e8 b1 03 00 00       	call   c002b5f6 <find_bucket>
c002b245:	83 c4 10             	add    $0x10,%esp
c002b248:	83 ec 04             	sub    $0x4,%esp
c002b24b:	ff 75 0c             	pushl  0xc(%ebp)
c002b24e:	50                   	push   %eax
c002b24f:	ff 75 08             	pushl  0x8(%ebp)
c002b252:	e8 db 03 00 00       	call   c002b632 <find_elem>
c002b257:	83 c4 10             	add    $0x10,%esp
}
c002b25a:	c9                   	leave  
c002b25b:	c3                   	ret    

c002b25c <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002b25c:	55                   	push   %ebp
c002b25d:	89 e5                	mov    %esp,%ebp
c002b25f:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002b262:	83 ec 08             	sub    $0x8,%esp
c002b265:	ff 75 0c             	pushl  0xc(%ebp)
c002b268:	ff 75 08             	pushl  0x8(%ebp)
c002b26b:	e8 86 03 00 00       	call   c002b5f6 <find_bucket>
c002b270:	83 c4 10             	add    $0x10,%esp
c002b273:	83 ec 04             	sub    $0x4,%esp
c002b276:	ff 75 0c             	pushl  0xc(%ebp)
c002b279:	50                   	push   %eax
c002b27a:	ff 75 08             	pushl  0x8(%ebp)
c002b27d:	e8 b0 03 00 00       	call   c002b632 <find_elem>
c002b282:	83 c4 10             	add    $0x10,%esp
c002b285:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002b288:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b28c:	74 1f                	je     c002b2ad <hash_delete+0x51>
    {
      remove_elem (h, found);
c002b28e:	83 ec 08             	sub    $0x8,%esp
c002b291:	ff 75 f4             	pushl  -0xc(%ebp)
c002b294:	ff 75 08             	pushl  0x8(%ebp)
c002b297:	e8 26 06 00 00       	call   c002b8c2 <remove_elem>
c002b29c:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002b29f:	83 ec 0c             	sub    $0xc,%esp
c002b2a2:	ff 75 08             	pushl  0x8(%ebp)
c002b2a5:	e8 53 04 00 00       	call   c002b6fd <rehash>
c002b2aa:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002b2ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b2b0:	c9                   	leave  
c002b2b1:	c3                   	ret    

c002b2b2 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002b2b2:	55                   	push   %ebp
c002b2b3:	89 e5                	mov    %esp,%ebp
c002b2b5:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002b2b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b2bc:	75 21                	jne    c002b2df <hash_apply+0x2d>
c002b2be:	83 ec 0c             	sub    $0xc,%esp
c002b2c1:	68 a8 23 03 c0       	push   $0xc00323a8
c002b2c6:	68 b7 23 03 c0       	push   $0xc00323b7
c002b2cb:	68 10 24 03 c0       	push   $0xc0032410
c002b2d0:	68 a7 00 00 00       	push   $0xa7
c002b2d5:	68 ce 23 03 c0       	push   $0xc00323ce
c002b2da:	e8 8f e4 ff ff       	call   c002976e <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002b2df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b2e6:	eb 6d                	jmp    c002b355 <hash_apply+0xa3>
    {
      struct list *bucket = &h->buckets[i];
c002b2e8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2eb:	8b 40 08             	mov    0x8(%eax),%eax
c002b2ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b2f1:	c1 e2 04             	shl    $0x4,%edx
c002b2f4:	01 d0                	add    %edx,%eax
c002b2f6:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b2f9:	83 ec 0c             	sub    $0xc,%esp
c002b2fc:	ff 75 ec             	pushl  -0x14(%ebp)
c002b2ff:	e8 30 e7 ff ff       	call   c0029a34 <list_begin>
c002b304:	83 c4 10             	add    $0x10,%esp
c002b307:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b30a:	eb 33                	jmp    c002b33f <hash_apply+0x8d>
        {
          next = list_next (elem);
c002b30c:	83 ec 0c             	sub    $0xc,%esp
c002b30f:	ff 75 f0             	pushl  -0x10(%ebp)
c002b312:	e8 4f e7 ff ff       	call   c0029a66 <list_next>
c002b317:	83 c4 10             	add    $0x10,%esp
c002b31a:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002b31d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b320:	8b 40 14             	mov    0x14(%eax),%eax
c002b323:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b326:	83 c2 04             	add    $0x4,%edx
c002b329:	83 ea 04             	sub    $0x4,%edx
c002b32c:	83 ec 08             	sub    $0x8,%esp
c002b32f:	50                   	push   %eax
c002b330:	52                   	push   %edx
c002b331:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b334:	ff d0                	call   *%eax
c002b336:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b339:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b33c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b33f:	83 ec 0c             	sub    $0xc,%esp
c002b342:	ff 75 ec             	pushl  -0x14(%ebp)
c002b345:	e8 66 e7 ff ff       	call   c0029ab0 <list_end>
c002b34a:	83 c4 10             	add    $0x10,%esp
c002b34d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b350:	75 ba                	jne    c002b30c <hash_apply+0x5a>
  for (i = 0; i < h->bucket_cnt; i++) 
c002b352:	ff 45 f4             	incl   -0xc(%ebp)
c002b355:	8b 45 08             	mov    0x8(%ebp),%eax
c002b358:	8b 40 04             	mov    0x4(%eax),%eax
c002b35b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b35e:	77 88                	ja     c002b2e8 <hash_apply+0x36>
        }
    }
}
c002b360:	90                   	nop
c002b361:	c9                   	leave  
c002b362:	c3                   	ret    

c002b363 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b363:	55                   	push   %ebp
c002b364:	89 e5                	mov    %esp,%ebp
c002b366:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b369:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b36d:	75 21                	jne    c002b390 <hash_first+0x2d>
c002b36f:	83 ec 0c             	sub    $0xc,%esp
c002b372:	68 e6 23 03 c0       	push   $0xc00323e6
c002b377:	68 b7 23 03 c0       	push   $0xc00323b7
c002b37c:	68 1c 24 03 c0       	push   $0xc003241c
c002b381:	68 ca 00 00 00       	push   $0xca
c002b386:	68 ce 23 03 c0       	push   $0xc00323ce
c002b38b:	e8 de e3 ff ff       	call   c002976e <debug_panic>
  ASSERT (h != NULL);
c002b390:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b394:	75 21                	jne    c002b3b7 <hash_first+0x54>
c002b396:	83 ec 0c             	sub    $0xc,%esp
c002b399:	68 f0 23 03 c0       	push   $0xc00323f0
c002b39e:	68 b7 23 03 c0       	push   $0xc00323b7
c002b3a3:	68 1c 24 03 c0       	push   $0xc003241c
c002b3a8:	68 cb 00 00 00       	push   $0xcb
c002b3ad:	68 ce 23 03 c0       	push   $0xc00323ce
c002b3b2:	e8 b7 e3 ff ff       	call   c002976e <debug_panic>

  i->hash = h;
c002b3b7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3ba:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b3bd:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b3bf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3c2:	8b 00                	mov    (%eax),%eax
c002b3c4:	8b 50 08             	mov    0x8(%eax),%edx
c002b3c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3ca:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b3cd:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3d0:	8b 40 04             	mov    0x4(%eax),%eax
c002b3d3:	83 ec 0c             	sub    $0xc,%esp
c002b3d6:	50                   	push   %eax
c002b3d7:	e8 b3 e7 ff ff       	call   c0029b8f <list_head>
c002b3dc:	83 c4 10             	add    $0x10,%esp
c002b3df:	83 c0 04             	add    $0x4,%eax
c002b3e2:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b3e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3e8:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b3eb:	90                   	nop
c002b3ec:	c9                   	leave  
c002b3ed:	c3                   	ret    

c002b3ee <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b3ee:	55                   	push   %ebp
c002b3ef:	89 e5                	mov    %esp,%ebp
c002b3f1:	53                   	push   %ebx
c002b3f2:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b3f5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b3f9:	75 21                	jne    c002b41c <hash_next+0x2e>
c002b3fb:	83 ec 0c             	sub    $0xc,%esp
c002b3fe:	68 e6 23 03 c0       	push   $0xc00323e6
c002b403:	68 b7 23 03 c0       	push   $0xc00323b7
c002b408:	68 28 24 03 c0       	push   $0xc0032428
c002b40d:	68 dd 00 00 00       	push   $0xdd
c002b412:	68 ce 23 03 c0       	push   $0xc00323ce
c002b417:	e8 52 e3 ff ff       	call   c002976e <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b41c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b41f:	8b 40 08             	mov    0x8(%eax),%eax
c002b422:	83 ec 0c             	sub    $0xc,%esp
c002b425:	50                   	push   %eax
c002b426:	e8 3b e6 ff ff       	call   c0029a66 <list_next>
c002b42b:	83 c4 10             	add    $0x10,%esp
c002b42e:	83 c0 04             	add    $0x4,%eax
c002b431:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b434:	8b 45 08             	mov    0x8(%ebp),%eax
c002b437:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b43a:	eb 58                	jmp    c002b494 <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b43c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b43f:	8b 40 04             	mov    0x4(%eax),%eax
c002b442:	8d 50 10             	lea    0x10(%eax),%edx
c002b445:	8b 45 08             	mov    0x8(%ebp),%eax
c002b448:	89 50 04             	mov    %edx,0x4(%eax)
c002b44b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b44e:	8b 50 04             	mov    0x4(%eax),%edx
c002b451:	8b 45 08             	mov    0x8(%ebp),%eax
c002b454:	8b 00                	mov    (%eax),%eax
c002b456:	8b 48 08             	mov    0x8(%eax),%ecx
c002b459:	8b 45 08             	mov    0x8(%ebp),%eax
c002b45c:	8b 00                	mov    (%eax),%eax
c002b45e:	8b 40 04             	mov    0x4(%eax),%eax
c002b461:	c1 e0 04             	shl    $0x4,%eax
c002b464:	01 c8                	add    %ecx,%eax
c002b466:	39 c2                	cmp    %eax,%edx
c002b468:	72 0c                	jb     c002b476 <hash_next+0x88>
        {
          i->elem = NULL;
c002b46a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b46d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b474:	eb 40                	jmp    c002b4b6 <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b476:	8b 45 08             	mov    0x8(%ebp),%eax
c002b479:	8b 40 04             	mov    0x4(%eax),%eax
c002b47c:	83 ec 0c             	sub    $0xc,%esp
c002b47f:	50                   	push   %eax
c002b480:	e8 af e5 ff ff       	call   c0029a34 <list_begin>
c002b485:	83 c4 10             	add    $0x10,%esp
c002b488:	83 c0 04             	add    $0x4,%eax
c002b48b:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b48e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b491:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b494:	8b 45 08             	mov    0x8(%ebp),%eax
c002b497:	8b 58 08             	mov    0x8(%eax),%ebx
c002b49a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b49d:	8b 40 04             	mov    0x4(%eax),%eax
c002b4a0:	83 ec 0c             	sub    $0xc,%esp
c002b4a3:	50                   	push   %eax
c002b4a4:	e8 07 e6 ff ff       	call   c0029ab0 <list_end>
c002b4a9:	83 c4 10             	add    $0x10,%esp
c002b4ac:	83 c0 04             	add    $0x4,%eax
c002b4af:	83 e8 04             	sub    $0x4,%eax
c002b4b2:	39 c3                	cmp    %eax,%ebx
c002b4b4:	74 86                	je     c002b43c <hash_next+0x4e>
    }
  
  return i->elem;
c002b4b6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4b9:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b4bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b4bf:	c9                   	leave  
c002b4c0:	c3                   	ret    

c002b4c1 <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b4c1:	55                   	push   %ebp
c002b4c2:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b4c4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4c7:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b4ca:	5d                   	pop    %ebp
c002b4cb:	c3                   	ret    

c002b4cc <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b4cc:	55                   	push   %ebp
c002b4cd:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b4cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4d2:	8b 00                	mov    (%eax),%eax
}
c002b4d4:	5d                   	pop    %ebp
c002b4d5:	c3                   	ret    

c002b4d6 <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b4d6:	55                   	push   %ebp
c002b4d7:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b4d9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4dc:	8b 00                	mov    (%eax),%eax
c002b4de:	85 c0                	test   %eax,%eax
c002b4e0:	0f 94 c0             	sete   %al
}
c002b4e3:	5d                   	pop    %ebp
c002b4e4:	c3                   	ret    

c002b4e5 <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b4e5:	55                   	push   %ebp
c002b4e6:	89 e5                	mov    %esp,%ebp
c002b4e8:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b4eb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b4f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b4f5:	75 21                	jne    c002b518 <hash_bytes+0x33>
c002b4f7:	83 ec 0c             	sub    $0xc,%esp
c002b4fa:	68 fa 23 03 c0       	push   $0xc00323fa
c002b4ff:	68 b7 23 03 c0       	push   $0xc00323b7
c002b504:	68 34 24 03 c0       	push   $0xc0032434
c002b509:	68 10 01 00 00       	push   $0x110
c002b50e:	68 ce 23 03 c0       	push   $0xc00323ce
c002b513:	e8 56 e2 ff ff       	call   c002976e <debug_panic>

  hash = FNV_32_BASIS;
c002b518:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b51f:	eb 30                	jmp    c002b551 <hash_bytes+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b521:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b524:	89 d0                	mov    %edx,%eax
c002b526:	c1 e0 10             	shl    $0x10,%eax
c002b529:	01 d0                	add    %edx,%eax
c002b52b:	01 c0                	add    %eax,%eax
c002b52d:	01 d0                	add    %edx,%eax
c002b52f:	c1 e0 03             	shl    $0x3,%eax
c002b532:	01 d0                	add    %edx,%eax
c002b534:	c1 e0 03             	shl    $0x3,%eax
c002b537:	01 d0                	add    %edx,%eax
c002b539:	01 c0                	add    %eax,%eax
c002b53b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b53e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b541:	8d 50 01             	lea    0x1(%eax),%edx
c002b544:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b547:	8a 00                	mov    (%eax),%al
c002b549:	0f b6 c0             	movzbl %al,%eax
c002b54c:	31 c8                	xor    %ecx,%eax
c002b54e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (size-- > 0)
c002b551:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b554:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b557:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b55a:	85 c0                	test   %eax,%eax
c002b55c:	75 c3                	jne    c002b521 <hash_bytes+0x3c>

  return hash;
c002b55e:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b561:	c9                   	leave  
c002b562:	c3                   	ret    

c002b563 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b563:	55                   	push   %ebp
c002b564:	89 e5                	mov    %esp,%ebp
c002b566:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b569:	8b 45 08             	mov    0x8(%ebp),%eax
c002b56c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b56f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b573:	75 21                	jne    c002b596 <hash_string+0x33>
c002b575:	83 ec 0c             	sub    $0xc,%esp
c002b578:	68 06 24 03 c0       	push   $0xc0032406
c002b57d:	68 b7 23 03 c0       	push   $0xc00323b7
c002b582:	68 40 24 03 c0       	push   $0xc0032440
c002b587:	68 20 01 00 00       	push   $0x120
c002b58c:	68 ce 23 03 c0       	push   $0xc00323ce
c002b591:	e8 d8 e1 ff ff       	call   c002976e <debug_panic>

  hash = FNV_32_BASIS;
c002b596:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b59d:	eb 30                	jmp    c002b5cf <hash_string+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b59f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b5a2:	89 d0                	mov    %edx,%eax
c002b5a4:	c1 e0 10             	shl    $0x10,%eax
c002b5a7:	01 d0                	add    %edx,%eax
c002b5a9:	01 c0                	add    %eax,%eax
c002b5ab:	01 d0                	add    %edx,%eax
c002b5ad:	c1 e0 03             	shl    $0x3,%eax
c002b5b0:	01 d0                	add    %edx,%eax
c002b5b2:	c1 e0 03             	shl    $0x3,%eax
c002b5b5:	01 d0                	add    %edx,%eax
c002b5b7:	01 c0                	add    %eax,%eax
c002b5b9:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b5bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b5bf:	8d 50 01             	lea    0x1(%eax),%edx
c002b5c2:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b5c5:	8a 00                	mov    (%eax),%al
c002b5c7:	0f b6 c0             	movzbl %al,%eax
c002b5ca:	31 c8                	xor    %ecx,%eax
c002b5cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (*s != '\0')
c002b5cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b5d2:	8a 00                	mov    (%eax),%al
c002b5d4:	84 c0                	test   %al,%al
c002b5d6:	75 c7                	jne    c002b59f <hash_string+0x3c>

  return hash;
c002b5d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b5db:	c9                   	leave  
c002b5dc:	c3                   	ret    

c002b5dd <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002b5dd:	55                   	push   %ebp
c002b5de:	89 e5                	mov    %esp,%ebp
c002b5e0:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002b5e3:	83 ec 08             	sub    $0x8,%esp
c002b5e6:	6a 04                	push   $0x4
c002b5e8:	8d 45 08             	lea    0x8(%ebp),%eax
c002b5eb:	50                   	push   %eax
c002b5ec:	e8 f4 fe ff ff       	call   c002b4e5 <hash_bytes>
c002b5f1:	83 c4 10             	add    $0x10,%esp
}
c002b5f4:	c9                   	leave  
c002b5f5:	c3                   	ret    

c002b5f6 <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002b5f6:	55                   	push   %ebp
c002b5f7:	89 e5                	mov    %esp,%ebp
c002b5f9:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002b5fc:	8b 45 08             	mov    0x8(%ebp),%eax
c002b5ff:	8b 40 0c             	mov    0xc(%eax),%eax
c002b602:	8b 55 08             	mov    0x8(%ebp),%edx
c002b605:	8b 52 14             	mov    0x14(%edx),%edx
c002b608:	83 ec 08             	sub    $0x8,%esp
c002b60b:	52                   	push   %edx
c002b60c:	ff 75 0c             	pushl  0xc(%ebp)
c002b60f:	ff d0                	call   *%eax
c002b611:	83 c4 10             	add    $0x10,%esp
c002b614:	89 c2                	mov    %eax,%edx
c002b616:	8b 45 08             	mov    0x8(%ebp),%eax
c002b619:	8b 40 04             	mov    0x4(%eax),%eax
c002b61c:	48                   	dec    %eax
c002b61d:	21 d0                	and    %edx,%eax
c002b61f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002b622:	8b 45 08             	mov    0x8(%ebp),%eax
c002b625:	8b 40 08             	mov    0x8(%eax),%eax
c002b628:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b62b:	c1 e2 04             	shl    $0x4,%edx
c002b62e:	01 d0                	add    %edx,%eax
}
c002b630:	c9                   	leave  
c002b631:	c3                   	ret    

c002b632 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b632:	55                   	push   %ebp
c002b633:	89 e5                	mov    %esp,%ebp
c002b635:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b638:	83 ec 0c             	sub    $0xc,%esp
c002b63b:	ff 75 0c             	pushl  0xc(%ebp)
c002b63e:	e8 f1 e3 ff ff       	call   c0029a34 <list_begin>
c002b643:	83 c4 10             	add    $0x10,%esp
c002b646:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b649:	eb 66                	jmp    c002b6b1 <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002b64b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b64e:	83 c0 04             	add    $0x4,%eax
c002b651:	83 e8 04             	sub    $0x4,%eax
c002b654:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002b657:	8b 45 08             	mov    0x8(%ebp),%eax
c002b65a:	8b 40 10             	mov    0x10(%eax),%eax
c002b65d:	8b 55 08             	mov    0x8(%ebp),%edx
c002b660:	8b 52 14             	mov    0x14(%edx),%edx
c002b663:	83 ec 04             	sub    $0x4,%esp
c002b666:	52                   	push   %edx
c002b667:	ff 75 10             	pushl  0x10(%ebp)
c002b66a:	ff 75 f0             	pushl  -0x10(%ebp)
c002b66d:	ff d0                	call   *%eax
c002b66f:	83 c4 10             	add    $0x10,%esp
c002b672:	83 f0 01             	xor    $0x1,%eax
c002b675:	84 c0                	test   %al,%al
c002b677:	74 27                	je     c002b6a0 <find_elem+0x6e>
c002b679:	8b 45 08             	mov    0x8(%ebp),%eax
c002b67c:	8b 40 10             	mov    0x10(%eax),%eax
c002b67f:	8b 55 08             	mov    0x8(%ebp),%edx
c002b682:	8b 52 14             	mov    0x14(%edx),%edx
c002b685:	83 ec 04             	sub    $0x4,%esp
c002b688:	52                   	push   %edx
c002b689:	ff 75 f0             	pushl  -0x10(%ebp)
c002b68c:	ff 75 10             	pushl  0x10(%ebp)
c002b68f:	ff d0                	call   *%eax
c002b691:	83 c4 10             	add    $0x10,%esp
c002b694:	83 f0 01             	xor    $0x1,%eax
c002b697:	84 c0                	test   %al,%al
c002b699:	74 05                	je     c002b6a0 <find_elem+0x6e>
        return hi; 
c002b69b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b69e:	eb 29                	jmp    c002b6c9 <find_elem+0x97>
  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b6a0:	83 ec 0c             	sub    $0xc,%esp
c002b6a3:	ff 75 f4             	pushl  -0xc(%ebp)
c002b6a6:	e8 bb e3 ff ff       	call   c0029a66 <list_next>
c002b6ab:	83 c4 10             	add    $0x10,%esp
c002b6ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b6b1:	83 ec 0c             	sub    $0xc,%esp
c002b6b4:	ff 75 0c             	pushl  0xc(%ebp)
c002b6b7:	e8 f4 e3 ff ff       	call   c0029ab0 <list_end>
c002b6bc:	83 c4 10             	add    $0x10,%esp
c002b6bf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b6c2:	75 87                	jne    c002b64b <find_elem+0x19>
    }
  return NULL;
c002b6c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b6c9:	c9                   	leave  
c002b6ca:	c3                   	ret    

c002b6cb <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002b6cb:	55                   	push   %ebp
c002b6cc:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002b6ce:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6d1:	48                   	dec    %eax
c002b6d2:	23 45 08             	and    0x8(%ebp),%eax
}
c002b6d5:	5d                   	pop    %ebp
c002b6d6:	c3                   	ret    

c002b6d7 <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002b6d7:	55                   	push   %ebp
c002b6d8:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002b6da:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b6de:	74 16                	je     c002b6f6 <is_power_of_2+0x1f>
c002b6e0:	ff 75 08             	pushl  0x8(%ebp)
c002b6e3:	e8 e3 ff ff ff       	call   c002b6cb <turn_off_least_1bit>
c002b6e8:	83 c4 04             	add    $0x4,%esp
c002b6eb:	85 c0                	test   %eax,%eax
c002b6ed:	75 07                	jne    c002b6f6 <is_power_of_2+0x1f>
c002b6ef:	b8 01 00 00 00       	mov    $0x1,%eax
c002b6f4:	eb 05                	jmp    c002b6fb <is_power_of_2+0x24>
c002b6f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b6fb:	c9                   	leave  
c002b6fc:	c3                   	ret    

c002b6fd <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002b6fd:	55                   	push   %ebp
c002b6fe:	89 e5                	mov    %esp,%ebp
c002b700:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002b703:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b707:	75 21                	jne    c002b72a <rehash+0x2d>
c002b709:	83 ec 0c             	sub    $0xc,%esp
c002b70c:	68 f0 23 03 c0       	push   $0xc00323f0
c002b711:	68 b7 23 03 c0       	push   $0xc00323b7
c002b716:	68 4c 24 03 c0       	push   $0xc003244c
c002b71b:	68 66 01 00 00       	push   $0x166
c002b720:	68 ce 23 03 c0       	push   $0xc00323ce
c002b725:	e8 44 e0 ff ff       	call   c002976e <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002b72a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b72d:	8b 40 08             	mov    0x8(%eax),%eax
c002b730:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002b733:	8b 45 08             	mov    0x8(%ebp),%eax
c002b736:	8b 40 04             	mov    0x4(%eax),%eax
c002b739:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002b73c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b73f:	8b 00                	mov    (%eax),%eax
c002b741:	d1 e8                	shr    %eax
c002b743:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002b746:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002b74a:	77 1a                	ja     c002b766 <rehash+0x69>
    new_bucket_cnt = 4;
c002b74c:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b753:	eb 11                	jmp    c002b766 <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002b755:	83 ec 0c             	sub    $0xc,%esp
c002b758:	ff 75 f4             	pushl  -0xc(%ebp)
c002b75b:	e8 6b ff ff ff       	call   c002b6cb <turn_off_least_1bit>
c002b760:	83 c4 10             	add    $0x10,%esp
c002b763:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b766:	83 ec 0c             	sub    $0xc,%esp
c002b769:	ff 75 f4             	pushl  -0xc(%ebp)
c002b76c:	e8 66 ff ff ff       	call   c002b6d7 <is_power_of_2>
c002b771:	83 c4 10             	add    $0x10,%esp
c002b774:	85 c0                	test   %eax,%eax
c002b776:	74 dd                	je     c002b755 <rehash+0x58>

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002b778:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b77b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b77e:	0f 84 10 01 00 00    	je     c002b894 <rehash+0x197>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002b784:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b787:	c1 e0 04             	shl    $0x4,%eax
c002b78a:	83 ec 0c             	sub    $0xc,%esp
c002b78d:	50                   	push   %eax
c002b78e:	e8 ff 7e ff ff       	call   c0023692 <malloc>
c002b793:	83 c4 10             	add    $0x10,%esp
c002b796:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002b799:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002b79d:	0f 84 f4 00 00 00    	je     c002b897 <rehash+0x19a>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b7a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b7aa:	eb 1c                	jmp    c002b7c8 <rehash+0xcb>
    list_init (&new_buckets[i]);
c002b7ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b7af:	c1 e0 04             	shl    $0x4,%eax
c002b7b2:	89 c2                	mov    %eax,%edx
c002b7b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b7b7:	01 d0                	add    %edx,%eax
c002b7b9:	83 ec 0c             	sub    $0xc,%esp
c002b7bc:	50                   	push   %eax
c002b7bd:	e8 1d e2 ff ff       	call   c00299df <list_init>
c002b7c2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < new_bucket_cnt; i++) 
c002b7c5:	ff 45 f0             	incl   -0x10(%ebp)
c002b7c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b7cb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b7ce:	72 dc                	jb     c002b7ac <rehash+0xaf>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002b7d0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7d3:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002b7d6:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002b7d9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b7df:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b7e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b7e9:	e9 8a 00 00 00       	jmp    c002b878 <rehash+0x17b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002b7ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b7f1:	c1 e0 04             	shl    $0x4,%eax
c002b7f4:	89 c2                	mov    %eax,%edx
c002b7f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b7f9:	01 d0                	add    %edx,%eax
c002b7fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002b7fe:	83 ec 0c             	sub    $0xc,%esp
c002b801:	ff 75 dc             	pushl  -0x24(%ebp)
c002b804:	e8 2b e2 ff ff       	call   c0029a34 <list_begin>
c002b809:	83 c4 10             	add    $0x10,%esp
c002b80c:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b80f:	eb 51                	jmp    c002b862 <rehash+0x165>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002b811:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b814:	83 c0 04             	add    $0x4,%eax
c002b817:	83 e8 04             	sub    $0x4,%eax
          struct list *new_bucket
c002b81a:	83 ec 08             	sub    $0x8,%esp
c002b81d:	50                   	push   %eax
c002b81e:	ff 75 08             	pushl  0x8(%ebp)
c002b821:	e8 d0 fd ff ff       	call   c002b5f6 <find_bucket>
c002b826:	83 c4 10             	add    $0x10,%esp
c002b829:	89 45 d8             	mov    %eax,-0x28(%ebp)
          next = list_next (elem);
c002b82c:	83 ec 0c             	sub    $0xc,%esp
c002b82f:	ff 75 ec             	pushl  -0x14(%ebp)
c002b832:	e8 2f e2 ff ff       	call   c0029a66 <list_next>
c002b837:	83 c4 10             	add    $0x10,%esp
c002b83a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002b83d:	83 ec 0c             	sub    $0xc,%esp
c002b840:	ff 75 ec             	pushl  -0x14(%ebp)
c002b843:	e8 9d e5 ff ff       	call   c0029de5 <list_remove>
c002b848:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002b84b:	83 ec 08             	sub    $0x8,%esp
c002b84e:	ff 75 ec             	pushl  -0x14(%ebp)
c002b851:	ff 75 d8             	pushl  -0x28(%ebp)
c002b854:	e8 40 e5 ff ff       	call   c0029d99 <list_push_front>
c002b859:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002b85c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002b85f:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b862:	83 ec 0c             	sub    $0xc,%esp
c002b865:	ff 75 dc             	pushl  -0x24(%ebp)
c002b868:	e8 43 e2 ff ff       	call   c0029ab0 <list_end>
c002b86d:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (old_bucket);
c002b870:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002b873:	75 9c                	jne    c002b811 <rehash+0x114>
  for (i = 0; i < old_bucket_cnt; i++) 
c002b875:	ff 45 f0             	incl   -0x10(%ebp)
c002b878:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b87b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b87e:	0f 82 6a ff ff ff    	jb     c002b7ee <rehash+0xf1>
        }
    }

  free (old_buckets);
c002b884:	83 ec 0c             	sub    $0xc,%esp
c002b887:	ff 75 e8             	pushl  -0x18(%ebp)
c002b88a:	e8 fd 80 ff ff       	call   c002398c <free>
c002b88f:	83 c4 10             	add    $0x10,%esp
c002b892:	eb 04                	jmp    c002b898 <rehash+0x19b>
    return;
c002b894:	90                   	nop
c002b895:	eb 01                	jmp    c002b898 <rehash+0x19b>
      return;
c002b897:	90                   	nop
}
c002b898:	c9                   	leave  
c002b899:	c3                   	ret    

c002b89a <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b89a:	55                   	push   %ebp
c002b89b:	89 e5                	mov    %esp,%ebp
c002b89d:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002b8a0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8a3:	8b 00                	mov    (%eax),%eax
c002b8a5:	8d 50 01             	lea    0x1(%eax),%edx
c002b8a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8ab:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002b8ad:	8b 45 10             	mov    0x10(%ebp),%eax
c002b8b0:	83 ec 08             	sub    $0x8,%esp
c002b8b3:	50                   	push   %eax
c002b8b4:	ff 75 0c             	pushl  0xc(%ebp)
c002b8b7:	e8 dd e4 ff ff       	call   c0029d99 <list_push_front>
c002b8bc:	83 c4 10             	add    $0x10,%esp
}
c002b8bf:	90                   	nop
c002b8c0:	c9                   	leave  
c002b8c1:	c3                   	ret    

c002b8c2 <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002b8c2:	55                   	push   %ebp
c002b8c3:	89 e5                	mov    %esp,%ebp
c002b8c5:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002b8c8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8cb:	8b 00                	mov    (%eax),%eax
c002b8cd:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b8d0:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8d3:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002b8d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b8d8:	83 ec 0c             	sub    $0xc,%esp
c002b8db:	50                   	push   %eax
c002b8dc:	e8 04 e5 ff ff       	call   c0029de5 <list_remove>
c002b8e1:	83 c4 10             	add    $0x10,%esp
}
c002b8e4:	90                   	nop
c002b8e5:	c9                   	leave  
c002b8e6:	c3                   	ret    

c002b8e7 <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002b8e7:	55                   	push   %ebp
c002b8e8:	89 e5                	mov    %esp,%ebp
c002b8ea:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002b8ed:	83 ec 0c             	sub    $0xc,%esp
c002b8f0:	68 a8 a3 03 c0       	push   $0xc003a3a8
c002b8f5:	e8 80 73 ff ff       	call   c0022c7a <lock_init>
c002b8fa:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002b8fd:	c6 05 c0 a3 03 c0 01 	movb   $0x1,0xc003a3c0
}
c002b904:	90                   	nop
c002b905:	c9                   	leave  
c002b906:	c3                   	ret    

c002b907 <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002b907:	55                   	push   %ebp
c002b908:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002b90a:	c6 05 c0 a3 03 c0 00 	movb   $0x0,0xc003a3c0
}
c002b911:	90                   	nop
c002b912:	5d                   	pop    %ebp
c002b913:	c3                   	ret    

c002b914 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002b914:	55                   	push   %ebp
c002b915:	89 e5                	mov    %esp,%ebp
c002b917:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002b91a:	a1 c8 a3 03 c0       	mov    0xc003a3c8,%eax
c002b91f:	8b 15 cc a3 03 c0    	mov    0xc003a3cc,%edx
c002b925:	83 ec 04             	sub    $0x4,%esp
c002b928:	52                   	push   %edx
c002b929:	50                   	push   %eax
c002b92a:	68 54 24 03 c0       	push   $0xc0032454
c002b92f:	e8 7b ba ff ff       	call   c00273af <printf>
c002b934:	83 c4 10             	add    $0x10,%esp
}
c002b937:	90                   	nop
c002b938:	c9                   	leave  
c002b939:	c3                   	ret    

c002b93a <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002b93a:	55                   	push   %ebp
c002b93b:	89 e5                	mov    %esp,%ebp
c002b93d:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b940:	e8 4b 5f ff ff       	call   c0021890 <intr_context>
c002b945:	83 f0 01             	xor    $0x1,%eax
c002b948:	84 c0                	test   %al,%al
c002b94a:	74 3a                	je     c002b986 <acquire_console+0x4c>
c002b94c:	a0 c0 a3 03 c0       	mov    0xc003a3c0,%al
c002b951:	84 c0                	test   %al,%al
c002b953:	74 31                	je     c002b986 <acquire_console+0x4c>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002b955:	83 ec 0c             	sub    $0xc,%esp
c002b958:	68 a8 a3 03 c0       	push   $0xc003a3a8
c002b95d:	e8 23 75 ff ff       	call   c0022e85 <lock_held_by_current_thread>
c002b962:	83 c4 10             	add    $0x10,%esp
c002b965:	84 c0                	test   %al,%al
c002b967:	74 0d                	je     c002b976 <acquire_console+0x3c>
        console_lock_depth++; 
c002b969:	a1 c4 a3 03 c0       	mov    0xc003a3c4,%eax
c002b96e:	40                   	inc    %eax
c002b96f:	a3 c4 a3 03 c0       	mov    %eax,0xc003a3c4
      else
        lock_acquire (&console_lock); 
    }
}
c002b974:	eb 10                	jmp    c002b986 <acquire_console+0x4c>
        lock_acquire (&console_lock); 
c002b976:	83 ec 0c             	sub    $0xc,%esp
c002b979:	68 a8 a3 03 c0       	push   $0xc003a3a8
c002b97e:	e8 44 73 ff ff       	call   c0022cc7 <lock_acquire>
c002b983:	83 c4 10             	add    $0x10,%esp
}
c002b986:	90                   	nop
c002b987:	c9                   	leave  
c002b988:	c3                   	ret    

c002b989 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002b989:	55                   	push   %ebp
c002b98a:	89 e5                	mov    %esp,%ebp
c002b98c:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b98f:	e8 fc 5e ff ff       	call   c0021890 <intr_context>
c002b994:	83 f0 01             	xor    $0x1,%eax
c002b997:	84 c0                	test   %al,%al
c002b999:	74 2f                	je     c002b9ca <release_console+0x41>
c002b99b:	a0 c0 a3 03 c0       	mov    0xc003a3c0,%al
c002b9a0:	84 c0                	test   %al,%al
c002b9a2:	74 26                	je     c002b9ca <release_console+0x41>
    {
      if (console_lock_depth > 0)
c002b9a4:	a1 c4 a3 03 c0       	mov    0xc003a3c4,%eax
c002b9a9:	85 c0                	test   %eax,%eax
c002b9ab:	7e 0d                	jle    c002b9ba <release_console+0x31>
        console_lock_depth--;
c002b9ad:	a1 c4 a3 03 c0       	mov    0xc003a3c4,%eax
c002b9b2:	48                   	dec    %eax
c002b9b3:	a3 c4 a3 03 c0       	mov    %eax,0xc003a3c4
      else
        lock_release (&console_lock); 
    }
}
c002b9b8:	eb 10                	jmp    c002b9ca <release_console+0x41>
        lock_release (&console_lock); 
c002b9ba:	83 ec 0c             	sub    $0xc,%esp
c002b9bd:	68 a8 a3 03 c0       	push   $0xc003a3a8
c002b9c2:	e8 40 74 ff ff       	call   c0022e07 <lock_release>
c002b9c7:	83 c4 10             	add    $0x10,%esp
}
c002b9ca:	90                   	nop
c002b9cb:	c9                   	leave  
c002b9cc:	c3                   	ret    

c002b9cd <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002b9cd:	55                   	push   %ebp
c002b9ce:	89 e5                	mov    %esp,%ebp
c002b9d0:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002b9d3:	e8 b8 5e ff ff       	call   c0021890 <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002b9d8:	84 c0                	test   %al,%al
c002b9da:	75 20                	jne    c002b9fc <console_locked_by_current_thread+0x2f>
          || !use_console_lock
c002b9dc:	a0 c0 a3 03 c0       	mov    0xc003a3c0,%al
c002b9e1:	83 f0 01             	xor    $0x1,%eax
c002b9e4:	84 c0                	test   %al,%al
c002b9e6:	75 14                	jne    c002b9fc <console_locked_by_current_thread+0x2f>
          || lock_held_by_current_thread (&console_lock));
c002b9e8:	83 ec 0c             	sub    $0xc,%esp
c002b9eb:	68 a8 a3 03 c0       	push   $0xc003a3a8
c002b9f0:	e8 90 74 ff ff       	call   c0022e85 <lock_held_by_current_thread>
c002b9f5:	83 c4 10             	add    $0x10,%esp
c002b9f8:	84 c0                	test   %al,%al
c002b9fa:	74 07                	je     c002ba03 <console_locked_by_current_thread+0x36>
c002b9fc:	b8 01 00 00 00       	mov    $0x1,%eax
c002ba01:	eb 05                	jmp    c002ba08 <console_locked_by_current_thread+0x3b>
c002ba03:	b8 00 00 00 00       	mov    $0x0,%eax
c002ba08:	83 e0 01             	and    $0x1,%eax
}
c002ba0b:	c9                   	leave  
c002ba0c:	c3                   	ret    

c002ba0d <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002ba0d:	55                   	push   %ebp
c002ba0e:	89 e5                	mov    %esp,%ebp
c002ba10:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002ba13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002ba1a:	e8 1b ff ff ff       	call   c002b93a <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002ba1f:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002ba22:	50                   	push   %eax
c002ba23:	68 ec ba 02 c0       	push   $0xc002baec
c002ba28:	ff 75 0c             	pushl  0xc(%ebp)
c002ba2b:	ff 75 08             	pushl  0x8(%ebp)
c002ba2e:	e8 a2 b9 ff ff       	call   c00273d5 <__vprintf>
c002ba33:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002ba36:	e8 4e ff ff ff       	call   c002b989 <release_console>

  return char_cnt;
c002ba3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ba3e:	c9                   	leave  
c002ba3f:	c3                   	ret    

c002ba40 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002ba40:	55                   	push   %ebp
c002ba41:	89 e5                	mov    %esp,%ebp
c002ba43:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002ba46:	e8 ef fe ff ff       	call   c002b93a <acquire_console>
  while (*s != '\0')
c002ba4b:	eb 1a                	jmp    c002ba67 <puts+0x27>
    putchar_have_lock (*s++);
c002ba4d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba50:	8d 50 01             	lea    0x1(%eax),%edx
c002ba53:	89 55 08             	mov    %edx,0x8(%ebp)
c002ba56:	8a 00                	mov    (%eax),%al
c002ba58:	0f b6 c0             	movzbl %al,%eax
c002ba5b:	83 ec 0c             	sub    $0xc,%esp
c002ba5e:	50                   	push   %eax
c002ba5f:	e8 bc 00 00 00       	call   c002bb20 <putchar_have_lock>
c002ba64:	83 c4 10             	add    $0x10,%esp
  while (*s != '\0')
c002ba67:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba6a:	8a 00                	mov    (%eax),%al
c002ba6c:	84 c0                	test   %al,%al
c002ba6e:	75 dd                	jne    c002ba4d <puts+0xd>
  putchar_have_lock ('\n');
c002ba70:	83 ec 0c             	sub    $0xc,%esp
c002ba73:	6a 0a                	push   $0xa
c002ba75:	e8 a6 00 00 00       	call   c002bb20 <putchar_have_lock>
c002ba7a:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002ba7d:	e8 07 ff ff ff       	call   c002b989 <release_console>

  return 0;
c002ba82:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ba87:	c9                   	leave  
c002ba88:	c3                   	ret    

c002ba89 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002ba89:	55                   	push   %ebp
c002ba8a:	89 e5                	mov    %esp,%ebp
c002ba8c:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002ba8f:	e8 a6 fe ff ff       	call   c002b93a <acquire_console>
  while (n-- > 0)
c002ba94:	eb 1a                	jmp    c002bab0 <putbuf+0x27>
    putchar_have_lock (*buffer++);
c002ba96:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba99:	8d 50 01             	lea    0x1(%eax),%edx
c002ba9c:	89 55 08             	mov    %edx,0x8(%ebp)
c002ba9f:	8a 00                	mov    (%eax),%al
c002baa1:	0f b6 c0             	movzbl %al,%eax
c002baa4:	83 ec 0c             	sub    $0xc,%esp
c002baa7:	50                   	push   %eax
c002baa8:	e8 73 00 00 00       	call   c002bb20 <putchar_have_lock>
c002baad:	83 c4 10             	add    $0x10,%esp
  while (n-- > 0)
c002bab0:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bab3:	8d 50 ff             	lea    -0x1(%eax),%edx
c002bab6:	89 55 0c             	mov    %edx,0xc(%ebp)
c002bab9:	85 c0                	test   %eax,%eax
c002babb:	75 d9                	jne    c002ba96 <putbuf+0xd>
  release_console ();
c002babd:	e8 c7 fe ff ff       	call   c002b989 <release_console>
}
c002bac2:	90                   	nop
c002bac3:	c9                   	leave  
c002bac4:	c3                   	ret    

c002bac5 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002bac5:	55                   	push   %ebp
c002bac6:	89 e5                	mov    %esp,%ebp
c002bac8:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002bacb:	e8 6a fe ff ff       	call   c002b93a <acquire_console>
  putchar_have_lock (c);
c002bad0:	8b 45 08             	mov    0x8(%ebp),%eax
c002bad3:	0f b6 c0             	movzbl %al,%eax
c002bad6:	83 ec 0c             	sub    $0xc,%esp
c002bad9:	50                   	push   %eax
c002bada:	e8 41 00 00 00       	call   c002bb20 <putchar_have_lock>
c002badf:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002bae2:	e8 a2 fe ff ff       	call   c002b989 <release_console>
  
  return c;
c002bae7:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002baea:	c9                   	leave  
c002baeb:	c3                   	ret    

c002baec <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002baec:	55                   	push   %ebp
c002baed:	89 e5                	mov    %esp,%ebp
c002baef:	83 ec 28             	sub    $0x28,%esp
c002baf2:	8b 45 08             	mov    0x8(%ebp),%eax
c002baf5:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002baf8:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bafb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002bafe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bb01:	8b 00                	mov    (%eax),%eax
c002bb03:	8d 50 01             	lea    0x1(%eax),%edx
c002bb06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bb09:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002bb0b:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002bb0e:	0f b6 c0             	movzbl %al,%eax
c002bb11:	83 ec 0c             	sub    $0xc,%esp
c002bb14:	50                   	push   %eax
c002bb15:	e8 06 00 00 00       	call   c002bb20 <putchar_have_lock>
c002bb1a:	83 c4 10             	add    $0x10,%esp
}
c002bb1d:	90                   	nop
c002bb1e:	c9                   	leave  
c002bb1f:	c3                   	ret    

c002bb20 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002bb20:	55                   	push   %ebp
c002bb21:	89 e5                	mov    %esp,%ebp
c002bb23:	83 ec 18             	sub    $0x18,%esp
c002bb26:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb29:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002bb2c:	e8 9c fe ff ff       	call   c002b9cd <console_locked_by_current_thread>
c002bb31:	84 c0                	test   %al,%al
c002bb33:	75 21                	jne    c002bb56 <putchar_have_lock+0x36>
c002bb35:	83 ec 0c             	sub    $0xc,%esp
c002bb38:	68 78 24 03 c0       	push   $0xc0032478
c002bb3d:	68 9c 24 03 c0       	push   $0xc003249c
c002bb42:	68 d0 24 03 c0       	push   $0xc00324d0
c002bb47:	68 bb 00 00 00       	push   $0xbb
c002bb4c:	68 b3 24 03 c0       	push   $0xc00324b3
c002bb51:	e8 18 dc ff ff       	call   c002976e <debug_panic>
  write_cnt++;
c002bb56:	a1 c8 a3 03 c0       	mov    0xc003a3c8,%eax
c002bb5b:	8b 15 cc a3 03 c0    	mov    0xc003a3cc,%edx
c002bb61:	83 c0 01             	add    $0x1,%eax
c002bb64:	83 d2 00             	adc    $0x0,%edx
c002bb67:	a3 c8 a3 03 c0       	mov    %eax,0xc003a3c8
c002bb6c:	89 15 cc a3 03 c0    	mov    %edx,0xc003a3cc
  serial_putc (c);
c002bb72:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002bb76:	83 ec 0c             	sub    $0xc,%esp
c002bb79:	50                   	push   %eax
c002bb7a:	e8 4a 90 ff ff       	call   c0024bc9 <serial_putc>
c002bb7f:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002bb82:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002bb86:	83 ec 0c             	sub    $0xc,%esp
c002bb89:	50                   	push   %eax
c002bb8a:	e8 d2 8b ff ff       	call   c0024761 <vga_putc>
c002bb8f:	83 c4 10             	add    $0x10,%esp
}
c002bb92:	90                   	nop
c002bb93:	c9                   	leave  
c002bb94:	c3                   	ret    

c002bb95 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c002bb95:	55                   	push   %ebp
c002bb96:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c002bb98:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb9b:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002bba0:	5d                   	pop    %ebp
c002bba1:	c3                   	ret    

c002bba2 <is_user_vaddr>:
{
c002bba2:	55                   	push   %ebp
c002bba3:	89 e5                	mov    %esp,%ebp
  return vaddr < PHYS_BASE;
c002bba5:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002bbac:	0f 96 c0             	setbe  %al
}
c002bbaf:	5d                   	pop    %ebp
c002bbb0:	c3                   	ret    

c002bbb1 <process_execute>:
   FILENAME.  The new thread may be scheduled (and may even exit)
   before process_execute() returns.  Returns the new process's
   thread id, or TID_ERROR if the thread cannot be created. */
tid_t
process_execute (const char *cmd_name) 
{
c002bbb1:	55                   	push   %ebp
c002bbb2:	89 e5                	mov    %esp,%ebp
c002bbb4:	83 ec 18             	sub    $0x18,%esp
  char *cmd_copy;
  tid_t tid;

  /* Make a copy of FILE_NAME.
     Otherwise there's a race between the caller and load(). */
  cmd_copy = palloc_get_page (0);
c002bbb7:	83 ec 0c             	sub    $0xc,%esp
c002bbba:	6a 00                	push   $0x0
c002bbbc:	e8 8a 77 ff ff       	call   c002334b <palloc_get_page>
c002bbc1:	83 c4 10             	add    $0x10,%esp
c002bbc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (cmd_copy == NULL)
c002bbc7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002bbcb:	75 07                	jne    c002bbd4 <process_execute+0x23>
    return TID_ERROR;
c002bbcd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002bbd2:	eb 5f                	jmp    c002bc33 <process_execute+0x82>
  strlcpy (cmd_copy, cmd_name, PGSIZE);
c002bbd4:	83 ec 04             	sub    $0x4,%esp
c002bbd7:	68 00 10 00 00       	push   $0x1000
c002bbdc:	ff 75 08             	pushl  0x8(%ebp)
c002bbdf:	ff 75 f4             	pushl  -0xc(%ebp)
c002bbe2:	e8 74 d0 ff ff       	call   c0028c5b <strlcpy>
c002bbe7:	83 c4 10             	add    $0x10,%esp

  
  char *file_name, *args;
  file_name = strtok_r (cmd_copy, " ", &args);
c002bbea:	83 ec 04             	sub    $0x4,%esp
c002bbed:	8d 45 e8             	lea    -0x18(%ebp),%eax
c002bbf0:	50                   	push   %eax
c002bbf1:	68 e4 24 03 c0       	push   $0xc00324e4
c002bbf6:	ff 75 f4             	pushl  -0xc(%ebp)
c002bbf9:	e8 7c ce ff ff       	call   c0028a7a <strtok_r>
c002bbfe:	83 c4 10             	add    $0x10,%esp
c002bc01:	89 45 f0             	mov    %eax,-0x10(%ebp)
  
  tid = thread_create (file_name, PRI_DEFAULT, start_process, cmd_name);
c002bc04:	ff 75 08             	pushl  0x8(%ebp)
c002bc07:	68 35 bc 02 c0       	push   $0xc002bc35
c002bc0c:	6a 1f                	push   $0x1f
c002bc0e:	ff 75 f0             	pushl  -0x10(%ebp)
c002bc11:	e8 31 50 ff ff       	call   c0020c47 <thread_create>
c002bc16:	83 c4 10             	add    $0x10,%esp
c002bc19:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (tid == TID_ERROR)
c002bc1c:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c002bc20:	75 0e                	jne    c002bc30 <process_execute+0x7f>
    palloc_free_page (cmd_copy); 
c002bc22:	83 ec 0c             	sub    $0xc,%esp
c002bc25:	ff 75 f4             	pushl  -0xc(%ebp)
c002bc28:	e8 76 78 ff ff       	call   c00234a3 <palloc_free_page>
c002bc2d:	83 c4 10             	add    $0x10,%esp
  return tid;
c002bc30:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c002bc33:	c9                   	leave  
c002bc34:	c3                   	ret    

c002bc35 <start_process>:

/* A thread function that loads a user process and starts it
   running. */
static void
start_process (void *file_name_)
{
c002bc35:	55                   	push   %ebp
c002bc36:	89 e5                	mov    %esp,%ebp
c002bc38:	83 ec 68             	sub    $0x68,%esp
  char *file_name = file_name_;
c002bc3b:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct intr_frame if_;
  bool success;

  /* Initialize interrupt frame and load executable. */
  memset (&if_, 0, sizeof if_);
c002bc41:	83 ec 04             	sub    $0x4,%esp
c002bc44:	6a 50                	push   $0x50
c002bc46:	6a 00                	push   $0x0
c002bc48:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bc4b:	50                   	push   %eax
c002bc4c:	e8 37 cf ff ff       	call   c0028b88 <memset>
c002bc51:	83 c4 10             	add    $0x10,%esp
  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002bc54:	66 c7 45 ec 23 00    	movw   $0x23,-0x14(%ebp)
c002bc5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc5d:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
c002bc61:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002bc64:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
c002bc68:	8b 45 c8             	mov    -0x38(%ebp),%eax
c002bc6b:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
c002bc6f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002bc72:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
  if_.cs = SEL_UCSEG;
c002bc76:	66 c7 45 e0 1b 00    	movw   $0x1b,-0x20(%ebp)
  if_.eflags = FLAG_IF | FLAG_MBS;
c002bc7c:	c7 45 e4 02 02 00 00 	movl   $0x202,-0x1c(%ebp)
  success = load (file_name, &if_.eip, &if_.esp);
c002bc83:	83 ec 04             	sub    $0x4,%esp
c002bc86:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bc89:	83 c0 48             	add    $0x48,%eax
c002bc8c:	50                   	push   %eax
c002bc8d:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bc90:	83 c0 3c             	add    $0x3c,%eax
c002bc93:	50                   	push   %eax
c002bc94:	ff 75 f4             	pushl  -0xc(%ebp)
c002bc97:	e8 f1 00 00 00       	call   c002bd8d <load>
c002bc9c:	83 c4 10             	add    $0x10,%esp
c002bc9f:	88 45 f3             	mov    %al,-0xd(%ebp)

  /* If load failed, quit. */
  //palloc_free_page (file_name);
  if (!success) 
c002bca2:	8a 45 f3             	mov    -0xd(%ebp),%al
c002bca5:	83 f0 01             	xor    $0x1,%eax
c002bca8:	84 c0                	test   %al,%al
c002bcaa:	74 05                	je     c002bcb1 <start_process+0x7c>
    thread_exit ();
c002bcac:	e8 2f 52 ff ff       	call   c0020ee0 <thread_exit>
     interrupt, implemented by intr_exit (in
     threads/intr-stubs.S).  Because intr_exit takes all of its
     arguments on the stack in the form of a `struct intr_frame',
     we just point the stack pointer (%esp) to our stack frame
     and jump to it. */
  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
c002bcb1:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bcb4:	89 c4                	mov    %eax,%esp
c002bcb6:	e9 71 61 ff ff       	jmp    c0021e2c <intr_exit>
  NOT_REACHED ();
c002bcbb:	68 e8 24 03 c0       	push   $0xc00324e8
c002bcc0:	68 dc 25 03 c0       	push   $0xc00325dc
c002bcc5:	6a 50                	push   $0x50
c002bcc7:	68 0a 25 03 c0       	push   $0xc003250a
c002bccc:	e8 9d da ff ff       	call   c002976e <debug_panic>

c002bcd1 <process_wait>:

   This function will be implemented in problem 2-2.  For now, it
   does nothing. */
int
process_wait (tid_t child_tid UNUSED) 
{
c002bcd1:	55                   	push   %ebp
c002bcd2:	89 e5                	mov    %esp,%ebp
c002bcd4:	83 ec 08             	sub    $0x8,%esp
    while(!thread_current()->is_exited)
c002bcd7:	90                   	nop
c002bcd8:	e8 83 51 ff ff       	call   c0020e60 <thread_current>
c002bcdd:	8a 40 30             	mov    0x30(%eax),%al
c002bce0:	83 f0 01             	xor    $0x1,%eax
c002bce3:	84 c0                	test   %al,%al
c002bce5:	75 f1                	jne    c002bcd8 <process_wait+0x7>
    ;
  return -1;
c002bce7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002bcec:	c9                   	leave  
c002bced:	c3                   	ret    

c002bcee <process_exit>:

/* Free the current process's resources. */
void
process_exit (void)
{
c002bcee:	55                   	push   %ebp
c002bcef:	89 e5                	mov    %esp,%ebp
c002bcf1:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c002bcf4:	e8 67 51 ff ff       	call   c0020e60 <thread_current>
c002bcf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint32_t *pd;

  printf("%s: exit(%d)\n",cur->name,cur->exit_error);
c002bcfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bcff:	8b 40 38             	mov    0x38(%eax),%eax
c002bd02:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bd05:	83 c2 08             	add    $0x8,%edx
c002bd08:	83 ec 04             	sub    $0x4,%esp
c002bd0b:	50                   	push   %eax
c002bd0c:	52                   	push   %edx
c002bd0d:	68 23 25 03 c0       	push   $0xc0032523
c002bd12:	e8 98 b6 ff ff       	call   c00273af <printf>
c002bd17:	83 c4 10             	add    $0x10,%esp
  close_all_files(&thread_current()->files);
c002bd1a:	e8 41 51 ff ff       	call   c0020e60 <thread_current>
c002bd1f:	83 c0 3c             	add    $0x3c,%eax
c002bd22:	83 ec 0c             	sub    $0xc,%esp
c002bd25:	50                   	push   %eax
c002bd26:	e8 2d 17 00 00       	call   c002d458 <close_all_files>
c002bd2b:	83 c4 10             	add    $0x10,%esp
  /* Destroy the current process's page directory and switch back
     to the kernel-only page directory. */
  pd = cur->pagedir;
c002bd2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bd31:	8b 40 50             	mov    0x50(%eax),%eax
c002bd34:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pd != NULL) 
c002bd37:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002bd3b:	74 25                	je     c002bd62 <process_exit+0x74>
         so that a timer interrupt can't switch back to the
         process page directory.  We must activate the base page
         directory before destroying the process's page
         directory, or our active page directory will be one
         that's been freed (and cleared). */
      cur->pagedir = NULL;
c002bd3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bd40:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
      pagedir_activate (NULL);
c002bd47:	83 ec 0c             	sub    $0xc,%esp
c002bd4a:	6a 00                	push   $0x0
c002bd4c:	e8 d3 0f 00 00       	call   c002cd24 <pagedir_activate>
c002bd51:	83 c4 10             	add    $0x10,%esp
      pagedir_destroy (pd);
c002bd54:	83 ec 0c             	sub    $0xc,%esp
c002bd57:	ff 75 f0             	pushl  -0x10(%ebp)
c002bd5a:	e8 fa 09 00 00       	call   c002c759 <pagedir_destroy>
c002bd5f:	83 c4 10             	add    $0x10,%esp
    }
}
c002bd62:	90                   	nop
c002bd63:	c9                   	leave  
c002bd64:	c3                   	ret    

c002bd65 <process_activate>:
/* Sets up the CPU for running user code in the current
   thread.
   This function is called on every context switch. */
void
process_activate (void)
{
c002bd65:	55                   	push   %ebp
c002bd66:	89 e5                	mov    %esp,%ebp
c002bd68:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c002bd6b:	e8 f0 50 ff ff       	call   c0020e60 <thread_current>
c002bd70:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Activate thread's page tables. */
  pagedir_activate (t->pagedir);
c002bd73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bd76:	8b 40 50             	mov    0x50(%eax),%eax
c002bd79:	83 ec 0c             	sub    $0xc,%esp
c002bd7c:	50                   	push   %eax
c002bd7d:	e8 a2 0f 00 00       	call   c002cd24 <pagedir_activate>
c002bd82:	83 c4 10             	add    $0x10,%esp

  /* Set thread's kernel stack for use in processing
     interrupts. */
  tss_update ();
c002bd85:	e8 83 1c 00 00       	call   c002da0d <tss_update>
}
c002bd8a:	90                   	nop
c002bd8b:	c9                   	leave  
c002bd8c:	c3                   	ret    

c002bd8d <load>:
   Stores the executable's entry point into *EIP
   and its initial stack pointer into *ESP.
   Returns true if successful, false otherwise. */
bool
load (const char *file_name, void (**eip) (void), void **esp) 
{
c002bd8d:	55                   	push   %ebp
c002bd8e:	89 e5                	mov    %esp,%ebp
c002bd90:	81 ec 88 00 00 00    	sub    $0x88,%esp
  struct thread *t = thread_current ();
c002bd96:	e8 c5 50 ff ff       	call   c0020e60 <thread_current>
c002bd9b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  struct Elf32_Ehdr ehdr;
  struct file *file = NULL;
c002bd9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  off_t file_ofs;
  bool success = false;
c002bda5:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  int i;

  /* Allocate and activate page directory. */
  t->pagedir = pagedir_create ();
c002bda9:	e8 71 09 00 00       	call   c002c71f <pagedir_create>
c002bdae:	89 c2                	mov    %eax,%edx
c002bdb0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bdb3:	89 50 50             	mov    %edx,0x50(%eax)
  if (t->pagedir == NULL) 
c002bdb6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bdb9:	8b 40 50             	mov    0x50(%eax),%eax
c002bdbc:	85 c0                	test   %eax,%eax
c002bdbe:	0f 84 4c 02 00 00    	je     c002c010 <load+0x283>
    goto done;
  process_activate ();
c002bdc4:	e8 9c ff ff ff       	call   c002bd65 <process_activate>

  /* Open executable file. */
  file = filesys_open (t->name);
c002bdc9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bdcc:	83 c0 08             	add    $0x8,%eax
c002bdcf:	83 ec 0c             	sub    $0xc,%esp
c002bdd2:	50                   	push   %eax
c002bdd3:	e8 8b 1d 00 00       	call   c002db63 <filesys_open>
c002bdd8:	83 c4 10             	add    $0x10,%esp
c002bddb:	89 45 f4             	mov    %eax,-0xc(%ebp)


  if (file == NULL) 
c002bdde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002bde2:	75 1c                	jne    c002be00 <load+0x73>
    {
      printf ("load: %s: open failed\n", t->name);
c002bde4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bde7:	83 c0 08             	add    $0x8,%eax
c002bdea:	83 ec 08             	sub    $0x8,%esp
c002bded:	50                   	push   %eax
c002bdee:	68 31 25 03 c0       	push   $0xc0032531
c002bdf3:	e8 b7 b5 ff ff       	call   c00273af <printf>
c002bdf8:	83 c4 10             	add    $0x10,%esp
      goto done; 
c002bdfb:	e9 20 02 00 00       	jmp    c002c020 <load+0x293>
    }

  /* Read and verify executable header. */
  if (file_read (file, &ehdr, sizeof ehdr) != sizeof ehdr
c002be00:	83 ec 04             	sub    $0x4,%esp
c002be03:	6a 34                	push   $0x34
c002be05:	8d 45 98             	lea    -0x68(%ebp),%eax
c002be08:	50                   	push   %eax
c002be09:	ff 75 f4             	pushl  -0xc(%ebp)
c002be0c:	e8 cb 21 00 00       	call   c002dfdc <file_read>
c002be11:	83 c4 10             	add    $0x10,%esp
c002be14:	83 f8 34             	cmp    $0x34,%eax
c002be17:	75 48                	jne    c002be61 <load+0xd4>
      || memcmp (ehdr.e_ident, "\177ELF\1\1\1", 7)
c002be19:	83 ec 04             	sub    $0x4,%esp
c002be1c:	6a 07                	push   $0x7
c002be1e:	68 48 25 03 c0       	push   $0xc0032548
c002be23:	8d 45 98             	lea    -0x68(%ebp),%eax
c002be26:	50                   	push   %eax
c002be27:	e8 d5 c8 ff ff       	call   c0028701 <memcmp>
c002be2c:	83 c4 10             	add    $0x10,%esp
c002be2f:	85 c0                	test   %eax,%eax
c002be31:	75 2e                	jne    c002be61 <load+0xd4>
      || ehdr.e_type != 2
c002be33:	8b 45 a8             	mov    -0x58(%ebp),%eax
c002be36:	66 83 f8 02          	cmp    $0x2,%ax
c002be3a:	75 25                	jne    c002be61 <load+0xd4>
      || ehdr.e_machine != 3
c002be3c:	66 8b 45 aa          	mov    -0x56(%ebp),%ax
c002be40:	66 83 f8 03          	cmp    $0x3,%ax
c002be44:	75 1b                	jne    c002be61 <load+0xd4>
      || ehdr.e_version != 1
c002be46:	8b 45 ac             	mov    -0x54(%ebp),%eax
c002be49:	83 f8 01             	cmp    $0x1,%eax
c002be4c:	75 13                	jne    c002be61 <load+0xd4>
      || ehdr.e_phentsize != sizeof (struct Elf32_Phdr)
c002be4e:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
c002be52:	66 83 f8 20          	cmp    $0x20,%ax
c002be56:	75 09                	jne    c002be61 <load+0xd4>
      || ehdr.e_phnum > 1024) 
c002be58:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002be5b:	66 3d 00 04          	cmp    $0x400,%ax
c002be5f:	76 1c                	jbe    c002be7d <load+0xf0>
    {
      printf ("load: %s: error loading executable\n", t->name);
c002be61:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002be64:	83 c0 08             	add    $0x8,%eax
c002be67:	83 ec 08             	sub    $0x8,%esp
c002be6a:	50                   	push   %eax
c002be6b:	68 50 25 03 c0       	push   $0xc0032550
c002be70:	e8 3a b5 ff ff       	call   c00273af <printf>
c002be75:	83 c4 10             	add    $0x10,%esp
      goto done; 
c002be78:	e9 a3 01 00 00       	jmp    c002c020 <load+0x293>
    }

  /* Read program headers. */
  file_ofs = ehdr.e_phoff;
c002be7d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c002be80:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 0; i < ehdr.e_phnum; i++) 
c002be83:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c002be8a:	e9 4a 01 00 00       	jmp    c002bfd9 <load+0x24c>
    {
      struct Elf32_Phdr phdr;

      if (file_ofs < 0 || file_ofs > file_length (file))
c002be8f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002be93:	0f 88 87 01 00 00    	js     c002c020 <load+0x293>
c002be99:	83 ec 0c             	sub    $0xc,%esp
c002be9c:	ff 75 f4             	pushl  -0xc(%ebp)
c002be9f:	e8 8e 22 00 00       	call   c002e132 <file_length>
c002bea4:	83 c4 10             	add    $0x10,%esp
c002bea7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002beaa:	0f 8c 70 01 00 00    	jl     c002c020 <load+0x293>
        goto done;
      file_seek (file, file_ofs);
c002beb0:	83 ec 08             	sub    $0x8,%esp
c002beb3:	ff 75 f0             	pushl  -0x10(%ebp)
c002beb6:	ff 75 f4             	pushl  -0xc(%ebp)
c002beb9:	e8 b4 22 00 00       	call   c002e172 <file_seek>
c002bebe:	83 c4 10             	add    $0x10,%esp

      if (file_read (file, &phdr, sizeof phdr) != sizeof phdr)
c002bec1:	83 ec 04             	sub    $0x4,%esp
c002bec4:	6a 20                	push   $0x20
c002bec6:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
c002becc:	50                   	push   %eax
c002becd:	ff 75 f4             	pushl  -0xc(%ebp)
c002bed0:	e8 07 21 00 00       	call   c002dfdc <file_read>
c002bed5:	83 c4 10             	add    $0x10,%esp
c002bed8:	83 f8 20             	cmp    $0x20,%eax
c002bedb:	0f 85 32 01 00 00    	jne    c002c013 <load+0x286>
        goto done;
      file_ofs += sizeof phdr;
c002bee1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bee4:	83 c0 20             	add    $0x20,%eax
c002bee7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      switch (phdr.p_type) 
c002beea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
c002bef0:	83 f8 03             	cmp    $0x3,%eax
c002bef3:	77 13                	ja     c002bf08 <load+0x17b>
c002bef5:	83 f8 02             	cmp    $0x2,%eax
c002bef8:	0f 83 18 01 00 00    	jae    c002c016 <load+0x289>
c002befe:	83 f8 01             	cmp    $0x1,%eax
c002bf01:	74 13                	je     c002bf16 <load+0x189>
        case PT_NOTE:
        case PT_PHDR:
        case PT_STACK:
        default:
          /* Ignore this segment. */
          break;
c002bf03:	e9 ce 00 00 00       	jmp    c002bfd6 <load+0x249>
      switch (phdr.p_type) 
c002bf08:	83 f8 05             	cmp    $0x5,%eax
c002bf0b:	0f 84 05 01 00 00    	je     c002c016 <load+0x289>
          break;
c002bf11:	e9 c0 00 00 00       	jmp    c002bfd6 <load+0x249>
        case PT_DYNAMIC:
        case PT_INTERP:
        case PT_SHLIB:
          goto done;
        case PT_LOAD:
          if (validate_segment (&phdr, file)) 
c002bf16:	83 ec 08             	sub    $0x8,%esp
c002bf19:	ff 75 f4             	pushl  -0xc(%ebp)
c002bf1c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
c002bf22:	50                   	push   %eax
c002bf23:	e8 0b 01 00 00       	call   c002c033 <validate_segment>
c002bf28:	83 c4 10             	add    $0x10,%esp
c002bf2b:	84 c0                	test   %al,%al
c002bf2d:	0f 84 e6 00 00 00    	je     c002c019 <load+0x28c>
            {
              bool writable = (phdr.p_flags & PF_W) != 0;
c002bf33:	8b 45 90             	mov    -0x70(%ebp),%eax
c002bf36:	83 e0 02             	and    $0x2,%eax
c002bf39:	85 c0                	test   %eax,%eax
c002bf3b:	0f 95 c0             	setne  %al
c002bf3e:	88 45 db             	mov    %al,-0x25(%ebp)
              uint32_t file_page = phdr.p_offset & ~PGMASK;
c002bf41:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
c002bf47:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bf4c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
              uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002bf4f:	8b 45 80             	mov    -0x80(%ebp),%eax
c002bf52:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bf57:	89 45 d0             	mov    %eax,-0x30(%ebp)
              uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002bf5a:	8b 45 80             	mov    -0x80(%ebp),%eax
c002bf5d:	25 ff 0f 00 00       	and    $0xfff,%eax
c002bf62:	89 45 cc             	mov    %eax,-0x34(%ebp)
              uint32_t read_bytes, zero_bytes;
              if (phdr.p_filesz > 0)
c002bf65:	8b 45 88             	mov    -0x78(%ebp),%eax
c002bf68:	85 c0                	test   %eax,%eax
c002bf6a:	74 25                	je     c002bf91 <load+0x204>
                {
                  /* Normal segment.
                     Read initial part from disk and zero the rest. */
                  read_bytes = page_offset + phdr.p_filesz;
c002bf6c:	8b 55 88             	mov    -0x78(%ebp),%edx
c002bf6f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002bf72:	01 d0                	add    %edx,%eax
c002bf74:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  zero_bytes = (ROUND_UP (page_offset + phdr.p_memsz, PGSIZE)
c002bf77:	8b 55 8c             	mov    -0x74(%ebp),%edx
c002bf7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002bf7d:	01 d0                	add    %edx,%eax
c002bf7f:	05 ff 0f 00 00       	add    $0xfff,%eax
c002bf84:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bf89:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002bf8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002bf8f:	eb 1c                	jmp    c002bfad <load+0x220>
                }
              else 
                {
                  /* Entirely zero.
                     Don't read anything from disk. */
                  read_bytes = 0;
c002bf91:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                  zero_bytes = ROUND_UP (page_offset + phdr.p_memsz, PGSIZE);
c002bf98:	8b 55 8c             	mov    -0x74(%ebp),%edx
c002bf9b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c002bf9e:	01 d0                	add    %edx,%eax
c002bfa0:	05 ff 0f 00 00       	add    $0xfff,%eax
c002bfa5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bfaa:	89 45 e0             	mov    %eax,-0x20(%ebp)
                }
              if (!load_segment (file, file_page, (void *) mem_page,
c002bfad:	0f b6 4d db          	movzbl -0x25(%ebp),%ecx
c002bfb1:	8b 55 d0             	mov    -0x30(%ebp),%edx
c002bfb4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bfb7:	83 ec 08             	sub    $0x8,%esp
c002bfba:	51                   	push   %ecx
c002bfbb:	ff 75 e0             	pushl  -0x20(%ebp)
c002bfbe:	ff 75 e4             	pushl  -0x1c(%ebp)
c002bfc1:	52                   	push   %edx
c002bfc2:	50                   	push   %eax
c002bfc3:	ff 75 f4             	pushl  -0xc(%ebp)
c002bfc6:	e8 44 01 00 00       	call   c002c10f <load_segment>
c002bfcb:	83 c4 20             	add    $0x20,%esp
c002bfce:	83 f0 01             	xor    $0x1,%eax
c002bfd1:	84 c0                	test   %al,%al
c002bfd3:	75 47                	jne    c002c01c <load+0x28f>
                                 read_bytes, zero_bytes, writable))
                goto done;
            }
          else
            goto done;
          break;
c002bfd5:	90                   	nop
  for (i = 0; i < ehdr.e_phnum; i++) 
c002bfd6:	ff 45 e8             	incl   -0x18(%ebp)
c002bfd9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c002bfdc:	0f b7 c0             	movzwl %ax,%eax
c002bfdf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002bfe2:	0f 8f a7 fe ff ff    	jg     c002be8f <load+0x102>
        }
    }
 
  /* Set up stack. */
  if (!setup_stack (esp,file_name))
c002bfe8:	83 ec 08             	sub    $0x8,%esp
c002bfeb:	ff 75 08             	pushl  0x8(%ebp)
c002bfee:	ff 75 10             	pushl  0x10(%ebp)
c002bff1:	e8 aa 02 00 00       	call   c002c2a0 <setup_stack>
c002bff6:	83 c4 10             	add    $0x10,%esp
c002bff9:	83 f0 01             	xor    $0x1,%eax
c002bffc:	84 c0                	test   %al,%al
c002bffe:	75 1f                	jne    c002c01f <load+0x292>
    goto done;

  /* Start address. */
  *eip = (void (*) (void)) ehdr.e_entry;
c002c000:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002c003:	89 c2                	mov    %eax,%edx
c002c005:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c008:	89 10                	mov    %edx,(%eax)

  success = true;
c002c00a:	c6 45 ef 01          	movb   $0x1,-0x11(%ebp)
c002c00e:	eb 10                	jmp    c002c020 <load+0x293>
    goto done;
c002c010:	90                   	nop
c002c011:	eb 0d                	jmp    c002c020 <load+0x293>
        goto done;
c002c013:	90                   	nop
c002c014:	eb 0a                	jmp    c002c020 <load+0x293>
          goto done;
c002c016:	90                   	nop
c002c017:	eb 07                	jmp    c002c020 <load+0x293>
            goto done;
c002c019:	90                   	nop
c002c01a:	eb 04                	jmp    c002c020 <load+0x293>
                goto done;
c002c01c:	90                   	nop
c002c01d:	eb 01                	jmp    c002c020 <load+0x293>
    goto done;
c002c01f:	90                   	nop

 done:
  /* We arrive here whether the load is successful or not. */
  file_close (file);
c002c020:	83 ec 0c             	sub    $0xc,%esp
c002c023:	ff 75 f4             	pushl  -0xc(%ebp)
c002c026:	e8 6b 1f 00 00       	call   c002df96 <file_close>
c002c02b:	83 c4 10             	add    $0x10,%esp
  return success;
c002c02e:	8a 45 ef             	mov    -0x11(%ebp),%al
}
c002c031:	c9                   	leave  
c002c032:	c3                   	ret    

c002c033 <validate_segment>:

/* Checks whether PHDR describes a valid, loadable segment in
   FILE and returns true if so, false otherwise. */
static bool
validate_segment (const struct Elf32_Phdr *phdr, struct file *file) 
{
c002c033:	55                   	push   %ebp
c002c034:	89 e5                	mov    %esp,%ebp
c002c036:	53                   	push   %ebx
c002c037:	83 ec 04             	sub    $0x4,%esp
  /* p_offset and p_vaddr must have the same page offset. */
  if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK)) 
c002c03a:	8b 45 08             	mov    0x8(%ebp),%eax
c002c03d:	8b 50 04             	mov    0x4(%eax),%edx
c002c040:	8b 45 08             	mov    0x8(%ebp),%eax
c002c043:	8b 40 08             	mov    0x8(%eax),%eax
c002c046:	31 d0                	xor    %edx,%eax
c002c048:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c04d:	85 c0                	test   %eax,%eax
c002c04f:	74 07                	je     c002c058 <validate_segment+0x25>
    return false; 
c002c051:	b0 00                	mov    $0x0,%al
c002c053:	e9 b2 00 00 00       	jmp    c002c10a <validate_segment+0xd7>

  /* p_offset must point within FILE. */
  if (phdr->p_offset > (Elf32_Off) file_length (file)) 
c002c058:	8b 45 08             	mov    0x8(%ebp),%eax
c002c05b:	8b 58 04             	mov    0x4(%eax),%ebx
c002c05e:	83 ec 0c             	sub    $0xc,%esp
c002c061:	ff 75 0c             	pushl  0xc(%ebp)
c002c064:	e8 c9 20 00 00       	call   c002e132 <file_length>
c002c069:	83 c4 10             	add    $0x10,%esp
c002c06c:	39 c3                	cmp    %eax,%ebx
c002c06e:	76 07                	jbe    c002c077 <validate_segment+0x44>
    return false;
c002c070:	b0 00                	mov    $0x0,%al
c002c072:	e9 93 00 00 00       	jmp    c002c10a <validate_segment+0xd7>

  /* p_memsz must be at least as big as p_filesz. */
  if (phdr->p_memsz < phdr->p_filesz) 
c002c077:	8b 45 08             	mov    0x8(%ebp),%eax
c002c07a:	8b 50 14             	mov    0x14(%eax),%edx
c002c07d:	8b 45 08             	mov    0x8(%ebp),%eax
c002c080:	8b 40 10             	mov    0x10(%eax),%eax
c002c083:	39 c2                	cmp    %eax,%edx
c002c085:	73 04                	jae    c002c08b <validate_segment+0x58>
    return false; 
c002c087:	b0 00                	mov    $0x0,%al
c002c089:	eb 7f                	jmp    c002c10a <validate_segment+0xd7>

  /* The segment must not be empty. */
  if (phdr->p_memsz == 0)
c002c08b:	8b 45 08             	mov    0x8(%ebp),%eax
c002c08e:	8b 40 14             	mov    0x14(%eax),%eax
c002c091:	85 c0                	test   %eax,%eax
c002c093:	75 04                	jne    c002c099 <validate_segment+0x66>
    return false;
c002c095:	b0 00                	mov    $0x0,%al
c002c097:	eb 71                	jmp    c002c10a <validate_segment+0xd7>
  
  /* The virtual memory region must both start and end within the
     user address space range. */
  if (!is_user_vaddr ((void *) phdr->p_vaddr))
c002c099:	8b 45 08             	mov    0x8(%ebp),%eax
c002c09c:	8b 40 08             	mov    0x8(%eax),%eax
c002c09f:	83 ec 0c             	sub    $0xc,%esp
c002c0a2:	50                   	push   %eax
c002c0a3:	e8 fa fa ff ff       	call   c002bba2 <is_user_vaddr>
c002c0a8:	83 c4 10             	add    $0x10,%esp
c002c0ab:	83 f0 01             	xor    $0x1,%eax
c002c0ae:	84 c0                	test   %al,%al
c002c0b0:	74 04                	je     c002c0b6 <validate_segment+0x83>
    return false;
c002c0b2:	b0 00                	mov    $0x0,%al
c002c0b4:	eb 54                	jmp    c002c10a <validate_segment+0xd7>
  if (!is_user_vaddr ((void *) (phdr->p_vaddr + phdr->p_memsz)))
c002c0b6:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0b9:	8b 50 08             	mov    0x8(%eax),%edx
c002c0bc:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0bf:	8b 40 14             	mov    0x14(%eax),%eax
c002c0c2:	01 d0                	add    %edx,%eax
c002c0c4:	83 ec 0c             	sub    $0xc,%esp
c002c0c7:	50                   	push   %eax
c002c0c8:	e8 d5 fa ff ff       	call   c002bba2 <is_user_vaddr>
c002c0cd:	83 c4 10             	add    $0x10,%esp
c002c0d0:	83 f0 01             	xor    $0x1,%eax
c002c0d3:	84 c0                	test   %al,%al
c002c0d5:	74 04                	je     c002c0db <validate_segment+0xa8>
    return false;
c002c0d7:	b0 00                	mov    $0x0,%al
c002c0d9:	eb 2f                	jmp    c002c10a <validate_segment+0xd7>

  /* The region cannot "wrap around" across the kernel virtual
     address space. */
  if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002c0db:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0de:	8b 50 08             	mov    0x8(%eax),%edx
c002c0e1:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0e4:	8b 40 14             	mov    0x14(%eax),%eax
c002c0e7:	01 c2                	add    %eax,%edx
c002c0e9:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0ec:	8b 40 08             	mov    0x8(%eax),%eax
c002c0ef:	39 c2                	cmp    %eax,%edx
c002c0f1:	73 04                	jae    c002c0f7 <validate_segment+0xc4>
    return false;
c002c0f3:	b0 00                	mov    $0x0,%al
c002c0f5:	eb 13                	jmp    c002c10a <validate_segment+0xd7>
  /* Disallow mapping page 0.
     Not only is it a bad idea to map page 0, but if we allowed
     it then user code that passed a null pointer to system calls
     could quite likely panic the kernel by way of null pointer
     assertions in memcpy(), etc. */
  if (phdr->p_vaddr < PGSIZE)
c002c0f7:	8b 45 08             	mov    0x8(%ebp),%eax
c002c0fa:	8b 40 08             	mov    0x8(%eax),%eax
c002c0fd:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002c102:	77 04                	ja     c002c108 <validate_segment+0xd5>
    return false;
c002c104:	b0 00                	mov    $0x0,%al
c002c106:	eb 02                	jmp    c002c10a <validate_segment+0xd7>

  /* It's okay. */
  return true;
c002c108:	b0 01                	mov    $0x1,%al
}
c002c10a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c10d:	c9                   	leave  
c002c10e:	c3                   	ret    

c002c10f <load_segment>:
   Return true if successful, false if a memory allocation error
   or disk read error occurs. */
static bool
load_segment (struct file *file, off_t ofs, uint8_t *upage,
              uint32_t read_bytes, uint32_t zero_bytes, bool writable) 
{
c002c10f:	55                   	push   %ebp
c002c110:	89 e5                	mov    %esp,%ebp
c002c112:	83 ec 28             	sub    $0x28,%esp
c002c115:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002c118:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
c002c11b:	8b 55 14             	mov    0x14(%ebp),%edx
c002c11e:	8b 45 18             	mov    0x18(%ebp),%eax
c002c121:	01 d0                	add    %edx,%eax
c002c123:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c128:	85 c0                	test   %eax,%eax
c002c12a:	74 21                	je     c002c14d <load_segment+0x3e>
c002c12c:	83 ec 0c             	sub    $0xc,%esp
c002c12f:	68 74 25 03 c0       	push   $0xc0032574
c002c134:	68 9c 25 03 c0       	push   $0xc003259c
c002c139:	68 ec 25 03 c0       	push   $0xc00325ec
c002c13e:	68 8c 01 00 00       	push   $0x18c
c002c143:	68 0a 25 03 c0       	push   $0xc003250a
c002c148:	e8 21 d6 ff ff       	call   c002976e <debug_panic>
  ASSERT (pg_ofs (upage) == 0);
c002c14d:	83 ec 0c             	sub    $0xc,%esp
c002c150:	ff 75 10             	pushl  0x10(%ebp)
c002c153:	e8 3d fa ff ff       	call   c002bb95 <pg_ofs>
c002c158:	83 c4 10             	add    $0x10,%esp
c002c15b:	85 c0                	test   %eax,%eax
c002c15d:	74 21                	je     c002c180 <load_segment+0x71>
c002c15f:	83 ec 0c             	sub    $0xc,%esp
c002c162:	68 b3 25 03 c0       	push   $0xc00325b3
c002c167:	68 9c 25 03 c0       	push   $0xc003259c
c002c16c:	68 ec 25 03 c0       	push   $0xc00325ec
c002c171:	68 8d 01 00 00       	push   $0x18d
c002c176:	68 0a 25 03 c0       	push   $0xc003250a
c002c17b:	e8 ee d5 ff ff       	call   c002976e <debug_panic>
  ASSERT (ofs % PGSIZE == 0);
c002c180:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c183:	25 ff 0f 00 00       	and    $0xfff,%eax
c002c188:	85 c0                	test   %eax,%eax
c002c18a:	74 21                	je     c002c1ad <load_segment+0x9e>
c002c18c:	83 ec 0c             	sub    $0xc,%esp
c002c18f:	68 c7 25 03 c0       	push   $0xc00325c7
c002c194:	68 9c 25 03 c0       	push   $0xc003259c
c002c199:	68 ec 25 03 c0       	push   $0xc00325ec
c002c19e:	68 8e 01 00 00       	push   $0x18e
c002c1a3:	68 0a 25 03 c0       	push   $0xc003250a
c002c1a8:	e8 c1 d5 ff ff       	call   c002976e <debug_panic>

  file_seek (file, ofs);
c002c1ad:	83 ec 08             	sub    $0x8,%esp
c002c1b0:	ff 75 0c             	pushl  0xc(%ebp)
c002c1b3:	ff 75 08             	pushl  0x8(%ebp)
c002c1b6:	e8 b7 1f 00 00       	call   c002e172 <file_seek>
c002c1bb:	83 c4 10             	add    $0x10,%esp
  while (read_bytes > 0 || zero_bytes > 0) 
c002c1be:	e9 c5 00 00 00       	jmp    c002c288 <load_segment+0x179>
    {
      /* Calculate how to fill this page.
         We will read PAGE_READ_BYTES bytes from FILE
         and zero the final PAGE_ZERO_BYTES bytes. */
      size_t page_read_bytes = read_bytes < PGSIZE ? read_bytes : PGSIZE;
c002c1c3:	8b 45 14             	mov    0x14(%ebp),%eax
c002c1c6:	3d 00 10 00 00       	cmp    $0x1000,%eax
c002c1cb:	76 05                	jbe    c002c1d2 <load_segment+0xc3>
c002c1cd:	b8 00 10 00 00       	mov    $0x1000,%eax
c002c1d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      size_t page_zero_bytes = PGSIZE - page_read_bytes;
c002c1d5:	b8 00 10 00 00       	mov    $0x1000,%eax
c002c1da:	2b 45 f4             	sub    -0xc(%ebp),%eax
c002c1dd:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /* Get a page of memory. */
      uint8_t *kpage = palloc_get_page (PAL_USER);
c002c1e0:	83 ec 0c             	sub    $0xc,%esp
c002c1e3:	6a 04                	push   $0x4
c002c1e5:	e8 61 71 ff ff       	call   c002334b <palloc_get_page>
c002c1ea:	83 c4 10             	add    $0x10,%esp
c002c1ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if (kpage == NULL)
c002c1f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002c1f4:	75 07                	jne    c002c1fd <load_segment+0xee>
        return false;
c002c1f6:	b0 00                	mov    $0x0,%al
c002c1f8:	e9 a1 00 00 00       	jmp    c002c29e <load_segment+0x18f>

      /* Load this page. */
      if (file_read (file, kpage, page_read_bytes) != (int) page_read_bytes)
c002c1fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c200:	83 ec 04             	sub    $0x4,%esp
c002c203:	50                   	push   %eax
c002c204:	ff 75 ec             	pushl  -0x14(%ebp)
c002c207:	ff 75 08             	pushl  0x8(%ebp)
c002c20a:	e8 cd 1d 00 00       	call   c002dfdc <file_read>
c002c20f:	83 c4 10             	add    $0x10,%esp
c002c212:	89 c2                	mov    %eax,%edx
c002c214:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c217:	39 c2                	cmp    %eax,%edx
c002c219:	74 12                	je     c002c22d <load_segment+0x11e>
        {
          palloc_free_page (kpage);
c002c21b:	83 ec 0c             	sub    $0xc,%esp
c002c21e:	ff 75 ec             	pushl  -0x14(%ebp)
c002c221:	e8 7d 72 ff ff       	call   c00234a3 <palloc_free_page>
c002c226:	83 c4 10             	add    $0x10,%esp
          return false; 
c002c229:	b0 00                	mov    $0x0,%al
c002c22b:	eb 71                	jmp    c002c29e <load_segment+0x18f>
        }
      memset (kpage + page_read_bytes, 0, page_zero_bytes);
c002c22d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002c230:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c233:	01 d0                	add    %edx,%eax
c002c235:	83 ec 04             	sub    $0x4,%esp
c002c238:	ff 75 f0             	pushl  -0x10(%ebp)
c002c23b:	6a 00                	push   $0x0
c002c23d:	50                   	push   %eax
c002c23e:	e8 45 c9 ff ff       	call   c0028b88 <memset>
c002c243:	83 c4 10             	add    $0x10,%esp

      /* Add the page to the process's address space. */
      if (!install_page (upage, kpage, writable)) 
c002c246:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002c24a:	83 ec 04             	sub    $0x4,%esp
c002c24d:	50                   	push   %eax
c002c24e:	ff 75 ec             	pushl  -0x14(%ebp)
c002c251:	ff 75 10             	pushl  0x10(%ebp)
c002c254:	e8 83 02 00 00       	call   c002c4dc <install_page>
c002c259:	83 c4 10             	add    $0x10,%esp
c002c25c:	83 f0 01             	xor    $0x1,%eax
c002c25f:	84 c0                	test   %al,%al
c002c261:	74 12                	je     c002c275 <load_segment+0x166>
        {
          palloc_free_page (kpage);
c002c263:	83 ec 0c             	sub    $0xc,%esp
c002c266:	ff 75 ec             	pushl  -0x14(%ebp)
c002c269:	e8 35 72 ff ff       	call   c00234a3 <palloc_free_page>
c002c26e:	83 c4 10             	add    $0x10,%esp
          return false; 
c002c271:	b0 00                	mov    $0x0,%al
c002c273:	eb 29                	jmp    c002c29e <load_segment+0x18f>
        }

      /* Advance. */
      read_bytes -= page_read_bytes;
c002c275:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c278:	29 45 14             	sub    %eax,0x14(%ebp)
      zero_bytes -= page_zero_bytes;
c002c27b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c27e:	29 45 18             	sub    %eax,0x18(%ebp)
      upage += PGSIZE;
c002c281:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
  while (read_bytes > 0 || zero_bytes > 0) 
c002c288:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002c28c:	0f 85 31 ff ff ff    	jne    c002c1c3 <load_segment+0xb4>
c002c292:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c002c296:	0f 85 27 ff ff ff    	jne    c002c1c3 <load_segment+0xb4>
    }
  return true;
c002c29c:	b0 01                	mov    $0x1,%al
}
c002c29e:	c9                   	leave  
c002c29f:	c3                   	ret    

c002c2a0 <setup_stack>:

/* Create a minimal stack by mapping a zeroed page at the top of
   user virtual memory. */
static bool
setup_stack (void **esp, const char *file_name) 
{
c002c2a0:	55                   	push   %ebp
c002c2a1:	89 e5                	mov    %esp,%ebp
c002c2a3:	53                   	push   %ebx
c002c2a4:	83 ec 34             	sub    $0x34,%esp

  uint8_t *kpage;
  bool success = false;
c002c2a7:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  kpage = palloc_get_page (PAL_USER | PAL_ZERO);
c002c2ab:	83 ec 0c             	sub    $0xc,%esp
c002c2ae:	6a 06                	push   $0x6
c002c2b0:	e8 96 70 ff ff       	call   c002334b <palloc_get_page>
c002c2b5:	83 c4 10             	add    $0x10,%esp
c002c2b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (kpage != NULL) 
c002c2bb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002c2bf:	74 37                	je     c002c2f8 <setup_stack+0x58>
    {
      success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
c002c2c1:	83 ec 04             	sub    $0x4,%esp
c002c2c4:	6a 01                	push   $0x1
c002c2c6:	ff 75 e8             	pushl  -0x18(%ebp)
c002c2c9:	68 00 f0 ff bf       	push   $0xbffff000
c002c2ce:	e8 09 02 00 00       	call   c002c4dc <install_page>
c002c2d3:	83 c4 10             	add    $0x10,%esp
c002c2d6:	88 45 f7             	mov    %al,-0x9(%ebp)
      if (success)
c002c2d9:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002c2dd:	74 0b                	je     c002c2ea <setup_stack+0x4a>
        *esp = PHYS_BASE;
c002c2df:	8b 45 08             	mov    0x8(%ebp),%eax
c002c2e2:	c7 00 00 00 00 c0    	movl   $0xc0000000,(%eax)
c002c2e8:	eb 0e                	jmp    c002c2f8 <setup_stack+0x58>
      else
        palloc_free_page (kpage);
c002c2ea:	83 ec 0c             	sub    $0xc,%esp
c002c2ed:	ff 75 e8             	pushl  -0x18(%ebp)
c002c2f0:	e8 ae 71 ff ff       	call   c00234a3 <palloc_free_page>
c002c2f5:	83 c4 10             	add    $0x10,%esp
    }

  char *token, *save_ptr;
  int argc = 0;  //to save number of arguments
c002c2f8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  int i;

  char *copy = malloc(strlen(file_name)+1);
c002c2ff:	83 ec 0c             	sub    $0xc,%esp
c002c302:	ff 75 0c             	pushl  0xc(%ebp)
c002c305:	e8 d7 c8 ff ff       	call   c0028be1 <strlen>
c002c30a:	83 c4 10             	add    $0x10,%esp
c002c30d:	40                   	inc    %eax
c002c30e:	83 ec 0c             	sub    $0xc,%esp
c002c311:	50                   	push   %eax
c002c312:	e8 7b 73 ff ff       	call   c0023692 <malloc>
c002c317:	83 c4 10             	add    $0x10,%esp
c002c31a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  strlcpy (copy, file_name, strlen(file_name)+1);
c002c31d:	83 ec 0c             	sub    $0xc,%esp
c002c320:	ff 75 0c             	pushl  0xc(%ebp)
c002c323:	e8 b9 c8 ff ff       	call   c0028be1 <strlen>
c002c328:	83 c4 10             	add    $0x10,%esp
c002c32b:	40                   	inc    %eax
c002c32c:	83 ec 04             	sub    $0x4,%esp
c002c32f:	50                   	push   %eax
c002c330:	ff 75 0c             	pushl  0xc(%ebp)
c002c333:	ff 75 e4             	pushl  -0x1c(%ebp)
c002c336:	e8 20 c9 ff ff       	call   c0028c5b <strlcpy>
c002c33b:	83 c4 10             	add    $0x10,%esp


  for (token = strtok_r (copy, " ", &save_ptr); token != NULL;
c002c33e:	83 ec 04             	sub    $0x4,%esp
c002c341:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002c344:	50                   	push   %eax
c002c345:	68 e4 24 03 c0       	push   $0xc00324e4
c002c34a:	ff 75 e4             	pushl  -0x1c(%ebp)
c002c34d:	e8 28 c7 ff ff       	call   c0028a7a <strtok_r>
c002c352:	83 c4 10             	add    $0x10,%esp
c002c355:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c358:	eb 20                	jmp    c002c37a <setup_stack+0xda>
    token = strtok_r (NULL, " ", &save_ptr))
    argc++;
c002c35a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c35d:	40                   	inc    %eax
c002c35e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    token = strtok_r (NULL, " ", &save_ptr))
c002c361:	83 ec 04             	sub    $0x4,%esp
c002c364:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002c367:	50                   	push   %eax
c002c368:	68 e4 24 03 c0       	push   $0xc00324e4
c002c36d:	6a 00                	push   $0x0
c002c36f:	e8 06 c7 ff ff       	call   c0028a7a <strtok_r>
c002c374:	83 c4 10             	add    $0x10,%esp
c002c377:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (token = strtok_r (copy, " ", &save_ptr); token != NULL;
c002c37a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c37e:	75 da                	jne    c002c35a <setup_stack+0xba>


  int *argv = calloc(argc,sizeof(int));  //allocate bytes for address of arg s which are initialized to zero
c002c380:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c383:	83 ec 08             	sub    $0x8,%esp
c002c386:	6a 04                	push   $0x4
c002c388:	50                   	push   %eax
c002c389:	e8 cd 74 ff ff       	call   c002385b <calloc>
c002c38e:	83 c4 10             	add    $0x10,%esp
c002c391:	89 45 e0             	mov    %eax,-0x20(%ebp)

  for (token = strtok_r (file_name, " ", &save_ptr),i=0; token != NULL;
c002c394:	83 ec 04             	sub    $0x4,%esp
c002c397:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002c39a:	50                   	push   %eax
c002c39b:	68 e4 24 03 c0       	push   $0xc00324e4
c002c3a0:	ff 75 0c             	pushl  0xc(%ebp)
c002c3a3:	e8 d2 c6 ff ff       	call   c0028a7a <strtok_r>
c002c3a8:	83 c4 10             	add    $0x10,%esp
c002c3ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c3ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002c3b5:	eb 75                	jmp    c002c42c <setup_stack+0x18c>
    token = strtok_r (NULL, " ", &save_ptr),i++)
    {
      *esp -= strlen(token) + 1; //decrement stack pointer
c002c3b7:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3ba:	8b 18                	mov    (%eax),%ebx
c002c3bc:	83 ec 0c             	sub    $0xc,%esp
c002c3bf:	ff 75 f0             	pushl  -0x10(%ebp)
c002c3c2:	e8 1a c8 ff ff       	call   c0028be1 <strlen>
c002c3c7:	83 c4 10             	add    $0x10,%esp
c002c3ca:	f7 d0                	not    %eax
c002c3cc:	8d 14 03             	lea    (%ebx,%eax,1),%edx
c002c3cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3d2:	89 10                	mov    %edx,(%eax)
      memcpy(*esp,token,strlen(token) + 1);  //copy the tokens
c002c3d4:	83 ec 0c             	sub    $0xc,%esp
c002c3d7:	ff 75 f0             	pushl  -0x10(%ebp)
c002c3da:	e8 02 c8 ff ff       	call   c0028be1 <strlen>
c002c3df:	83 c4 10             	add    $0x10,%esp
c002c3e2:	8d 50 01             	lea    0x1(%eax),%edx
c002c3e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3e8:	8b 00                	mov    (%eax),%eax
c002c3ea:	83 ec 04             	sub    $0x4,%esp
c002c3ed:	52                   	push   %edx
c002c3ee:	ff 75 f0             	pushl  -0x10(%ebp)
c002c3f1:	50                   	push   %eax
c002c3f2:	e8 b7 c1 ff ff       	call   c00285ae <memcpy>
c002c3f7:	83 c4 10             	add    $0x10,%esp
      argv[i]=*esp;   //save the address of pointer for each arg
c002c3fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c3fd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c404:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c407:	01 c2                	add    %eax,%edx
c002c409:	8b 45 08             	mov    0x8(%ebp),%eax
c002c40c:	8b 00                	mov    (%eax),%eax
c002c40e:	89 02                	mov    %eax,(%edx)
    token = strtok_r (NULL, " ", &save_ptr),i++)
c002c410:	83 ec 04             	sub    $0x4,%esp
c002c413:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002c416:	50                   	push   %eax
c002c417:	68 e4 24 03 c0       	push   $0xc00324e4
c002c41c:	6a 00                	push   $0x0
c002c41e:	e8 57 c6 ff ff       	call   c0028a7a <strtok_r>
c002c423:	83 c4 10             	add    $0x10,%esp
c002c426:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c429:	ff 45 ec             	incl   -0x14(%ebp)
  for (token = strtok_r (file_name, " ", &save_ptr),i=0; token != NULL;
c002c42c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c430:	75 85                	jne    c002c3b7 <setup_stack+0x117>
    }

  while((int)*esp%4!=0)
c002c432:	eb 0d                	jmp    c002c441 <setup_stack+0x1a1>
  {
    *esp-=sizeof(char);  //decrement for correct allignment
c002c434:	8b 45 08             	mov    0x8(%ebp),%eax
c002c437:	8b 00                	mov    (%eax),%eax
c002c439:	8d 50 ff             	lea    -0x1(%eax),%edx
c002c43c:	8b 45 08             	mov    0x8(%ebp),%eax
c002c43f:	89 10                	mov    %edx,(%eax)
  while((int)*esp%4!=0)
c002c441:	8b 45 08             	mov    0x8(%ebp),%eax
c002c444:	8b 00                	mov    (%eax),%eax
c002c446:	83 e0 03             	and    $0x3,%eax
c002c449:	85 c0                	test   %eax,%eax
c002c44b:	75 e7                	jne    c002c434 <setup_stack+0x194>
  }

  *esp-=sizeof(int);  //decrement for 4 0
c002c44d:	8b 45 08             	mov    0x8(%ebp),%eax
c002c450:	8b 00                	mov    (%eax),%eax
c002c452:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c455:	8b 45 08             	mov    0x8(%ebp),%eax
c002c458:	89 10                	mov    %edx,(%eax)

  for(i=argc-1;i>=0;i--)
c002c45a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c45d:	48                   	dec    %eax
c002c45e:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002c461:	eb 28                	jmp    c002c48b <setup_stack+0x1eb>
  {
    *esp-=sizeof(int);
c002c463:	8b 45 08             	mov    0x8(%ebp),%eax
c002c466:	8b 00                	mov    (%eax),%eax
c002c468:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c46b:	8b 45 08             	mov    0x8(%ebp),%eax
c002c46e:	89 10                	mov    %edx,(%eax)
    memcpy(*esp,&argv[i],sizeof(int));    //copy the pointers of args
c002c470:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c473:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c47a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c47d:	01 c2                	add    %eax,%edx
c002c47f:	8b 45 08             	mov    0x8(%ebp),%eax
c002c482:	8b 00                	mov    (%eax),%eax
c002c484:	8b 12                	mov    (%edx),%edx
c002c486:	89 10                	mov    %edx,(%eax)
  for(i=argc-1;i>=0;i--)
c002c488:	ff 4d ec             	decl   -0x14(%ebp)
c002c48b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002c48f:	79 d2                	jns    c002c463 <setup_stack+0x1c3>
  }

  int pt = *esp;
c002c491:	8b 45 08             	mov    0x8(%ebp),%eax
c002c494:	8b 00                	mov    (%eax),%eax
c002c496:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  *esp-=sizeof(int);
c002c499:	8b 45 08             	mov    0x8(%ebp),%eax
c002c49c:	8b 00                	mov    (%eax),%eax
c002c49e:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c4a1:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4a4:	89 10                	mov    %edx,(%eax)
  memcpy(*esp,&pt,sizeof(int));   //copy pointer to the block which has pointer to address of first arg 
c002c4a6:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4a9:	8b 00                	mov    (%eax),%eax
c002c4ab:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002c4ae:	89 10                	mov    %edx,(%eax)

  *esp-=sizeof(int);
c002c4b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4b3:	8b 00                	mov    (%eax),%eax
c002c4b5:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c4b8:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4bb:	89 10                	mov    %edx,(%eax)
  memcpy(*esp,&argc,sizeof(int));   //copy number of args
c002c4bd:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4c0:	8b 00                	mov    (%eax),%eax
c002c4c2:	8b 55 d8             	mov    -0x28(%ebp),%edx
c002c4c5:	89 10                	mov    %edx,(%eax)

  *esp-=sizeof(int);    //for return address
c002c4c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4ca:	8b 00                	mov    (%eax),%eax
c002c4cc:	8d 50 fc             	lea    -0x4(%eax),%edx
c002c4cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002c4d2:	89 10                	mov    %edx,(%eax)

  return success;
c002c4d4:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002c4d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c4da:	c9                   	leave  
c002c4db:	c3                   	ret    

c002c4dc <install_page>:
   with palloc_get_page().
   Returns true on success, false if UPAGE is already mapped or
   if memory allocation fails. */
static bool
install_page (void *upage, void *kpage, bool writable)
{
c002c4dc:	55                   	push   %ebp
c002c4dd:	89 e5                	mov    %esp,%ebp
c002c4df:	83 ec 28             	sub    $0x28,%esp
c002c4e2:	8b 45 10             	mov    0x10(%ebp),%eax
c002c4e5:	88 45 e4             	mov    %al,-0x1c(%ebp)
  struct thread *t = thread_current ();
c002c4e8:	e8 73 49 ff ff       	call   c0020e60 <thread_current>
c002c4ed:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Verify that there's not already a page at that virtual
     address, then map our page there. */
  return (pagedir_get_page (t->pagedir, upage) == NULL
c002c4f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c4f3:	8b 40 50             	mov    0x50(%eax),%eax
c002c4f6:	83 ec 08             	sub    $0x8,%esp
c002c4f9:	ff 75 08             	pushl  0x8(%ebp)
c002c4fc:	50                   	push   %eax
c002c4fd:	e8 a7 05 00 00       	call   c002caa9 <pagedir_get_page>
c002c502:	83 c4 10             	add    $0x10,%esp
          && pagedir_set_page (t->pagedir, upage, kpage, writable));
c002c505:	85 c0                	test   %eax,%eax
c002c507:	75 25                	jne    c002c52e <install_page+0x52>
c002c509:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c002c50d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c510:	8b 40 50             	mov    0x50(%eax),%eax
c002c513:	52                   	push   %edx
c002c514:	ff 75 0c             	pushl  0xc(%ebp)
c002c517:	ff 75 08             	pushl  0x8(%ebp)
c002c51a:	50                   	push   %eax
c002c51b:	e8 26 04 00 00       	call   c002c946 <pagedir_set_page>
c002c520:	83 c4 10             	add    $0x10,%esp
c002c523:	84 c0                	test   %al,%al
c002c525:	74 07                	je     c002c52e <install_page+0x52>
c002c527:	b8 01 00 00 00       	mov    $0x1,%eax
c002c52c:	eb 05                	jmp    c002c533 <install_page+0x57>
c002c52e:	b8 00 00 00 00       	mov    $0x0,%eax
c002c533:	83 e0 01             	and    $0x1,%eax
}
c002c536:	c9                   	leave  
c002c537:	c3                   	ret    

c002c538 <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c002c538:	55                   	push   %ebp
c002c539:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c002c53b:	8b 45 08             	mov    0x8(%ebp),%eax
c002c53e:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002c543:	5d                   	pop    %ebp
c002c544:	c3                   	ret    

c002c545 <is_user_vaddr>:
{
c002c545:	55                   	push   %ebp
c002c546:	89 e5                	mov    %esp,%ebp
  return vaddr < PHYS_BASE;
c002c548:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002c54f:	0f 96 c0             	setbe  %al
}
c002c552:	5d                   	pop    %ebp
c002c553:	c3                   	ret    

c002c554 <is_kernel_vaddr>:
{
c002c554:	55                   	push   %ebp
c002c555:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c002c557:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002c55e:	0f 97 c0             	seta   %al
}
c002c561:	5d                   	pop    %ebp
c002c562:	c3                   	ret    

c002c563 <ptov>:
{
c002c563:	55                   	push   %ebp
c002c564:	89 e5                	mov    %esp,%ebp
c002c566:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c002c569:	8b 45 08             	mov    0x8(%ebp),%eax
c002c56c:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c571:	76 1e                	jbe    c002c591 <ptov+0x2e>
c002c573:	83 ec 0c             	sub    $0xc,%esp
c002c576:	68 fc 25 03 c0       	push   $0xc00325fc
c002c57b:	68 17 26 03 c0       	push   $0xc0032617
c002c580:	68 a8 27 03 c0       	push   $0xc00327a8
c002c585:	6a 4a                	push   $0x4a
c002c587:	68 2e 26 03 c0       	push   $0xc003262e
c002c58c:	e8 dd d1 ff ff       	call   c002976e <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c002c591:	8b 45 08             	mov    0x8(%ebp),%eax
c002c594:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c002c599:	c9                   	leave  
c002c59a:	c3                   	ret    

c002c59b <vtop>:
{
c002c59b:	55                   	push   %ebp
c002c59c:	89 e5                	mov    %esp,%ebp
c002c59e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c002c5a1:	ff 75 08             	pushl  0x8(%ebp)
c002c5a4:	e8 ab ff ff ff       	call   c002c554 <is_kernel_vaddr>
c002c5a9:	83 c4 04             	add    $0x4,%esp
c002c5ac:	84 c0                	test   %al,%al
c002c5ae:	75 1e                	jne    c002c5ce <vtop+0x33>
c002c5b0:	83 ec 0c             	sub    $0xc,%esp
c002c5b3:	68 44 26 03 c0       	push   $0xc0032644
c002c5b8:	68 17 26 03 c0       	push   $0xc0032617
c002c5bd:	68 c8 27 03 c0       	push   $0xc00327c8
c002c5c2:	6a 54                	push   $0x54
c002c5c4:	68 2e 26 03 c0       	push   $0xc003262e
c002c5c9:	e8 a0 d1 ff ff       	call   c002976e <debug_panic>
  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c002c5ce:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5d1:	05 00 00 00 40       	add    $0x40000000,%eax
}
c002c5d6:	c9                   	leave  
c002c5d7:	c3                   	ret    

c002c5d8 <pt_no>:
static inline unsigned pt_no (const void *va) {
c002c5d8:	55                   	push   %ebp
c002c5d9:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c002c5db:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5de:	c1 e8 0c             	shr    $0xc,%eax
c002c5e1:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c002c5e6:	5d                   	pop    %ebp
c002c5e7:	c3                   	ret    

c002c5e8 <pd_no>:
static inline uintptr_t pd_no (const void *va) {
c002c5e8:	55                   	push   %ebp
c002c5e9:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c002c5eb:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5ee:	c1 e8 16             	shr    $0x16,%eax
}
c002c5f1:	5d                   	pop    %ebp
c002c5f2:	c3                   	ret    

c002c5f3 <pde_create>:
static inline uint32_t pde_create (uint32_t *pt) {
c002c5f3:	55                   	push   %ebp
c002c5f4:	89 e5                	mov    %esp,%ebp
c002c5f6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c002c5f9:	ff 75 08             	pushl  0x8(%ebp)
c002c5fc:	e8 37 ff ff ff       	call   c002c538 <pg_ofs>
c002c601:	83 c4 04             	add    $0x4,%esp
c002c604:	85 c0                	test   %eax,%eax
c002c606:	74 1e                	je     c002c626 <pde_create+0x33>
c002c608:	83 ec 0c             	sub    $0xc,%esp
c002c60b:	68 5c 26 03 c0       	push   $0xc003265c
c002c610:	68 17 26 03 c0       	push   $0xc0032617
c002c615:	68 bc 27 03 c0       	push   $0xc00327bc
c002c61a:	6a 48                	push   $0x48
c002c61c:	68 6d 26 03 c0       	push   $0xc003266d
c002c621:	e8 48 d1 ff ff       	call   c002976e <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c002c626:	83 ec 0c             	sub    $0xc,%esp
c002c629:	ff 75 08             	pushl  0x8(%ebp)
c002c62c:	e8 6a ff ff ff       	call   c002c59b <vtop>
c002c631:	83 c4 10             	add    $0x10,%esp
c002c634:	83 c8 07             	or     $0x7,%eax
}
c002c637:	c9                   	leave  
c002c638:	c3                   	ret    

c002c639 <pde_get_pt>:
static inline uint32_t *pde_get_pt (uint32_t pde) {
c002c639:	55                   	push   %ebp
c002c63a:	89 e5                	mov    %esp,%ebp
c002c63c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pde & PTE_P);
c002c63f:	8b 45 08             	mov    0x8(%ebp),%eax
c002c642:	83 e0 01             	and    $0x1,%eax
c002c645:	85 c0                	test   %eax,%eax
c002c647:	75 1e                	jne    c002c667 <pde_get_pt+0x2e>
c002c649:	83 ec 0c             	sub    $0xc,%esp
c002c64c:	68 81 26 03 c0       	push   $0xc0032681
c002c651:	68 17 26 03 c0       	push   $0xc0032617
c002c656:	68 9c 27 03 c0       	push   $0xc003279c
c002c65b:	6a 4f                	push   $0x4f
c002c65d:	68 6d 26 03 c0       	push   $0xc003266d
c002c662:	e8 07 d1 ff ff       	call   c002976e <debug_panic>
  return ptov (pde & PTE_ADDR);
c002c667:	8b 45 08             	mov    0x8(%ebp),%eax
c002c66a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c66f:	83 ec 0c             	sub    $0xc,%esp
c002c672:	50                   	push   %eax
c002c673:	e8 eb fe ff ff       	call   c002c563 <ptov>
c002c678:	83 c4 10             	add    $0x10,%esp
}
c002c67b:	c9                   	leave  
c002c67c:	c3                   	ret    

c002c67d <pte_create_kernel>:
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c002c67d:	55                   	push   %ebp
c002c67e:	89 e5                	mov    %esp,%ebp
c002c680:	83 ec 18             	sub    $0x18,%esp
c002c683:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c686:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c002c689:	ff 75 08             	pushl  0x8(%ebp)
c002c68c:	e8 a7 fe ff ff       	call   c002c538 <pg_ofs>
c002c691:	83 c4 04             	add    $0x4,%esp
c002c694:	85 c0                	test   %eax,%eax
c002c696:	74 1e                	je     c002c6b6 <pte_create_kernel+0x39>
c002c698:	83 ec 0c             	sub    $0xc,%esp
c002c69b:	68 8d 26 03 c0       	push   $0xc003268d
c002c6a0:	68 17 26 03 c0       	push   $0xc0032617
c002c6a5:	68 e4 27 03 c0       	push   $0xc00327e4
c002c6aa:	6a 58                	push   $0x58
c002c6ac:	68 6d 26 03 c0       	push   $0xc003266d
c002c6b1:	e8 b8 d0 ff ff       	call   c002976e <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002c6b6:	83 ec 0c             	sub    $0xc,%esp
c002c6b9:	ff 75 08             	pushl  0x8(%ebp)
c002c6bc:	e8 da fe ff ff       	call   c002c59b <vtop>
c002c6c1:	83 c4 10             	add    $0x10,%esp
c002c6c4:	89 c2                	mov    %eax,%edx
c002c6c6:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002c6ca:	74 07                	je     c002c6d3 <pte_create_kernel+0x56>
c002c6cc:	b8 02 00 00 00       	mov    $0x2,%eax
c002c6d1:	eb 05                	jmp    c002c6d8 <pte_create_kernel+0x5b>
c002c6d3:	b8 00 00 00 00       	mov    $0x0,%eax
c002c6d8:	09 d0                	or     %edx,%eax
c002c6da:	83 c8 01             	or     $0x1,%eax
}
c002c6dd:	c9                   	leave  
c002c6de:	c3                   	ret    

c002c6df <pte_create_user>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable by both user and kernel code. */
static inline uint32_t pte_create_user (void *page, bool writable) {
c002c6df:	55                   	push   %ebp
c002c6e0:	89 e5                	mov    %esp,%ebp
c002c6e2:	83 ec 18             	sub    $0x18,%esp
c002c6e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c6e8:	88 45 f4             	mov    %al,-0xc(%ebp)
  return pte_create_kernel (page, writable) | PTE_U;
c002c6eb:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002c6ef:	83 ec 08             	sub    $0x8,%esp
c002c6f2:	50                   	push   %eax
c002c6f3:	ff 75 08             	pushl  0x8(%ebp)
c002c6f6:	e8 82 ff ff ff       	call   c002c67d <pte_create_kernel>
c002c6fb:	83 c4 10             	add    $0x10,%esp
c002c6fe:	83 c8 04             	or     $0x4,%eax
}
c002c701:	c9                   	leave  
c002c702:	c3                   	ret    

c002c703 <pte_get_page>:

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page (uint32_t pte) {
c002c703:	55                   	push   %ebp
c002c704:	89 e5                	mov    %esp,%ebp
c002c706:	83 ec 08             	sub    $0x8,%esp
  return ptov (pte & PTE_ADDR);
c002c709:	8b 45 08             	mov    0x8(%ebp),%eax
c002c70c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c711:	83 ec 0c             	sub    $0xc,%esp
c002c714:	50                   	push   %eax
c002c715:	e8 49 fe ff ff       	call   c002c563 <ptov>
c002c71a:	83 c4 10             	add    $0x10,%esp
}
c002c71d:	c9                   	leave  
c002c71e:	c3                   	ret    

c002c71f <pagedir_create>:
   virtual addresses, but n one for user virtual addresses.
   Returns the new page directory, or a null pointer if memory
   allocation fails. */
uint32_t *
pagedir_create (void) 
{
c002c71f:	55                   	push   %ebp
c002c720:	89 e5                	mov    %esp,%ebp
c002c722:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pd = palloc_get_page (0);
c002c725:	83 ec 0c             	sub    $0xc,%esp
c002c728:	6a 00                	push   $0x0
c002c72a:	e8 1c 6c ff ff       	call   c002334b <palloc_get_page>
c002c72f:	83 c4 10             	add    $0x10,%esp
c002c732:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pd != NULL)
c002c735:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002c739:	74 19                	je     c002c754 <pagedir_create+0x35>
    memcpy (pd, init_page_dir, PGSIZE);
c002c73b:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c002c740:	83 ec 04             	sub    $0x4,%esp
c002c743:	68 00 10 00 00       	push   $0x1000
c002c748:	50                   	push   %eax
c002c749:	ff 75 f4             	pushl  -0xc(%ebp)
c002c74c:	e8 5d be ff ff       	call   c00285ae <memcpy>
c002c751:	83 c4 10             	add    $0x10,%esp
  return pd;
c002c754:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002c757:	c9                   	leave  
c002c758:	c3                   	ret    

c002c759 <pagedir_destroy>:

/* Destroys page directory PD, freeing all the pages it
   references. */
void
pagedir_destroy (uint32_t *pd) 
{
c002c759:	55                   	push   %ebp
c002c75a:	89 e5                	mov    %esp,%ebp
c002c75c:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pde;

  if (pd == NULL)
c002c75f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c763:	0f 84 d9 00 00 00    	je     c002c842 <pagedir_destroy+0xe9>
    return;

  ASSERT (pd != init_page_dir);
c002c769:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c002c76e:	39 45 08             	cmp    %eax,0x8(%ebp)
c002c771:	75 1e                	jne    c002c791 <pagedir_destroy+0x38>
c002c773:	83 ec 0c             	sub    $0xc,%esp
c002c776:	68 a0 26 03 c0       	push   $0xc00326a0
c002c77b:	68 17 26 03 c0       	push   $0xc0032617
c002c780:	68 8c 27 03 c0       	push   $0xc003278c
c002c785:	6a 23                	push   $0x23
c002c787:	68 b4 26 03 c0       	push   $0xc00326b4
c002c78c:	e8 dd cf ff ff       	call   c002976e <debug_panic>
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002c791:	8b 45 08             	mov    0x8(%ebp),%eax
c002c794:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c797:	eb 74                	jmp    c002c80d <pagedir_destroy+0xb4>
    if (*pde & PTE_P) 
c002c799:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c79c:	8b 00                	mov    (%eax),%eax
c002c79e:	83 e0 01             	and    $0x1,%eax
c002c7a1:	85 c0                	test   %eax,%eax
c002c7a3:	74 64                	je     c002c809 <pagedir_destroy+0xb0>
      {
        uint32_t *pt = pde_get_pt (*pde);
c002c7a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c7a8:	8b 00                	mov    (%eax),%eax
c002c7aa:	83 ec 0c             	sub    $0xc,%esp
c002c7ad:	50                   	push   %eax
c002c7ae:	e8 86 fe ff ff       	call   c002c639 <pde_get_pt>
c002c7b3:	83 c4 10             	add    $0x10,%esp
c002c7b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t *pte;
        
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002c7b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c7bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c7bf:	eb 2d                	jmp    c002c7ee <pagedir_destroy+0x95>
          if (*pte & PTE_P) 
c002c7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c7c4:	8b 00                	mov    (%eax),%eax
c002c7c6:	83 e0 01             	and    $0x1,%eax
c002c7c9:	85 c0                	test   %eax,%eax
c002c7cb:	74 1d                	je     c002c7ea <pagedir_destroy+0x91>
            palloc_free_page (pte_get_page (*pte));
c002c7cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c7d0:	8b 00                	mov    (%eax),%eax
c002c7d2:	83 ec 0c             	sub    $0xc,%esp
c002c7d5:	50                   	push   %eax
c002c7d6:	e8 28 ff ff ff       	call   c002c703 <pte_get_page>
c002c7db:	83 c4 10             	add    $0x10,%esp
c002c7de:	83 ec 0c             	sub    $0xc,%esp
c002c7e1:	50                   	push   %eax
c002c7e2:	e8 bc 6c ff ff       	call   c00234a3 <palloc_free_page>
c002c7e7:	83 c4 10             	add    $0x10,%esp
        for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002c7ea:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
c002c7ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c7f1:	05 00 10 00 00       	add    $0x1000,%eax
c002c7f6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002c7f9:	77 c6                	ja     c002c7c1 <pagedir_destroy+0x68>
        palloc_free_page (pt);
c002c7fb:	83 ec 0c             	sub    $0xc,%esp
c002c7fe:	ff 75 ec             	pushl  -0x14(%ebp)
c002c801:	e8 9d 6c ff ff       	call   c00234a3 <palloc_free_page>
c002c806:	83 c4 10             	add    $0x10,%esp
  for (pde = pd; pde < pd + pd_no (PHYS_BASE); pde++)
c002c809:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002c80d:	83 ec 0c             	sub    $0xc,%esp
c002c810:	68 00 00 00 c0       	push   $0xc0000000
c002c815:	e8 ce fd ff ff       	call   c002c5e8 <pd_no>
c002c81a:	83 c4 10             	add    $0x10,%esp
c002c81d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c824:	8b 45 08             	mov    0x8(%ebp),%eax
c002c827:	01 d0                	add    %edx,%eax
c002c829:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c82c:	0f 87 67 ff ff ff    	ja     c002c799 <pagedir_destroy+0x40>
      }
  palloc_free_page (pd);
c002c832:	83 ec 0c             	sub    $0xc,%esp
c002c835:	ff 75 08             	pushl  0x8(%ebp)
c002c838:	e8 66 6c ff ff       	call   c00234a3 <palloc_free_page>
c002c83d:	83 c4 10             	add    $0x10,%esp
c002c840:	eb 01                	jmp    c002c843 <pagedir_destroy+0xea>
    return;
c002c842:	90                   	nop
}
c002c843:	c9                   	leave  
c002c844:	c3                   	ret    

c002c845 <lookup_page>:
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page (uint32_t *pd, const void *vaddr, bool create)
{
c002c845:	55                   	push   %ebp
c002c846:	89 e5                	mov    %esp,%ebp
c002c848:	83 ec 28             	sub    $0x28,%esp
c002c84b:	8b 45 10             	mov    0x10(%ebp),%eax
c002c84e:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pt, *pde;

  ASSERT (pd != NULL);
c002c851:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002c855:	75 1e                	jne    c002c875 <lookup_page+0x30>
c002c857:	83 ec 0c             	sub    $0xc,%esp
c002c85a:	68 cd 26 03 c0       	push   $0xc00326cd
c002c85f:	68 17 26 03 c0       	push   $0xc0032617
c002c864:	68 b0 27 03 c0       	push   $0xc00327b0
c002c869:	6a 3d                	push   $0x3d
c002c86b:	68 b4 26 03 c0       	push   $0xc00326b4
c002c870:	e8 f9 ce ff ff       	call   c002976e <debug_panic>

  /* Shouldn't create new kernel virtual mappings. */
  ASSERT (!create || is_user_vaddr (vaddr));
c002c875:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002c878:	83 f0 01             	xor    $0x1,%eax
c002c87b:	84 c0                	test   %al,%al
c002c87d:	75 30                	jne    c002c8af <lookup_page+0x6a>
c002c87f:	83 ec 0c             	sub    $0xc,%esp
c002c882:	ff 75 0c             	pushl  0xc(%ebp)
c002c885:	e8 bb fc ff ff       	call   c002c545 <is_user_vaddr>
c002c88a:	83 c4 10             	add    $0x10,%esp
c002c88d:	84 c0                	test   %al,%al
c002c88f:	75 1e                	jne    c002c8af <lookup_page+0x6a>
c002c891:	83 ec 0c             	sub    $0xc,%esp
c002c894:	68 d8 26 03 c0       	push   $0xc00326d8
c002c899:	68 17 26 03 c0       	push   $0xc0032617
c002c89e:	68 b0 27 03 c0       	push   $0xc00327b0
c002c8a3:	6a 40                	push   $0x40
c002c8a5:	68 b4 26 03 c0       	push   $0xc00326b4
c002c8aa:	e8 bf ce ff ff       	call   c002976e <debug_panic>

  /* Check for a page table for VADDR.
     If one is missing, create one if requested. */
  pde = pd + pd_no (vaddr);
c002c8af:	83 ec 0c             	sub    $0xc,%esp
c002c8b2:	ff 75 0c             	pushl  0xc(%ebp)
c002c8b5:	e8 2e fd ff ff       	call   c002c5e8 <pd_no>
c002c8ba:	83 c4 10             	add    $0x10,%esp
c002c8bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c8c4:	8b 45 08             	mov    0x8(%ebp),%eax
c002c8c7:	01 d0                	add    %edx,%eax
c002c8c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (*pde == 0) 
c002c8cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c8cf:	8b 00                	mov    (%eax),%eax
c002c8d1:	85 c0                	test   %eax,%eax
c002c8d3:	75 41                	jne    c002c916 <lookup_page+0xd1>
    {
      if (create)
c002c8d5:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c002c8d9:	74 34                	je     c002c90f <lookup_page+0xca>
        {
          pt = palloc_get_page (PAL_ZERO);
c002c8db:	83 ec 0c             	sub    $0xc,%esp
c002c8de:	6a 02                	push   $0x2
c002c8e0:	e8 66 6a ff ff       	call   c002334b <palloc_get_page>
c002c8e5:	83 c4 10             	add    $0x10,%esp
c002c8e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (pt == NULL) 
c002c8eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c8ef:	75 07                	jne    c002c8f8 <lookup_page+0xb3>
            return NULL; 
c002c8f1:	b8 00 00 00 00       	mov    $0x0,%eax
c002c8f6:	eb 4c                	jmp    c002c944 <lookup_page+0xff>
      
          *pde = pde_create (pt);
c002c8f8:	83 ec 0c             	sub    $0xc,%esp
c002c8fb:	ff 75 f0             	pushl  -0x10(%ebp)
c002c8fe:	e8 f0 fc ff ff       	call   c002c5f3 <pde_create>
c002c903:	83 c4 10             	add    $0x10,%esp
c002c906:	89 c2                	mov    %eax,%edx
c002c908:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c90b:	89 10                	mov    %edx,(%eax)
c002c90d:	eb 07                	jmp    c002c916 <lookup_page+0xd1>
        }
      else
        return NULL;
c002c90f:	b8 00 00 00 00       	mov    $0x0,%eax
c002c914:	eb 2e                	jmp    c002c944 <lookup_page+0xff>
    }

  /* Return the page table entry. */
  pt = pde_get_pt (*pde);
c002c916:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c919:	8b 00                	mov    (%eax),%eax
c002c91b:	83 ec 0c             	sub    $0xc,%esp
c002c91e:	50                   	push   %eax
c002c91f:	e8 15 fd ff ff       	call   c002c639 <pde_get_pt>
c002c924:	83 c4 10             	add    $0x10,%esp
c002c927:	89 45 f0             	mov    %eax,-0x10(%ebp)
  return &pt[pt_no (vaddr)];
c002c92a:	83 ec 0c             	sub    $0xc,%esp
c002c92d:	ff 75 0c             	pushl  0xc(%ebp)
c002c930:	e8 a3 fc ff ff       	call   c002c5d8 <pt_no>
c002c935:	83 c4 10             	add    $0x10,%esp
c002c938:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c93f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c942:	01 d0                	add    %edx,%eax
}
c002c944:	c9                   	leave  
c002c945:	c3                   	ret    

c002c946 <pagedir_set_page>:
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool
pagedir_set_page (uint32_t *pd, void *upage, void *kpage, bool writable)
{
c002c946:	55                   	push   %ebp
c002c947:	89 e5                	mov    %esp,%ebp
c002c949:	83 ec 28             	sub    $0x28,%esp
c002c94c:	8b 45 14             	mov    0x14(%ebp),%eax
c002c94f:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pte;

  ASSERT (pg_ofs (upage) == 0);
c002c952:	ff 75 0c             	pushl  0xc(%ebp)
c002c955:	e8 de fb ff ff       	call   c002c538 <pg_ofs>
c002c95a:	83 c4 04             	add    $0x4,%esp
c002c95d:	85 c0                	test   %eax,%eax
c002c95f:	74 1e                	je     c002c97f <pagedir_set_page+0x39>
c002c961:	83 ec 0c             	sub    $0xc,%esp
c002c964:	68 f9 26 03 c0       	push   $0xc00326f9
c002c969:	68 17 26 03 c0       	push   $0xc0032617
c002c96e:	68 d0 27 03 c0       	push   $0xc00327d0
c002c973:	6a 67                	push   $0x67
c002c975:	68 b4 26 03 c0       	push   $0xc00326b4
c002c97a:	e8 ef cd ff ff       	call   c002976e <debug_panic>
  ASSERT (pg_ofs (kpage) == 0);
c002c97f:	83 ec 0c             	sub    $0xc,%esp
c002c982:	ff 75 10             	pushl  0x10(%ebp)
c002c985:	e8 ae fb ff ff       	call   c002c538 <pg_ofs>
c002c98a:	83 c4 10             	add    $0x10,%esp
c002c98d:	85 c0                	test   %eax,%eax
c002c98f:	74 1e                	je     c002c9af <pagedir_set_page+0x69>
c002c991:	83 ec 0c             	sub    $0xc,%esp
c002c994:	68 0d 27 03 c0       	push   $0xc003270d
c002c999:	68 17 26 03 c0       	push   $0xc0032617
c002c99e:	68 d0 27 03 c0       	push   $0xc00327d0
c002c9a3:	6a 68                	push   $0x68
c002c9a5:	68 b4 26 03 c0       	push   $0xc00326b4
c002c9aa:	e8 bf cd ff ff       	call   c002976e <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002c9af:	83 ec 0c             	sub    $0xc,%esp
c002c9b2:	ff 75 0c             	pushl  0xc(%ebp)
c002c9b5:	e8 8b fb ff ff       	call   c002c545 <is_user_vaddr>
c002c9ba:	83 c4 10             	add    $0x10,%esp
c002c9bd:	84 c0                	test   %al,%al
c002c9bf:	75 1e                	jne    c002c9df <pagedir_set_page+0x99>
c002c9c1:	83 ec 0c             	sub    $0xc,%esp
c002c9c4:	68 21 27 03 c0       	push   $0xc0032721
c002c9c9:	68 17 26 03 c0       	push   $0xc0032617
c002c9ce:	68 d0 27 03 c0       	push   $0xc00327d0
c002c9d3:	6a 69                	push   $0x69
c002c9d5:	68 b4 26 03 c0       	push   $0xc00326b4
c002c9da:	e8 8f cd ff ff       	call   c002976e <debug_panic>
  ASSERT (vtop (kpage) >> PTSHIFT < init_ram_pages);
c002c9df:	83 ec 0c             	sub    $0xc,%esp
c002c9e2:	ff 75 10             	pushl  0x10(%ebp)
c002c9e5:	e8 b1 fb ff ff       	call   c002c59b <vtop>
c002c9ea:	83 c4 10             	add    $0x10,%esp
c002c9ed:	c1 e8 0c             	shr    $0xc,%eax
c002c9f0:	89 c2                	mov    %eax,%edx
c002c9f2:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c002c9f7:	39 c2                	cmp    %eax,%edx
c002c9f9:	72 1e                	jb     c002ca19 <pagedir_set_page+0xd3>
c002c9fb:	83 ec 0c             	sub    $0xc,%esp
c002c9fe:	68 38 27 03 c0       	push   $0xc0032738
c002ca03:	68 17 26 03 c0       	push   $0xc0032617
c002ca08:	68 d0 27 03 c0       	push   $0xc00327d0
c002ca0d:	6a 6a                	push   $0x6a
c002ca0f:	68 b4 26 03 c0       	push   $0xc00326b4
c002ca14:	e8 55 cd ff ff       	call   c002976e <debug_panic>
  ASSERT (pd != init_page_dir);
c002ca19:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c002ca1e:	39 45 08             	cmp    %eax,0x8(%ebp)
c002ca21:	75 1e                	jne    c002ca41 <pagedir_set_page+0xfb>
c002ca23:	83 ec 0c             	sub    $0xc,%esp
c002ca26:	68 a0 26 03 c0       	push   $0xc00326a0
c002ca2b:	68 17 26 03 c0       	push   $0xc0032617
c002ca30:	68 d0 27 03 c0       	push   $0xc00327d0
c002ca35:	6a 6b                	push   $0x6b
c002ca37:	68 b4 26 03 c0       	push   $0xc00326b4
c002ca3c:	e8 2d cd ff ff       	call   c002976e <debug_panic>

  pte = lookup_page (pd, upage, true);
c002ca41:	83 ec 04             	sub    $0x4,%esp
c002ca44:	6a 01                	push   $0x1
c002ca46:	ff 75 0c             	pushl  0xc(%ebp)
c002ca49:	ff 75 08             	pushl  0x8(%ebp)
c002ca4c:	e8 f4 fd ff ff       	call   c002c845 <lookup_page>
c002ca51:	83 c4 10             	add    $0x10,%esp
c002ca54:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (pte != NULL) 
c002ca57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ca5b:	74 48                	je     c002caa5 <pagedir_set_page+0x15f>
    {
      ASSERT ((*pte & PTE_P) == 0);
c002ca5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca60:	8b 00                	mov    (%eax),%eax
c002ca62:	83 e0 01             	and    $0x1,%eax
c002ca65:	85 c0                	test   %eax,%eax
c002ca67:	74 1e                	je     c002ca87 <pagedir_set_page+0x141>
c002ca69:	83 ec 0c             	sub    $0xc,%esp
c002ca6c:	68 61 27 03 c0       	push   $0xc0032761
c002ca71:	68 17 26 03 c0       	push   $0xc0032617
c002ca76:	68 d0 27 03 c0       	push   $0xc00327d0
c002ca7b:	6a 71                	push   $0x71
c002ca7d:	68 b4 26 03 c0       	push   $0xc00326b4
c002ca82:	e8 e7 cc ff ff       	call   c002976e <debug_panic>
      *pte = pte_create_user (kpage, writable);
c002ca87:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ca8b:	83 ec 08             	sub    $0x8,%esp
c002ca8e:	50                   	push   %eax
c002ca8f:	ff 75 10             	pushl  0x10(%ebp)
c002ca92:	e8 48 fc ff ff       	call   c002c6df <pte_create_user>
c002ca97:	83 c4 10             	add    $0x10,%esp
c002ca9a:	89 c2                	mov    %eax,%edx
c002ca9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ca9f:	89 10                	mov    %edx,(%eax)
      return true;
c002caa1:	b0 01                	mov    $0x1,%al
c002caa3:	eb 02                	jmp    c002caa7 <pagedir_set_page+0x161>
    }
  else
    return false;
c002caa5:	b0 00                	mov    $0x0,%al
}
c002caa7:	c9                   	leave  
c002caa8:	c3                   	ret    

c002caa9 <pagedir_get_page>:
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page (uint32_t *pd, const void *uaddr) 
{
c002caa9:	55                   	push   %ebp
c002caaa:	89 e5                	mov    %esp,%ebp
c002caac:	53                   	push   %ebx
c002caad:	83 ec 14             	sub    $0x14,%esp
  uint32_t *pte;

  ASSERT (is_user_vaddr (uaddr));
c002cab0:	ff 75 0c             	pushl  0xc(%ebp)
c002cab3:	e8 8d fa ff ff       	call   c002c545 <is_user_vaddr>
c002cab8:	83 c4 04             	add    $0x4,%esp
c002cabb:	84 c0                	test   %al,%al
c002cabd:	75 21                	jne    c002cae0 <pagedir_get_page+0x37>
c002cabf:	83 ec 0c             	sub    $0xc,%esp
c002cac2:	68 75 27 03 c0       	push   $0xc0032775
c002cac7:	68 17 26 03 c0       	push   $0xc0032617
c002cacc:	68 f8 27 03 c0       	push   $0xc00327f8
c002cad1:	68 82 00 00 00       	push   $0x82
c002cad6:	68 b4 26 03 c0       	push   $0xc00326b4
c002cadb:	e8 8e cc ff ff       	call   c002976e <debug_panic>
  
  pte = lookup_page (pd, uaddr, false);
c002cae0:	83 ec 04             	sub    $0x4,%esp
c002cae3:	6a 00                	push   $0x0
c002cae5:	ff 75 0c             	pushl  0xc(%ebp)
c002cae8:	ff 75 08             	pushl  0x8(%ebp)
c002caeb:	e8 55 fd ff ff       	call   c002c845 <lookup_page>
c002caf0:	83 c4 10             	add    $0x10,%esp
c002caf3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL && (*pte & PTE_P) != 0)
c002caf6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cafa:	74 31                	je     c002cb2d <pagedir_get_page+0x84>
c002cafc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002caff:	8b 00                	mov    (%eax),%eax
c002cb01:	83 e0 01             	and    $0x1,%eax
c002cb04:	85 c0                	test   %eax,%eax
c002cb06:	74 25                	je     c002cb2d <pagedir_get_page+0x84>
    return pte_get_page (*pte) + pg_ofs (uaddr);
c002cb08:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb0b:	8b 00                	mov    (%eax),%eax
c002cb0d:	83 ec 0c             	sub    $0xc,%esp
c002cb10:	50                   	push   %eax
c002cb11:	e8 ed fb ff ff       	call   c002c703 <pte_get_page>
c002cb16:	83 c4 10             	add    $0x10,%esp
c002cb19:	89 c3                	mov    %eax,%ebx
c002cb1b:	83 ec 0c             	sub    $0xc,%esp
c002cb1e:	ff 75 0c             	pushl  0xc(%ebp)
c002cb21:	e8 12 fa ff ff       	call   c002c538 <pg_ofs>
c002cb26:	83 c4 10             	add    $0x10,%esp
c002cb29:	01 d8                	add    %ebx,%eax
c002cb2b:	eb 05                	jmp    c002cb32 <pagedir_get_page+0x89>
  else
    return NULL;
c002cb2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002cb32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002cb35:	c9                   	leave  
c002cb36:	c3                   	ret    

c002cb37 <pagedir_clear_page>:
   directory PD.  Later accesses to the page will fault.  Other
   bits in the page table entry are preserved.
   UPAGE need not be mapped. */
void
pagedir_clear_page (uint32_t *pd, void *upage) 
{
c002cb37:	55                   	push   %ebp
c002cb38:	89 e5                	mov    %esp,%ebp
c002cb3a:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pte;

  ASSERT (pg_ofs (upage) == 0);
c002cb3d:	ff 75 0c             	pushl  0xc(%ebp)
c002cb40:	e8 f3 f9 ff ff       	call   c002c538 <pg_ofs>
c002cb45:	83 c4 04             	add    $0x4,%esp
c002cb48:	85 c0                	test   %eax,%eax
c002cb4a:	74 21                	je     c002cb6d <pagedir_clear_page+0x36>
c002cb4c:	83 ec 0c             	sub    $0xc,%esp
c002cb4f:	68 f9 26 03 c0       	push   $0xc00326f9
c002cb54:	68 17 26 03 c0       	push   $0xc0032617
c002cb59:	68 0c 28 03 c0       	push   $0xc003280c
c002cb5e:	68 94 00 00 00       	push   $0x94
c002cb63:	68 b4 26 03 c0       	push   $0xc00326b4
c002cb68:	e8 01 cc ff ff       	call   c002976e <debug_panic>
  ASSERT (is_user_vaddr (upage));
c002cb6d:	83 ec 0c             	sub    $0xc,%esp
c002cb70:	ff 75 0c             	pushl  0xc(%ebp)
c002cb73:	e8 cd f9 ff ff       	call   c002c545 <is_user_vaddr>
c002cb78:	83 c4 10             	add    $0x10,%esp
c002cb7b:	84 c0                	test   %al,%al
c002cb7d:	75 21                	jne    c002cba0 <pagedir_clear_page+0x69>
c002cb7f:	83 ec 0c             	sub    $0xc,%esp
c002cb82:	68 21 27 03 c0       	push   $0xc0032721
c002cb87:	68 17 26 03 c0       	push   $0xc0032617
c002cb8c:	68 0c 28 03 c0       	push   $0xc003280c
c002cb91:	68 95 00 00 00       	push   $0x95
c002cb96:	68 b4 26 03 c0       	push   $0xc00326b4
c002cb9b:	e8 ce cb ff ff       	call   c002976e <debug_panic>

  pte = lookup_page (pd, upage, false);
c002cba0:	83 ec 04             	sub    $0x4,%esp
c002cba3:	6a 00                	push   $0x0
c002cba5:	ff 75 0c             	pushl  0xc(%ebp)
c002cba8:	ff 75 08             	pushl  0x8(%ebp)
c002cbab:	e8 95 fc ff ff       	call   c002c845 <lookup_page>
c002cbb0:	83 c4 10             	add    $0x10,%esp
c002cbb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL && (*pte & PTE_P) != 0)
c002cbb6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cbba:	74 29                	je     c002cbe5 <pagedir_clear_page+0xae>
c002cbbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbbf:	8b 00                	mov    (%eax),%eax
c002cbc1:	83 e0 01             	and    $0x1,%eax
c002cbc4:	85 c0                	test   %eax,%eax
c002cbc6:	74 1d                	je     c002cbe5 <pagedir_clear_page+0xae>
    {
      *pte &= ~PTE_P;
c002cbc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbcb:	8b 00                	mov    (%eax),%eax
c002cbcd:	83 e0 fe             	and    $0xfffffffe,%eax
c002cbd0:	89 c2                	mov    %eax,%edx
c002cbd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbd5:	89 10                	mov    %edx,(%eax)
      invalidate_pagedir (pd);
c002cbd7:	83 ec 0c             	sub    $0xc,%esp
c002cbda:	ff 75 08             	pushl  0x8(%ebp)
c002cbdd:	e8 86 01 00 00       	call   c002cd68 <invalidate_pagedir>
c002cbe2:	83 c4 10             	add    $0x10,%esp
    }
}
c002cbe5:	90                   	nop
c002cbe6:	c9                   	leave  
c002cbe7:	c3                   	ret    

c002cbe8 <pagedir_is_dirty>:
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool
pagedir_is_dirty (uint32_t *pd, const void *vpage) 
{
c002cbe8:	55                   	push   %ebp
c002cbe9:	89 e5                	mov    %esp,%ebp
c002cbeb:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002cbee:	83 ec 04             	sub    $0x4,%esp
c002cbf1:	6a 00                	push   $0x0
c002cbf3:	ff 75 0c             	pushl  0xc(%ebp)
c002cbf6:	ff 75 08             	pushl  0x8(%ebp)
c002cbf9:	e8 47 fc ff ff       	call   c002c845 <lookup_page>
c002cbfe:	83 c4 10             	add    $0x10,%esp
c002cc01:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return pte != NULL && (*pte & PTE_D) != 0;
c002cc04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cc08:	74 13                	je     c002cc1d <pagedir_is_dirty+0x35>
c002cc0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc0d:	8b 00                	mov    (%eax),%eax
c002cc0f:	83 e0 40             	and    $0x40,%eax
c002cc12:	85 c0                	test   %eax,%eax
c002cc14:	74 07                	je     c002cc1d <pagedir_is_dirty+0x35>
c002cc16:	b8 01 00 00 00       	mov    $0x1,%eax
c002cc1b:	eb 05                	jmp    c002cc22 <pagedir_is_dirty+0x3a>
c002cc1d:	b8 00 00 00 00       	mov    $0x0,%eax
c002cc22:	83 e0 01             	and    $0x1,%eax
}
c002cc25:	c9                   	leave  
c002cc26:	c3                   	ret    

c002cc27 <pagedir_set_dirty>:

/* Set the dirty bit to DIRTY in the PTE for virtual page VPAGE
   in PD. */
void
pagedir_set_dirty (uint32_t *pd, const void *vpage, bool dirty) 
{
c002cc27:	55                   	push   %ebp
c002cc28:	89 e5                	mov    %esp,%ebp
c002cc2a:	83 ec 28             	sub    $0x28,%esp
c002cc2d:	8b 45 10             	mov    0x10(%ebp),%eax
c002cc30:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pte = lookup_page (pd, vpage, false);
c002cc33:	83 ec 04             	sub    $0x4,%esp
c002cc36:	6a 00                	push   $0x0
c002cc38:	ff 75 0c             	pushl  0xc(%ebp)
c002cc3b:	ff 75 08             	pushl  0x8(%ebp)
c002cc3e:	e8 02 fc ff ff       	call   c002c845 <lookup_page>
c002cc43:	83 c4 10             	add    $0x10,%esp
c002cc46:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL) 
c002cc49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cc4d:	74 34                	je     c002cc83 <pagedir_set_dirty+0x5c>
    {
      if (dirty)
c002cc4f:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c002cc53:	74 11                	je     c002cc66 <pagedir_set_dirty+0x3f>
        *pte |= PTE_D;
c002cc55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc58:	8b 00                	mov    (%eax),%eax
c002cc5a:	83 c8 40             	or     $0x40,%eax
c002cc5d:	89 c2                	mov    %eax,%edx
c002cc5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc62:	89 10                	mov    %edx,(%eax)
        {
          *pte &= ~(uint32_t) PTE_D;
          invalidate_pagedir (pd);
        }
    }
}
c002cc64:	eb 1d                	jmp    c002cc83 <pagedir_set_dirty+0x5c>
          *pte &= ~(uint32_t) PTE_D;
c002cc66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc69:	8b 00                	mov    (%eax),%eax
c002cc6b:	83 e0 bf             	and    $0xffffffbf,%eax
c002cc6e:	89 c2                	mov    %eax,%edx
c002cc70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc73:	89 10                	mov    %edx,(%eax)
          invalidate_pagedir (pd);
c002cc75:	83 ec 0c             	sub    $0xc,%esp
c002cc78:	ff 75 08             	pushl  0x8(%ebp)
c002cc7b:	e8 e8 00 00 00       	call   c002cd68 <invalidate_pagedir>
c002cc80:	83 c4 10             	add    $0x10,%esp
}
c002cc83:	90                   	nop
c002cc84:	c9                   	leave  
c002cc85:	c3                   	ret    

c002cc86 <pagedir_is_accessed>:
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool
pagedir_is_accessed (uint32_t *pd, const void *vpage) 
{
c002cc86:	55                   	push   %ebp
c002cc87:	89 e5                	mov    %esp,%ebp
c002cc89:	83 ec 18             	sub    $0x18,%esp
  uint32_t *pte = lookup_page (pd, vpage, false);
c002cc8c:	83 ec 04             	sub    $0x4,%esp
c002cc8f:	6a 00                	push   $0x0
c002cc91:	ff 75 0c             	pushl  0xc(%ebp)
c002cc94:	ff 75 08             	pushl  0x8(%ebp)
c002cc97:	e8 a9 fb ff ff       	call   c002c845 <lookup_page>
c002cc9c:	83 c4 10             	add    $0x10,%esp
c002cc9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return pte != NULL && (*pte & PTE_A) != 0;
c002cca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cca6:	74 13                	je     c002ccbb <pagedir_is_accessed+0x35>
c002cca8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ccab:	8b 00                	mov    (%eax),%eax
c002ccad:	83 e0 20             	and    $0x20,%eax
c002ccb0:	85 c0                	test   %eax,%eax
c002ccb2:	74 07                	je     c002ccbb <pagedir_is_accessed+0x35>
c002ccb4:	b8 01 00 00 00       	mov    $0x1,%eax
c002ccb9:	eb 05                	jmp    c002ccc0 <pagedir_is_accessed+0x3a>
c002ccbb:	b8 00 00 00 00       	mov    $0x0,%eax
c002ccc0:	83 e0 01             	and    $0x1,%eax
}
c002ccc3:	c9                   	leave  
c002ccc4:	c3                   	ret    

c002ccc5 <pagedir_set_accessed>:

/* Sets the accessed bit to ACCESSED in the PTE for virtual page
   VPAGE in PD. */
void
pagedir_set_accessed (uint32_t *pd, const void *vpage, bool accessed) 
{
c002ccc5:	55                   	push   %ebp
c002ccc6:	89 e5                	mov    %esp,%ebp
c002ccc8:	83 ec 28             	sub    $0x28,%esp
c002cccb:	8b 45 10             	mov    0x10(%ebp),%eax
c002ccce:	88 45 e4             	mov    %al,-0x1c(%ebp)
  uint32_t *pte = lookup_page (pd, vpage, false);
c002ccd1:	83 ec 04             	sub    $0x4,%esp
c002ccd4:	6a 00                	push   $0x0
c002ccd6:	ff 75 0c             	pushl  0xc(%ebp)
c002ccd9:	ff 75 08             	pushl  0x8(%ebp)
c002ccdc:	e8 64 fb ff ff       	call   c002c845 <lookup_page>
c002cce1:	83 c4 10             	add    $0x10,%esp
c002cce4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (pte != NULL) 
c002cce7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002cceb:	74 34                	je     c002cd21 <pagedir_set_accessed+0x5c>
    {
      if (accessed)
c002cced:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c002ccf1:	74 11                	je     c002cd04 <pagedir_set_accessed+0x3f>
        *pte |= PTE_A;
c002ccf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ccf6:	8b 00                	mov    (%eax),%eax
c002ccf8:	83 c8 20             	or     $0x20,%eax
c002ccfb:	89 c2                	mov    %eax,%edx
c002ccfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd00:	89 10                	mov    %edx,(%eax)
        {
          *pte &= ~(uint32_t) PTE_A; 
          invalidate_pagedir (pd);
        }
    }
}
c002cd02:	eb 1d                	jmp    c002cd21 <pagedir_set_accessed+0x5c>
          *pte &= ~(uint32_t) PTE_A; 
c002cd04:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd07:	8b 00                	mov    (%eax),%eax
c002cd09:	83 e0 df             	and    $0xffffffdf,%eax
c002cd0c:	89 c2                	mov    %eax,%edx
c002cd0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cd11:	89 10                	mov    %edx,(%eax)
          invalidate_pagedir (pd);
c002cd13:	83 ec 0c             	sub    $0xc,%esp
c002cd16:	ff 75 08             	pushl  0x8(%ebp)
c002cd19:	e8 4a 00 00 00       	call   c002cd68 <invalidate_pagedir>
c002cd1e:	83 c4 10             	add    $0x10,%esp
}
c002cd21:	90                   	nop
c002cd22:	c9                   	leave  
c002cd23:	c3                   	ret    

c002cd24 <pagedir_activate>:

/* Loads page directory PD into the CPU's page directory base
   register. */
void
pagedir_activate (uint32_t *pd) 
{
c002cd24:	55                   	push   %ebp
c002cd25:	89 e5                	mov    %esp,%ebp
c002cd27:	83 ec 08             	sub    $0x8,%esp
  if (pd == NULL)
c002cd2a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002cd2e:	75 08                	jne    c002cd38 <pagedir_activate+0x14>
    pd = init_page_dir;
c002cd30:	a1 48 a6 03 c0       	mov    0xc003a648,%eax
c002cd35:	89 45 08             	mov    %eax,0x8(%ebp)
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
     Address of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (pd)) : "memory");
c002cd38:	83 ec 0c             	sub    $0xc,%esp
c002cd3b:	ff 75 08             	pushl  0x8(%ebp)
c002cd3e:	e8 58 f8 ff ff       	call   c002c59b <vtop>
c002cd43:	83 c4 10             	add    $0x10,%esp
c002cd46:	0f 22 d8             	mov    %eax,%cr3
}
c002cd49:	90                   	nop
c002cd4a:	c9                   	leave  
c002cd4b:	c3                   	ret    

c002cd4c <active_pd>:

/* Returns the currently active page directory. */
static uint32_t *
active_pd (void) 
{
c002cd4c:	55                   	push   %ebp
c002cd4d:	89 e5                	mov    %esp,%ebp
c002cd4f:	83 ec 18             	sub    $0x18,%esp
  /* Copy CR3, the page directory base register (PDBR), into
     `pd'.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 3.7.5 "Base Address of the Page Directory". */
  uintptr_t pd;
  asm volatile ("movl %%cr3, %0" : "=r" (pd));
c002cd52:	0f 20 d8             	mov    %cr3,%eax
c002cd55:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return ptov (pd);
c002cd58:	83 ec 0c             	sub    $0xc,%esp
c002cd5b:	ff 75 f4             	pushl  -0xc(%ebp)
c002cd5e:	e8 00 f8 ff ff       	call   c002c563 <ptov>
c002cd63:	83 c4 10             	add    $0x10,%esp
}
c002cd66:	c9                   	leave  
c002cd67:	c3                   	ret    

c002cd68 <invalidate_pagedir>:
   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir (uint32_t *pd) 
{
c002cd68:	55                   	push   %ebp
c002cd69:	89 e5                	mov    %esp,%ebp
c002cd6b:	83 ec 08             	sub    $0x8,%esp
  if (active_pd () == pd) 
c002cd6e:	e8 d9 ff ff ff       	call   c002cd4c <active_pd>
c002cd73:	3b 45 08             	cmp    0x8(%ebp),%eax
c002cd76:	75 0e                	jne    c002cd86 <invalidate_pagedir+0x1e>
    {
      /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
         "Translation Lookaside Buffers (TLBs)". */
      pagedir_activate (pd);
c002cd78:	83 ec 0c             	sub    $0xc,%esp
c002cd7b:	ff 75 08             	pushl  0x8(%ebp)
c002cd7e:	e8 a1 ff ff ff       	call   c002cd24 <pagedir_activate>
c002cd83:	83 c4 10             	add    $0x10,%esp
    } 
}
c002cd86:	90                   	nop
c002cd87:	c9                   	leave  
c002cd88:	c3                   	ret    

c002cd89 <exception_init>:

   Refer to [IA32-v3a] section 5.15 "Exception and Interrupt
   Reference" for a description of each of these exceptions. */
void
exception_init (void) 
{
c002cd89:	55                   	push   %ebp
c002cd8a:	89 e5                	mov    %esp,%ebp
c002cd8c:	83 ec 08             	sub    $0x8,%esp
  /* These exceptions can be raised explicitly by a user program,
     e.g. via the INT, INT3, INTO, and BOUND instructions.  Thus,
     we set DPL==3, meaning that user programs are allowed to
     invoke them via these instructions. */
  intr_register_int (3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002cd8f:	83 ec 0c             	sub    $0xc,%esp
c002cd92:	68 20 28 03 c0       	push   $0xc0032820
c002cd97:	68 17 cf 02 c0       	push   $0xc002cf17
c002cd9c:	6a 01                	push   $0x1
c002cd9e:	6a 03                	push   $0x3
c002cda0:	6a 03                	push   $0x3
c002cda2:	e8 91 4a ff ff       	call   c0021838 <intr_register_int>
c002cda7:	83 c4 20             	add    $0x20,%esp
  intr_register_int (4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002cdaa:	83 ec 0c             	sub    $0xc,%esp
c002cdad:	68 39 28 03 c0       	push   $0xc0032839
c002cdb2:	68 17 cf 02 c0       	push   $0xc002cf17
c002cdb7:	6a 01                	push   $0x1
c002cdb9:	6a 03                	push   $0x3
c002cdbb:	6a 04                	push   $0x4
c002cdbd:	e8 76 4a ff ff       	call   c0021838 <intr_register_int>
c002cdc2:	83 c4 20             	add    $0x20,%esp
  intr_register_int (5, 3, INTR_ON, kill,
c002cdc5:	83 ec 0c             	sub    $0xc,%esp
c002cdc8:	68 50 28 03 c0       	push   $0xc0032850
c002cdcd:	68 17 cf 02 c0       	push   $0xc002cf17
c002cdd2:	6a 01                	push   $0x1
c002cdd4:	6a 03                	push   $0x3
c002cdd6:	6a 05                	push   $0x5
c002cdd8:	e8 5b 4a ff ff       	call   c0021838 <intr_register_int>
c002cddd:	83 c4 20             	add    $0x20,%esp

  /* These exceptions have DPL==0, preventing user processes from
     invoking them via the INT instruction.  They can still be
     caused indirectly, e.g. #DE can be caused by dividing by
     0.  */
  intr_register_int (0, 0, INTR_ON, kill, "#DE Divide Error");
c002cde0:	83 ec 0c             	sub    $0xc,%esp
c002cde3:	68 73 28 03 c0       	push   $0xc0032873
c002cde8:	68 17 cf 02 c0       	push   $0xc002cf17
c002cded:	6a 01                	push   $0x1
c002cdef:	6a 00                	push   $0x0
c002cdf1:	6a 00                	push   $0x0
c002cdf3:	e8 40 4a ff ff       	call   c0021838 <intr_register_int>
c002cdf8:	83 c4 20             	add    $0x20,%esp
  intr_register_int (1, 0, INTR_ON, kill, "#DB Debug Exception");
c002cdfb:	83 ec 0c             	sub    $0xc,%esp
c002cdfe:	68 84 28 03 c0       	push   $0xc0032884
c002ce03:	68 17 cf 02 c0       	push   $0xc002cf17
c002ce08:	6a 01                	push   $0x1
c002ce0a:	6a 00                	push   $0x0
c002ce0c:	6a 01                	push   $0x1
c002ce0e:	e8 25 4a ff ff       	call   c0021838 <intr_register_int>
c002ce13:	83 c4 20             	add    $0x20,%esp
  intr_register_int (6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002ce16:	83 ec 0c             	sub    $0xc,%esp
c002ce19:	68 98 28 03 c0       	push   $0xc0032898
c002ce1e:	68 17 cf 02 c0       	push   $0xc002cf17
c002ce23:	6a 01                	push   $0x1
c002ce25:	6a 00                	push   $0x0
c002ce27:	6a 06                	push   $0x6
c002ce29:	e8 0a 4a ff ff       	call   c0021838 <intr_register_int>
c002ce2e:	83 c4 20             	add    $0x20,%esp
  intr_register_int (7, 0, INTR_ON, kill,
c002ce31:	83 ec 0c             	sub    $0xc,%esp
c002ce34:	68 b8 28 03 c0       	push   $0xc00328b8
c002ce39:	68 17 cf 02 c0       	push   $0xc002cf17
c002ce3e:	6a 01                	push   $0x1
c002ce40:	6a 00                	push   $0x0
c002ce42:	6a 07                	push   $0x7
c002ce44:	e8 ef 49 ff ff       	call   c0021838 <intr_register_int>
c002ce49:	83 c4 20             	add    $0x20,%esp
                     "#NM Device Not Available Exception");
  intr_register_int (11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002ce4c:	83 ec 0c             	sub    $0xc,%esp
c002ce4f:	68 db 28 03 c0       	push   $0xc00328db
c002ce54:	68 17 cf 02 c0       	push   $0xc002cf17
c002ce59:	6a 01                	push   $0x1
c002ce5b:	6a 00                	push   $0x0
c002ce5d:	6a 0b                	push   $0xb
c002ce5f:	e8 d4 49 ff ff       	call   c0021838 <intr_register_int>
c002ce64:	83 c4 20             	add    $0x20,%esp
  intr_register_int (12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002ce67:	83 ec 0c             	sub    $0xc,%esp
c002ce6a:	68 f3 28 03 c0       	push   $0xc00328f3
c002ce6f:	68 17 cf 02 c0       	push   $0xc002cf17
c002ce74:	6a 01                	push   $0x1
c002ce76:	6a 00                	push   $0x0
c002ce78:	6a 0c                	push   $0xc
c002ce7a:	e8 b9 49 ff ff       	call   c0021838 <intr_register_int>
c002ce7f:	83 c4 20             	add    $0x20,%esp
  intr_register_int (13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002ce82:	83 ec 0c             	sub    $0xc,%esp
c002ce85:	68 10 29 03 c0       	push   $0xc0032910
c002ce8a:	68 17 cf 02 c0       	push   $0xc002cf17
c002ce8f:	6a 01                	push   $0x1
c002ce91:	6a 00                	push   $0x0
c002ce93:	6a 0d                	push   $0xd
c002ce95:	e8 9e 49 ff ff       	call   c0021838 <intr_register_int>
c002ce9a:	83 c4 20             	add    $0x20,%esp
  intr_register_int (16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002ce9d:	83 ec 0c             	sub    $0xc,%esp
c002cea0:	68 34 29 03 c0       	push   $0xc0032934
c002cea5:	68 17 cf 02 c0       	push   $0xc002cf17
c002ceaa:	6a 01                	push   $0x1
c002ceac:	6a 00                	push   $0x0
c002ceae:	6a 10                	push   $0x10
c002ceb0:	e8 83 49 ff ff       	call   c0021838 <intr_register_int>
c002ceb5:	83 c4 20             	add    $0x20,%esp
  intr_register_int (19, 0, INTR_ON, kill,
c002ceb8:	83 ec 0c             	sub    $0xc,%esp
c002cebb:	68 58 29 03 c0       	push   $0xc0032958
c002cec0:	68 17 cf 02 c0       	push   $0xc002cf17
c002cec5:	6a 01                	push   $0x1
c002cec7:	6a 00                	push   $0x0
c002cec9:	6a 13                	push   $0x13
c002cecb:	e8 68 49 ff ff       	call   c0021838 <intr_register_int>
c002ced0:	83 c4 20             	add    $0x20,%esp
                     "#XF SIMD Floating-Point Exception");

  /* Most exceptions can be handled with interrupts turned on.
     We need to disable interrupts for page faults because the
     fault address is stored in CR2 and needs to be preserved. */
  intr_register_int (14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002ced3:	83 ec 0c             	sub    $0xc,%esp
c002ced6:	68 7a 29 03 c0       	push   $0xc003297a
c002cedb:	68 d8 cf 02 c0       	push   $0xc002cfd8
c002cee0:	6a 00                	push   $0x0
c002cee2:	6a 00                	push   $0x0
c002cee4:	6a 0e                	push   $0xe
c002cee6:	e8 4d 49 ff ff       	call   c0021838 <intr_register_int>
c002ceeb:	83 c4 20             	add    $0x20,%esp
}
c002ceee:	90                   	nop
c002ceef:	c9                   	leave  
c002cef0:	c3                   	ret    

c002cef1 <exception_print_stats>:

/* Prints exception statistics. */
void
exception_print_stats (void) 
{
c002cef1:	55                   	push   %ebp
c002cef2:	89 e5                	mov    %esp,%ebp
c002cef4:	83 ec 08             	sub    $0x8,%esp
  printf ("Exception: %lld page faults\n", page_fault_cnt);
c002cef7:	a1 d0 a3 03 c0       	mov    0xc003a3d0,%eax
c002cefc:	8b 15 d4 a3 03 c0    	mov    0xc003a3d4,%edx
c002cf02:	83 ec 04             	sub    $0x4,%esp
c002cf05:	52                   	push   %edx
c002cf06:	50                   	push   %eax
c002cf07:	68 93 29 03 c0       	push   $0xc0032993
c002cf0c:	e8 9e a4 ff ff       	call   c00273af <printf>
c002cf11:	83 c4 10             	add    $0x10,%esp
}
c002cf14:	90                   	nop
c002cf15:	c9                   	leave  
c002cf16:	c3                   	ret    

c002cf17 <kill>:

/* Handler for an exception (probably) caused by a user process. */
static void
kill (struct intr_frame *f) 
{
c002cf17:	55                   	push   %ebp
c002cf18:	89 e5                	mov    %esp,%ebp
c002cf1a:	56                   	push   %esi
c002cf1b:	53                   	push   %ebx
     exceptions back to the process via signals, but we don't
     implement them. */
     
  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
c002cf1c:	8b 45 08             	mov    0x8(%ebp),%eax
c002cf1f:	8b 40 40             	mov    0x40(%eax),%eax
c002cf22:	0f b7 c0             	movzwl %ax,%eax
c002cf25:	83 f8 08             	cmp    $0x8,%eax
c002cf28:	74 4f                	je     c002cf79 <kill+0x62>
c002cf2a:	83 f8 1b             	cmp    $0x1b,%eax
c002cf2d:	75 6e                	jne    c002cf9d <kill+0x86>
    {
    case SEL_UCSEG:
      /* User's code segment, so it's a user exception, as we
         expected.  Kill the user process.  */
      printf ("%s: dying due to interrupt %#04x (%s).\n",
              thread_name (), f->vec_no, intr_name (f->vec_no));
c002cf2f:	8b 45 08             	mov    0x8(%ebp),%eax
c002cf32:	8b 40 30             	mov    0x30(%eax),%eax
      printf ("%s: dying due to interrupt %#04x (%s).\n",
c002cf35:	0f b6 c0             	movzbl %al,%eax
c002cf38:	83 ec 0c             	sub    $0xc,%esp
c002cf3b:	50                   	push   %eax
c002cf3c:	e8 b4 4e ff ff       	call   c0021df5 <intr_name>
c002cf41:	83 c4 10             	add    $0x10,%esp
c002cf44:	89 c6                	mov    %eax,%esi
c002cf46:	8b 45 08             	mov    0x8(%ebp),%eax
c002cf49:	8b 58 30             	mov    0x30(%eax),%ebx
c002cf4c:	e8 ff 3e ff ff       	call   c0020e50 <thread_name>
c002cf51:	56                   	push   %esi
c002cf52:	53                   	push   %ebx
c002cf53:	50                   	push   %eax
c002cf54:	68 b0 29 03 c0       	push   $0xc00329b0
c002cf59:	e8 51 a4 ff ff       	call   c00273af <printf>
c002cf5e:	83 c4 10             	add    $0x10,%esp
      intr_dump_frame (f);
c002cf61:	83 ec 0c             	sub    $0xc,%esp
c002cf64:	ff 75 08             	pushl  0x8(%ebp)
c002cf67:	e8 a2 4d ff ff       	call   c0021d0e <intr_dump_frame>
c002cf6c:	83 c4 10             	add    $0x10,%esp

      // thread_current()->parent->ex = true;
		// thread_current()->exit_error = -1;
      // thread_exit (); 
      exit(-1);
c002cf6f:	83 ec 0c             	sub    $0xc,%esp
c002cf72:	6a ff                	push   $0xffffffff
c002cf74:	e8 4a 05 00 00       	call   c002d4c3 <exit>
    case SEL_KCSEG:
      /* Kernel's code segment, which indicates a kernel bug.
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.)  Panic the kernel to make the point.  */
      intr_dump_frame (f);
c002cf79:	83 ec 0c             	sub    $0xc,%esp
c002cf7c:	ff 75 08             	pushl  0x8(%ebp)
c002cf7f:	e8 8a 4d ff ff       	call   c0021d0e <intr_dump_frame>
c002cf84:	83 c4 10             	add    $0x10,%esp
      PANIC ("Kernel bug - unexpected interrupt in kernel"); 
c002cf87:	68 d8 29 03 c0       	push   $0xc00329d8
c002cf8c:	68 bc 2a 03 c0       	push   $0xc0032abc
c002cf91:	6a 68                	push   $0x68
c002cf93:	68 04 2a 03 c0       	push   $0xc0032a04
c002cf98:	e8 d1 c7 ff ff       	call   c002976e <debug_panic>

    default:
      /* Some other code segment?  Shouldn't happen.  Panic the
         kernel. */
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
             f->vec_no, intr_name (f->vec_no), f->cs);
c002cf9d:	8b 45 08             	mov    0x8(%ebp),%eax
c002cfa0:	8b 40 40             	mov    0x40(%eax),%eax
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002cfa3:	0f b7 d8             	movzwl %ax,%ebx
             f->vec_no, intr_name (f->vec_no), f->cs);
c002cfa6:	8b 45 08             	mov    0x8(%ebp),%eax
c002cfa9:	8b 40 30             	mov    0x30(%eax),%eax
      printf ("Interrupt %#04x (%s) in unknown segment %04x\n",
c002cfac:	0f b6 c0             	movzbl %al,%eax
c002cfaf:	83 ec 0c             	sub    $0xc,%esp
c002cfb2:	50                   	push   %eax
c002cfb3:	e8 3d 4e ff ff       	call   c0021df5 <intr_name>
c002cfb8:	83 c4 10             	add    $0x10,%esp
c002cfbb:	89 c2                	mov    %eax,%edx
c002cfbd:	8b 45 08             	mov    0x8(%ebp),%eax
c002cfc0:	8b 40 30             	mov    0x30(%eax),%eax
c002cfc3:	53                   	push   %ebx
c002cfc4:	52                   	push   %edx
c002cfc5:	50                   	push   %eax
c002cfc6:	68 20 2a 03 c0       	push   $0xc0032a20
c002cfcb:	e8 df a3 ff ff       	call   c00273af <printf>
c002cfd0:	83 c4 10             	add    $0x10,%esp
      thread_exit ();
c002cfd3:	e8 08 3f ff ff       	call   c0020ee0 <thread_exit>

c002cfd8 <page_fault>:
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault (struct intr_frame *f) 
{
c002cfd8:	55                   	push   %ebp
c002cfd9:	89 e5                	mov    %esp,%ebp
c002cfdb:	83 ec 18             	sub    $0x18,%esp
     data.  It is not necessarily the address of the instruction
     that caused the fault (that's f->eip).
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (fault_addr));
c002cfde:	0f 20 d0             	mov    %cr2,%eax
c002cfe1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Turn interrupts back on (they were only off so that we could
     be assured of reading CR2 before it changed). */
  intr_enable ();
c002cfe4:	e8 9c 45 ff ff       	call   c0021585 <intr_enable>

  /* Count page faults. */
  page_fault_cnt++;
c002cfe9:	a1 d0 a3 03 c0       	mov    0xc003a3d0,%eax
c002cfee:	8b 15 d4 a3 03 c0    	mov    0xc003a3d4,%edx
c002cff4:	83 c0 01             	add    $0x1,%eax
c002cff7:	83 d2 00             	adc    $0x0,%edx
c002cffa:	a3 d0 a3 03 c0       	mov    %eax,0xc003a3d0
c002cfff:	89 15 d4 a3 03 c0    	mov    %edx,0xc003a3d4

  /* Determine cause. */
  not_present = (f->error_code & PF_P) == 0;
c002d005:	8b 45 08             	mov    0x8(%ebp),%eax
c002d008:	8b 40 34             	mov    0x34(%eax),%eax
c002d00b:	83 e0 01             	and    $0x1,%eax
c002d00e:	85 c0                	test   %eax,%eax
c002d010:	0f 94 c0             	sete   %al
c002d013:	88 45 f3             	mov    %al,-0xd(%ebp)
  write = (f->error_code & PF_W) != 0;
c002d016:	8b 45 08             	mov    0x8(%ebp),%eax
c002d019:	8b 40 34             	mov    0x34(%eax),%eax
c002d01c:	83 e0 02             	and    $0x2,%eax
c002d01f:	85 c0                	test   %eax,%eax
c002d021:	0f 95 c0             	setne  %al
c002d024:	88 45 f2             	mov    %al,-0xe(%ebp)
  user = (f->error_code & PF_U) != 0;
c002d027:	8b 45 08             	mov    0x8(%ebp),%eax
c002d02a:	8b 40 34             	mov    0x34(%eax),%eax
c002d02d:	83 e0 04             	and    $0x4,%eax
c002d030:	85 c0                	test   %eax,%eax
c002d032:	0f 95 c0             	setne  %al
c002d035:	88 45 f1             	mov    %al,-0xf(%ebp)

  /* To implement virtual memory, delete the rest of the function
     body, and replace it with code that brings in the page to
     which fault_addr refers. */
  printf ("Page fault at %p: %s error %s page in %s context.\n",
c002d038:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c002d03c:	74 07                	je     c002d045 <page_fault+0x6d>
c002d03e:	b9 4e 2a 03 c0       	mov    $0xc0032a4e,%ecx
c002d043:	eb 05                	jmp    c002d04a <page_fault+0x72>
c002d045:	b9 53 2a 03 c0       	mov    $0xc0032a53,%ecx
c002d04a:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c002d04e:	74 07                	je     c002d057 <page_fault+0x7f>
c002d050:	ba 5a 2a 03 c0       	mov    $0xc0032a5a,%edx
c002d055:	eb 05                	jmp    c002d05c <page_fault+0x84>
c002d057:	ba 62 2a 03 c0       	mov    $0xc0032a62,%edx
c002d05c:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c002d060:	74 07                	je     c002d069 <page_fault+0x91>
c002d062:	b8 6a 2a 03 c0       	mov    $0xc0032a6a,%eax
c002d067:	eb 05                	jmp    c002d06e <page_fault+0x96>
c002d069:	b8 76 2a 03 c0       	mov    $0xc0032a76,%eax
c002d06e:	83 ec 0c             	sub    $0xc,%esp
c002d071:	51                   	push   %ecx
c002d072:	52                   	push   %edx
c002d073:	50                   	push   %eax
c002d074:	ff 75 f4             	pushl  -0xc(%ebp)
c002d077:	68 88 2a 03 c0       	push   $0xc0032a88
c002d07c:	e8 2e a3 ff ff       	call   c00273af <printf>
c002d081:	83 c4 20             	add    $0x20,%esp
          fault_addr,
          not_present ? "not present" : "rights violation",
          write ? "writing" : "reading",
          user ? "user" : "kernel");
  kill (f);
c002d084:	83 ec 0c             	sub    $0xc,%esp
c002d087:	ff 75 08             	pushl  0x8(%ebp)
c002d08a:	e8 88 fe ff ff       	call   c002cf17 <kill>
c002d08f:	83 c4 10             	add    $0x10,%esp
}
c002d092:	90                   	nop
c002d093:	c9                   	leave  
c002d094:	c3                   	ret    

c002d095 <is_user_vaddr>:
{
c002d095:	55                   	push   %ebp
c002d096:	89 e5                	mov    %esp,%ebp
  return vaddr < PHYS_BASE;
c002d098:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c002d09f:	0f 96 c0             	setbe  %al
}
c002d0a2:	5d                   	pop    %ebp
c002d0a3:	c3                   	ret    

c002d0a4 <syscall_init>:
	struct list_elem elem;
};


syscall_init (void) 
{
c002d0a4:	55                   	push   %ebp
c002d0a5:	89 e5                	mov    %esp,%ebp
c002d0a7:	83 ec 08             	sub    $0x8,%esp
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
c002d0aa:	83 ec 0c             	sub    $0xc,%esp
c002d0ad:	68 c4 2a 03 c0       	push   $0xc0032ac4
c002d0b2:	68 c8 d0 02 c0       	push   $0xc002d0c8
c002d0b7:	6a 01                	push   $0x1
c002d0b9:	6a 03                	push   $0x3
c002d0bb:	6a 30                	push   $0x30
c002d0bd:	e8 76 47 ff ff       	call   c0021838 <intr_register_int>
c002d0c2:	83 c4 20             	add    $0x20,%esp
}
c002d0c5:	90                   	nop
c002d0c6:	c9                   	leave  
c002d0c7:	c3                   	ret    

c002d0c8 <syscall_handler>:

static void
syscall_handler (struct intr_frame *f UNUSED) 
{
c002d0c8:	55                   	push   %ebp
c002d0c9:	89 e5                	mov    %esp,%ebp
c002d0cb:	53                   	push   %ebx
c002d0cc:	83 ec 24             	sub    $0x24,%esp
  

	uint32_t *esp;
    esp = f->esp;
c002d0cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002d0d2:	8b 40 48             	mov    0x48(%eax),%eax
c002d0d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	check_addr(esp);
c002d0d8:	83 ec 0c             	sub    $0xc,%esp
c002d0db:	ff 75 f4             	pushl  -0xc(%ebp)
c002d0de:	e8 02 04 00 00       	call   c002d4e5 <check_addr>
c002d0e3:	83 c4 10             	add    $0x10,%esp

	int fd = *((int*)f->esp + 1);
c002d0e6:	8b 45 08             	mov    0x8(%ebp),%eax
c002d0e9:	8b 40 48             	mov    0x48(%eax),%eax
c002d0ec:	8b 40 04             	mov    0x4(%eax),%eax
c002d0ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void* buffer = (void*)(*((int*)f->esp + 2));
c002d0f2:	8b 45 08             	mov    0x8(%ebp),%eax
c002d0f5:	8b 40 48             	mov    0x48(%eax),%eax
c002d0f8:	83 c0 08             	add    $0x8,%eax
c002d0fb:	8b 00                	mov    (%eax),%eax
c002d0fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	unsigned size = *((unsigned*)f->esp + 3);
c002d100:	8b 45 08             	mov    0x8(%ebp),%eax
c002d103:	8b 40 48             	mov    0x48(%eax),%eax
c002d106:	8b 40 0c             	mov    0xc(%eax),%eax
c002d109:	89 45 e8             	mov    %eax,-0x18(%ebp)

	switch (*esp)
c002d10c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d10f:	8b 00                	mov    (%eax),%eax
c002d111:	83 f8 0c             	cmp    $0xc,%eax
c002d114:	0f 87 f1 01 00 00    	ja     c002d30b <syscall_handler+0x243>
c002d11a:	8b 04 85 d8 2a 03 c0 	mov    -0x3ffcd528(,%eax,4),%eax
c002d121:	ff e0                	jmp    *%eax
	{
		case SYS_HALT:
		shutdown_power_off();
c002d123:	e8 92 9d ff ff       	call   c0026eba <shutdown_power_off>
		break;

		case SYS_EXEC:
		check_addr(fd);
c002d128:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d12b:	83 ec 0c             	sub    $0xc,%esp
c002d12e:	50                   	push   %eax
c002d12f:	e8 b1 03 00 00       	call   c002d4e5 <check_addr>
c002d134:	83 c4 10             	add    $0x10,%esp
		f->eax =process_execute(fd);
c002d137:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d13a:	83 ec 0c             	sub    $0xc,%esp
c002d13d:	50                   	push   %eax
c002d13e:	e8 6e ea ff ff       	call   c002bbb1 <process_execute>
c002d143:	83 c4 10             	add    $0x10,%esp
c002d146:	89 c2                	mov    %eax,%edx
c002d148:	8b 45 08             	mov    0x8(%ebp),%eax
c002d14b:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d14e:	e9 c8 01 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_CREATE:
		check_addr(fd);
c002d153:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d156:	83 ec 0c             	sub    $0xc,%esp
c002d159:	50                   	push   %eax
c002d15a:	e8 86 03 00 00       	call   c002d4e5 <check_addr>
c002d15f:	83 c4 10             	add    $0x10,%esp
		f->eax = filesys_create(fd,buffer);
c002d162:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002d165:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d168:	83 ec 08             	sub    $0x8,%esp
c002d16b:	52                   	push   %edx
c002d16c:	50                   	push   %eax
c002d16d:	e8 4a 09 00 00       	call   c002dabc <filesys_create>
c002d172:	83 c4 10             	add    $0x10,%esp
c002d175:	0f b6 d0             	movzbl %al,%edx
c002d178:	8b 45 08             	mov    0x8(%ebp),%eax
c002d17b:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d17e:	e9 98 01 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_REMOVE:
		check_addr(fd);
c002d183:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d186:	83 ec 0c             	sub    $0xc,%esp
c002d189:	50                   	push   %eax
c002d18a:	e8 56 03 00 00       	call   c002d4e5 <check_addr>
c002d18f:	83 c4 10             	add    $0x10,%esp
		bool status=filesys_remove(fd);
c002d192:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d195:	83 ec 0c             	sub    $0xc,%esp
c002d198:	50                   	push   %eax
c002d199:	e8 14 0a 00 00       	call   c002dbb2 <filesys_remove>
c002d19e:	83 c4 10             	add    $0x10,%esp
c002d1a1:	88 45 e7             	mov    %al,-0x19(%ebp)
		f->eax = status;
c002d1a4:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c002d1a8:	8b 45 08             	mov    0x8(%ebp),%eax
c002d1ab:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d1ae:	e9 68 01 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_OPEN:
		f->eax=open(fd);
c002d1b3:	83 ec 0c             	sub    $0xc,%esp
c002d1b6:	ff 75 f0             	pushl  -0x10(%ebp)
c002d1b9:	e8 63 01 00 00       	call   c002d321 <open>
c002d1be:	83 c4 10             	add    $0x10,%esp
c002d1c1:	89 c2                	mov    %eax,%edx
c002d1c3:	8b 45 08             	mov    0x8(%ebp),%eax
c002d1c6:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d1c9:	e9 4d 01 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_FILESIZE:
		f->eax = file_length (list_search(&thread_current()->files, fd)->ptr);
c002d1ce:	e8 8d 3c ff ff       	call   c0020e60 <thread_current>
c002d1d3:	83 c0 3c             	add    $0x3c,%eax
c002d1d6:	83 ec 08             	sub    $0x8,%esp
c002d1d9:	ff 75 f0             	pushl  -0x10(%ebp)
c002d1dc:	50                   	push   %eax
c002d1dd:	e8 52 03 00 00       	call   c002d534 <list_search>
c002d1e2:	83 c4 10             	add    $0x10,%esp
c002d1e5:	8b 00                	mov    (%eax),%eax
c002d1e7:	83 ec 0c             	sub    $0xc,%esp
c002d1ea:	50                   	push   %eax
c002d1eb:	e8 42 0f 00 00       	call   c002e132 <file_length>
c002d1f0:	83 c4 10             	add    $0x10,%esp
c002d1f3:	89 c2                	mov    %eax,%edx
c002d1f5:	8b 45 08             	mov    0x8(%ebp),%eax
c002d1f8:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d1fb:	e9 1b 01 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_READ:
		f->eax = read (fd,buffer, size);
c002d200:	83 ec 04             	sub    $0x4,%esp
c002d203:	ff 75 e8             	pushl  -0x18(%ebp)
c002d206:	ff 75 ec             	pushl  -0x14(%ebp)
c002d209:	ff 75 f0             	pushl  -0x10(%ebp)
c002d20c:	e8 f9 03 00 00       	call   c002d60a <read>
c002d211:	83 c4 10             	add    $0x10,%esp
c002d214:	89 c2                	mov    %eax,%edx
c002d216:	8b 45 08             	mov    0x8(%ebp),%eax
c002d219:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d21c:	e9 fa 00 00 00       	jmp    c002d31b <syscall_handler+0x253>
		
		case SYS_WAIT:
		check_addr(fd);
c002d221:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d224:	83 ec 0c             	sub    $0xc,%esp
c002d227:	50                   	push   %eax
c002d228:	e8 b8 02 00 00       	call   c002d4e5 <check_addr>
c002d22d:	83 c4 10             	add    $0x10,%esp
		f->eax = process_wait(fd);
c002d230:	83 ec 0c             	sub    $0xc,%esp
c002d233:	ff 75 f0             	pushl  -0x10(%ebp)
c002d236:	e8 96 ea ff ff       	call   c002bcd1 <process_wait>
c002d23b:	83 c4 10             	add    $0x10,%esp
c002d23e:	89 c2                	mov    %eax,%edx
c002d240:	8b 45 08             	mov    0x8(%ebp),%eax
c002d243:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d246:	e9 d0 00 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_EXIT:
		exit(fd);
c002d24b:	83 ec 0c             	sub    $0xc,%esp
c002d24e:	ff 75 f0             	pushl  -0x10(%ebp)
c002d251:	e8 6d 02 00 00       	call   c002d4c3 <exit>
		break;

		case SYS_WRITE:
		f->eax = write (fd, buffer, size);
c002d256:	83 ec 04             	sub    $0x4,%esp
c002d259:	ff 75 e8             	pushl  -0x18(%ebp)
c002d25c:	ff 75 ec             	pushl  -0x14(%ebp)
c002d25f:	ff 75 f0             	pushl  -0x10(%ebp)
c002d262:	e8 56 01 00 00       	call   c002d3bd <write>
c002d267:	83 c4 10             	add    $0x10,%esp
c002d26a:	89 c2                	mov    %eax,%edx
c002d26c:	8b 45 08             	mov    0x8(%ebp),%eax
c002d26f:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d272:	e9 a4 00 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_CLOSE:
		close_file(&thread_current()->files,fd);
c002d277:	e8 e4 3b ff ff       	call   c0020e60 <thread_current>
c002d27c:	83 c0 3c             	add    $0x3c,%eax
c002d27f:	83 ec 08             	sub    $0x8,%esp
c002d282:	ff 75 f0             	pushl  -0x10(%ebp)
c002d285:	50                   	push   %eax
c002d286:	e8 09 03 00 00       	call   c002d594 <close_file>
c002d28b:	83 c4 10             	add    $0x10,%esp
		break;
c002d28e:	e9 88 00 00 00       	jmp    c002d31b <syscall_handler+0x253>

		case SYS_SEEK:
		check_addr(fd);
c002d293:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d296:	83 ec 0c             	sub    $0xc,%esp
c002d299:	50                   	push   %eax
c002d29a:	e8 46 02 00 00       	call   c002d4e5 <check_addr>
c002d29f:	83 c4 10             	add    $0x10,%esp
		file_seek(list_search(&thread_current()->files, fd)->ptr,buffer);
c002d2a2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d2a5:	e8 b6 3b ff ff       	call   c0020e60 <thread_current>
c002d2aa:	83 c0 3c             	add    $0x3c,%eax
c002d2ad:	83 ec 08             	sub    $0x8,%esp
c002d2b0:	ff 75 f0             	pushl  -0x10(%ebp)
c002d2b3:	50                   	push   %eax
c002d2b4:	e8 7b 02 00 00       	call   c002d534 <list_search>
c002d2b9:	83 c4 10             	add    $0x10,%esp
c002d2bc:	8b 00                	mov    (%eax),%eax
c002d2be:	83 ec 08             	sub    $0x8,%esp
c002d2c1:	53                   	push   %ebx
c002d2c2:	50                   	push   %eax
c002d2c3:	e8 aa 0e 00 00       	call   c002e172 <file_seek>
c002d2c8:	83 c4 10             	add    $0x10,%esp
		break;
c002d2cb:	eb 4e                	jmp    c002d31b <syscall_handler+0x253>

		case SYS_TELL:
		check_addr(fd);
c002d2cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d2d0:	83 ec 0c             	sub    $0xc,%esp
c002d2d3:	50                   	push   %eax
c002d2d4:	e8 0c 02 00 00       	call   c002d4e5 <check_addr>
c002d2d9:	83 c4 10             	add    $0x10,%esp
		f->eax = file_tell(list_search(&thread_current()->files, fd)->ptr);
c002d2dc:	e8 7f 3b ff ff       	call   c0020e60 <thread_current>
c002d2e1:	83 c0 3c             	add    $0x3c,%eax
c002d2e4:	83 ec 08             	sub    $0x8,%esp
c002d2e7:	ff 75 f0             	pushl  -0x10(%ebp)
c002d2ea:	50                   	push   %eax
c002d2eb:	e8 44 02 00 00       	call   c002d534 <list_search>
c002d2f0:	83 c4 10             	add    $0x10,%esp
c002d2f3:	8b 00                	mov    (%eax),%eax
c002d2f5:	83 ec 0c             	sub    $0xc,%esp
c002d2f8:	50                   	push   %eax
c002d2f9:	e8 d4 0e 00 00       	call   c002e1d2 <file_tell>
c002d2fe:	83 c4 10             	add    $0x10,%esp
c002d301:	89 c2                	mov    %eax,%edx
c002d303:	8b 45 08             	mov    0x8(%ebp),%eax
c002d306:	89 50 1c             	mov    %edx,0x1c(%eax)
		break;
c002d309:	eb 10                	jmp    c002d31b <syscall_handler+0x253>

		default:
		printf("No match\n");
c002d30b:	83 ec 0c             	sub    $0xc,%esp
c002d30e:	68 cc 2a 03 c0       	push   $0xc0032acc
c002d313:	e8 28 e7 ff ff       	call   c002ba40 <puts>
c002d318:	83 c4 10             	add    $0x10,%esp
	}
}
c002d31b:	90                   	nop
c002d31c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d31f:	c9                   	leave  
c002d320:	c3                   	ret    

c002d321 <open>:

int 
open(int fd){
c002d321:	55                   	push   %ebp
c002d322:	89 e5                	mov    %esp,%ebp
c002d324:	53                   	push   %ebx
c002d325:	83 ec 14             	sub    $0x14,%esp

	int status=0;
c002d328:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	check_addr(fd);
c002d32f:	8b 45 08             	mov    0x8(%ebp),%eax
c002d332:	83 ec 0c             	sub    $0xc,%esp
c002d335:	50                   	push   %eax
c002d336:	e8 aa 01 00 00       	call   c002d4e5 <check_addr>
c002d33b:	83 c4 10             	add    $0x10,%esp
		
	struct file* fptr = filesys_open (fd);
c002d33e:	8b 45 08             	mov    0x8(%ebp),%eax
c002d341:	83 ec 0c             	sub    $0xc,%esp
c002d344:	50                   	push   %eax
c002d345:	e8 19 08 00 00       	call   c002db63 <filesys_open>
c002d34a:	83 c4 10             	add    $0x10,%esp
c002d34d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		
	if(fptr==NULL)
c002d350:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002d354:	75 09                	jne    c002d35f <open+0x3e>
		status= -1;
c002d356:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
c002d35d:	eb 56                	jmp    c002d3b5 <open+0x94>
	else
	{
		struct proc_file *pfile = malloc(sizeof(*pfile));
c002d35f:	83 ec 0c             	sub    $0xc,%esp
c002d362:	6a 10                	push   $0x10
c002d364:	e8 29 63 ff ff       	call   c0023692 <malloc>
c002d369:	83 c4 10             	add    $0x10,%esp
c002d36c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		pfile->ptr = fptr;
c002d36f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d372:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d375:	89 10                	mov    %edx,(%eax)
		pfile->fd = thread_current()->fd_count;
c002d377:	e8 e4 3a ff ff       	call   c0020e60 <thread_current>
c002d37c:	8b 50 4c             	mov    0x4c(%eax),%edx
c002d37f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d382:	89 50 04             	mov    %edx,0x4(%eax)
		thread_current()->fd_count++;
c002d385:	e8 d6 3a ff ff       	call   c0020e60 <thread_current>
c002d38a:	8b 50 4c             	mov    0x4c(%eax),%edx
c002d38d:	42                   	inc    %edx
c002d38e:	89 50 4c             	mov    %edx,0x4c(%eax)
		list_push_back (&thread_current()->files, &pfile->elem);
c002d391:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d394:	8d 58 08             	lea    0x8(%eax),%ebx
c002d397:	e8 c4 3a ff ff       	call   c0020e60 <thread_current>
c002d39c:	83 c0 3c             	add    $0x3c,%eax
c002d39f:	83 ec 08             	sub    $0x8,%esp
c002d3a2:	53                   	push   %ebx
c002d3a3:	50                   	push   %eax
c002d3a4:	e8 16 ca ff ff       	call   c0029dbf <list_push_back>
c002d3a9:	83 c4 10             	add    $0x10,%esp
		status= pfile->fd;
c002d3ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d3af:	8b 40 04             	mov    0x4(%eax),%eax
c002d3b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	return status;
c002d3b5:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
c002d3b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d3bb:	c9                   	leave  
c002d3bc:	c3                   	ret    

c002d3bd <write>:

int
write (int fd, const void *buffer, unsigned size)
{
c002d3bd:	55                   	push   %ebp
c002d3be:	89 e5                	mov    %esp,%ebp
c002d3c0:	83 ec 18             	sub    $0x18,%esp
	check_addr(buffer);
c002d3c3:	83 ec 0c             	sub    $0xc,%esp
c002d3c6:	ff 75 0c             	pushl  0xc(%ebp)
c002d3c9:	e8 17 01 00 00       	call   c002d4e5 <check_addr>
c002d3ce:	83 c4 10             	add    $0x10,%esp
	check_addr(buffer + size - 1);
c002d3d1:	8b 45 10             	mov    0x10(%ebp),%eax
c002d3d4:	8d 50 ff             	lea    -0x1(%eax),%edx
c002d3d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d3da:	01 d0                	add    %edx,%eax
c002d3dc:	83 ec 0c             	sub    $0xc,%esp
c002d3df:	50                   	push   %eax
c002d3e0:	e8 00 01 00 00       	call   c002d4e5 <check_addr>
c002d3e5:	83 c4 10             	add    $0x10,%esp

	struct proc_file* fd_struct;
	int status = 0;
c002d3e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (fd == STDOUT_FILENO)
c002d3ef:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002d3f3:	75 16                	jne    c002d40b <write+0x4e>
		{
		putbuf (buffer, size);
c002d3f5:	83 ec 08             	sub    $0x8,%esp
c002d3f8:	ff 75 10             	pushl  0x10(%ebp)
c002d3fb:	ff 75 0c             	pushl  0xc(%ebp)
c002d3fe:	e8 86 e6 ff ff       	call   c002ba89 <putbuf>
c002d403:	83 c4 10             	add    $0x10,%esp
		return size;
c002d406:	8b 45 10             	mov    0x10(%ebp),%eax
c002d409:	eb 4b                	jmp    c002d456 <write+0x99>
		}
	if (fd == STDIN_FILENO)
c002d40b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d40f:	75 07                	jne    c002d418 <write+0x5b>
	{
		return -1;
c002d411:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002d416:	eb 3e                	jmp    c002d456 <write+0x99>
	}

	fd_struct = list_search(&thread_current()->files, fd);
c002d418:	e8 43 3a ff ff       	call   c0020e60 <thread_current>
c002d41d:	83 c0 3c             	add    $0x3c,%eax
c002d420:	83 ec 08             	sub    $0x8,%esp
c002d423:	ff 75 08             	pushl  0x8(%ebp)
c002d426:	50                   	push   %eax
c002d427:	e8 08 01 00 00       	call   c002d534 <list_search>
c002d42c:	83 c4 10             	add    $0x10,%esp
c002d42f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (fd_struct != NULL)
c002d432:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002d436:	74 1b                	je     c002d453 <write+0x96>
	status = file_write (fd_struct->ptr, buffer, size);
c002d438:	8b 55 10             	mov    0x10(%ebp),%edx
c002d43b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d43e:	8b 00                	mov    (%eax),%eax
c002d440:	83 ec 04             	sub    $0x4,%esp
c002d443:	52                   	push   %edx
c002d444:	ff 75 0c             	pushl  0xc(%ebp)
c002d447:	50                   	push   %eax
c002d448:	e8 e8 0b 00 00       	call   c002e035 <file_write>
c002d44d:	83 c4 10             	add    $0x10,%esp
c002d450:	89 45 f4             	mov    %eax,-0xc(%ebp)

	return status;
c002d453:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002d456:	c9                   	leave  
c002d457:	c3                   	ret    

c002d458 <close_all_files>:

void close_all_files(struct list* files)
{
c002d458:	55                   	push   %ebp
c002d459:	89 e5                	mov    %esp,%ebp
c002d45b:	83 ec 18             	sub    $0x18,%esp

	struct list_elem *e;

      for (e = list_begin (files); e != list_end (files);
c002d45e:	83 ec 0c             	sub    $0xc,%esp
c002d461:	ff 75 08             	pushl  0x8(%ebp)
c002d464:	e8 cb c5 ff ff       	call   c0029a34 <list_begin>
c002d469:	83 c4 10             	add    $0x10,%esp
c002d46c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002d46f:	eb 3c                	jmp    c002d4ad <close_all_files+0x55>
           e = list_next (e))
        {
          struct proc_file *f = list_entry (e, struct proc_file, elem);
c002d471:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d474:	83 c0 04             	add    $0x4,%eax
c002d477:	83 e8 0c             	sub    $0xc,%eax
c002d47a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	      	file_close(f->ptr);
c002d47d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d480:	8b 00                	mov    (%eax),%eax
c002d482:	83 ec 0c             	sub    $0xc,%esp
c002d485:	50                   	push   %eax
c002d486:	e8 0b 0b 00 00       	call   c002df96 <file_close>
c002d48b:	83 c4 10             	add    $0x10,%esp
	      	list_remove(e);
c002d48e:	83 ec 0c             	sub    $0xc,%esp
c002d491:	ff 75 f4             	pushl  -0xc(%ebp)
c002d494:	e8 4c c9 ff ff       	call   c0029de5 <list_remove>
c002d499:	83 c4 10             	add    $0x10,%esp
           e = list_next (e))
c002d49c:	83 ec 0c             	sub    $0xc,%esp
c002d49f:	ff 75 f4             	pushl  -0xc(%ebp)
c002d4a2:	e8 bf c5 ff ff       	call   c0029a66 <list_next>
c002d4a7:	83 c4 10             	add    $0x10,%esp
c002d4aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_begin (files); e != list_end (files);
c002d4ad:	83 ec 0c             	sub    $0xc,%esp
c002d4b0:	ff 75 08             	pushl  0x8(%ebp)
c002d4b3:	e8 f8 c5 ff ff       	call   c0029ab0 <list_end>
c002d4b8:	83 c4 10             	add    $0x10,%esp
c002d4bb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002d4be:	75 b1                	jne    c002d471 <close_all_files+0x19>
        }
} 
c002d4c0:	90                   	nop
c002d4c1:	c9                   	leave  
c002d4c2:	c3                   	ret    

c002d4c3 <exit>:

void exit (int error_code){
c002d4c3:	55                   	push   %ebp
c002d4c4:	89 e5                	mov    %esp,%ebp
c002d4c6:	83 ec 08             	sub    $0x8,%esp
		thread_current()->parent->is_exited = true;
c002d4c9:	e8 92 39 ff ff       	call   c0020e60 <thread_current>
c002d4ce:	8b 40 34             	mov    0x34(%eax),%eax
c002d4d1:	c6 40 30 01          	movb   $0x1,0x30(%eax)
		thread_current()->exit_error = error_code;
c002d4d5:	e8 86 39 ff ff       	call   c0020e60 <thread_current>
c002d4da:	8b 55 08             	mov    0x8(%ebp),%edx
c002d4dd:	89 50 38             	mov    %edx,0x38(%eax)
		thread_exit();
c002d4e0:	e8 fb 39 ff ff       	call   c0020ee0 <thread_exit>

c002d4e5 <check_addr>:
}

void check_addr(const void *vaddr)
{
c002d4e5:	55                   	push   %ebp
c002d4e6:	89 e5                	mov    %esp,%ebp
c002d4e8:	83 ec 18             	sub    $0x18,%esp
	
	if (!is_user_vaddr(vaddr))
c002d4eb:	ff 75 08             	pushl  0x8(%ebp)
c002d4ee:	e8 a2 fb ff ff       	call   c002d095 <is_user_vaddr>
c002d4f3:	83 c4 04             	add    $0x4,%esp
c002d4f6:	83 f0 01             	xor    $0x1,%eax
c002d4f9:	84 c0                	test   %al,%al
c002d4fb:	74 0a                	je     c002d507 <check_addr+0x22>
	{
		exit(-1);	
c002d4fd:	83 ec 0c             	sub    $0xc,%esp
c002d500:	6a ff                	push   $0xffffffff
c002d502:	e8 bc ff ff ff       	call   c002d4c3 <exit>
	}
	void *ptr = pagedir_get_page(thread_current()->pagedir, vaddr);
c002d507:	e8 54 39 ff ff       	call   c0020e60 <thread_current>
c002d50c:	8b 40 50             	mov    0x50(%eax),%eax
c002d50f:	83 ec 08             	sub    $0x8,%esp
c002d512:	ff 75 08             	pushl  0x8(%ebp)
c002d515:	50                   	push   %eax
c002d516:	e8 8e f5 ff ff       	call   c002caa9 <pagedir_get_page>
c002d51b:	83 c4 10             	add    $0x10,%esp
c002d51e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!ptr)
c002d521:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d525:	75 0a                	jne    c002d531 <check_addr+0x4c>
	{
		exit(-1);
c002d527:	83 ec 0c             	sub    $0xc,%esp
c002d52a:	6a ff                	push   $0xffffffff
c002d52c:	e8 92 ff ff ff       	call   c002d4c3 <exit>
	}
}
c002d531:	90                   	nop
c002d532:	c9                   	leave  
c002d533:	c3                   	ret    

c002d534 <list_search>:

struct proc_file* list_search(struct list* files, int fd)
{
c002d534:	55                   	push   %ebp
c002d535:	89 e5                	mov    %esp,%ebp
c002d537:	83 ec 18             	sub    $0x18,%esp

	struct list_elem *e;

      for (e = list_begin (files); e != list_end (files);
c002d53a:	83 ec 0c             	sub    $0xc,%esp
c002d53d:	ff 75 08             	pushl  0x8(%ebp)
c002d540:	e8 ef c4 ff ff       	call   c0029a34 <list_begin>
c002d545:	83 c4 10             	add    $0x10,%esp
c002d548:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002d54b:	eb 2d                	jmp    c002d57a <list_search+0x46>
           e = list_next (e))
        {
          struct proc_file *f = list_entry (e, struct proc_file, elem);
c002d54d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d550:	83 c0 04             	add    $0x4,%eax
c002d553:	83 e8 0c             	sub    $0xc,%eax
c002d556:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(f->fd == fd)
c002d559:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d55c:	8b 40 04             	mov    0x4(%eax),%eax
c002d55f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002d562:	75 05                	jne    c002d569 <list_search+0x35>
          	return f;
c002d564:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d567:	eb 29                	jmp    c002d592 <list_search+0x5e>
           e = list_next (e))
c002d569:	83 ec 0c             	sub    $0xc,%esp
c002d56c:	ff 75 f4             	pushl  -0xc(%ebp)
c002d56f:	e8 f2 c4 ff ff       	call   c0029a66 <list_next>
c002d574:	83 c4 10             	add    $0x10,%esp
c002d577:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_begin (files); e != list_end (files);
c002d57a:	83 ec 0c             	sub    $0xc,%esp
c002d57d:	ff 75 08             	pushl  0x8(%ebp)
c002d580:	e8 2b c5 ff ff       	call   c0029ab0 <list_end>
c002d585:	83 c4 10             	add    $0x10,%esp
c002d588:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002d58b:	75 c0                	jne    c002d54d <list_search+0x19>
        }
   return NULL;
c002d58d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002d592:	c9                   	leave  
c002d593:	c3                   	ret    

c002d594 <close_file>:

void close_file(struct list* files, int fd)
{
c002d594:	55                   	push   %ebp
c002d595:	89 e5                	mov    %esp,%ebp
c002d597:	83 ec 18             	sub    $0x18,%esp

	struct list_elem *e;

      for (e = list_begin (files); e != list_end (files);
c002d59a:	83 ec 0c             	sub    $0xc,%esp
c002d59d:	ff 75 08             	pushl  0x8(%ebp)
c002d5a0:	e8 8f c4 ff ff       	call   c0029a34 <list_begin>
c002d5a5:	83 c4 10             	add    $0x10,%esp
c002d5a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002d5ab:	eb 47                	jmp    c002d5f4 <close_file+0x60>
           e = list_next (e))
        {
          struct proc_file *f = list_entry (e, struct proc_file, elem);
c002d5ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5b0:	83 c0 04             	add    $0x4,%eax
c002d5b3:	83 e8 0c             	sub    $0xc,%eax
c002d5b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(f->fd == fd)
c002d5b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d5bc:	8b 40 04             	mov    0x4(%eax),%eax
c002d5bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002d5c2:	75 1f                	jne    c002d5e3 <close_file+0x4f>
          {
          	file_close(f->ptr);
c002d5c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d5c7:	8b 00                	mov    (%eax),%eax
c002d5c9:	83 ec 0c             	sub    $0xc,%esp
c002d5cc:	50                   	push   %eax
c002d5cd:	e8 c4 09 00 00       	call   c002df96 <file_close>
c002d5d2:	83 c4 10             	add    $0x10,%esp
          	list_remove(e);
c002d5d5:	83 ec 0c             	sub    $0xc,%esp
c002d5d8:	ff 75 f4             	pushl  -0xc(%ebp)
c002d5db:	e8 05 c8 ff ff       	call   c0029de5 <list_remove>
c002d5e0:	83 c4 10             	add    $0x10,%esp
           e = list_next (e))
c002d5e3:	83 ec 0c             	sub    $0xc,%esp
c002d5e6:	ff 75 f4             	pushl  -0xc(%ebp)
c002d5e9:	e8 78 c4 ff ff       	call   c0029a66 <list_next>
c002d5ee:	83 c4 10             	add    $0x10,%esp
c002d5f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_begin (files); e != list_end (files);
c002d5f4:	83 ec 0c             	sub    $0xc,%esp
c002d5f7:	ff 75 08             	pushl  0x8(%ebp)
c002d5fa:	e8 b1 c4 ff ff       	call   c0029ab0 <list_end>
c002d5ff:	83 c4 10             	add    $0x10,%esp
c002d602:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002d605:	75 a6                	jne    c002d5ad <close_file+0x19>
          }
        }
}
c002d607:	90                   	nop
c002d608:	c9                   	leave  
c002d609:	c3                   	ret    

c002d60a <read>:

int
read (int fd, void *buffer, unsigned size)

{
c002d60a:	55                   	push   %ebp
c002d60b:	89 e5                	mov    %esp,%ebp
c002d60d:	83 ec 28             	sub    $0x28,%esp
	struct proc_file* fd_struct  ; 
	int status = 0;
c002d610:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	check_addr(buffer);
c002d617:	83 ec 0c             	sub    $0xc,%esp
c002d61a:	ff 75 0c             	pushl  0xc(%ebp)
c002d61d:	e8 c3 fe ff ff       	call   c002d4e5 <check_addr>
c002d622:	83 c4 10             	add    $0x10,%esp
	check_addr(buffer + size - 1);
c002d625:	8b 45 10             	mov    0x10(%ebp),%eax
c002d628:	8d 50 ff             	lea    -0x1(%eax),%edx
c002d62b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d62e:	01 d0                	add    %edx,%eax
c002d630:	83 ec 0c             	sub    $0xc,%esp
c002d633:	50                   	push   %eax
c002d634:	e8 ac fe ff ff       	call   c002d4e5 <check_addr>
c002d639:	83 c4 10             	add    $0x10,%esp


  if (fd == STDOUT_FILENO)
c002d63c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002d640:	75 0a                	jne    c002d64c <read+0x42>
    {
      return -1;
c002d642:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002d647:	e9 82 00 00 00       	jmp    c002d6ce <read+0xc4>
    }

  if (fd == STDIN_FILENO)
c002d64c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002d650:	75 3e                	jne    c002d690 <read+0x86>
    {
      uint8_t c;
      unsigned counter = size;
c002d652:	8b 45 10             	mov    0x10(%ebp),%eax
c002d655:	89 45 f0             	mov    %eax,-0x10(%ebp)
      uint8_t *buf = buffer;
c002d658:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d65b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      while (counter > 1 && (c = input_getc()) != 0)
c002d65e:	eb 0e                	jmp    c002d66e <read+0x64>
        {
          *buf = c;
c002d660:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d663:	8a 55 eb             	mov    -0x15(%ebp),%dl
c002d666:	88 10                	mov    %dl,(%eax)
          buffer++;
c002d668:	ff 45 0c             	incl   0xc(%ebp)
          counter--; 
c002d66b:	ff 4d f0             	decl   -0x10(%ebp)
      while (counter > 1 && (c = input_getc()) != 0)
c002d66e:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c002d672:	76 0e                	jbe    c002d682 <read+0x78>
c002d674:	e8 29 90 ff ff       	call   c00266a2 <input_getc>
c002d679:	88 45 eb             	mov    %al,-0x15(%ebp)
c002d67c:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
c002d680:	75 de                	jne    c002d660 <read+0x56>
        }
      *buf = 0;
c002d682:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d685:	c6 00 00             	movb   $0x0,(%eax)
      return (size - counter);
c002d688:	8b 45 10             	mov    0x10(%ebp),%eax
c002d68b:	2b 45 f0             	sub    -0x10(%ebp),%eax
c002d68e:	eb 3e                	jmp    c002d6ce <read+0xc4>
    } 

  fd_struct = list_search(&thread_current()->files, fd);
c002d690:	e8 cb 37 ff ff       	call   c0020e60 <thread_current>
c002d695:	83 c0 3c             	add    $0x3c,%eax
c002d698:	83 ec 08             	sub    $0x8,%esp
c002d69b:	ff 75 08             	pushl  0x8(%ebp)
c002d69e:	50                   	push   %eax
c002d69f:	e8 90 fe ff ff       	call   c002d534 <list_search>
c002d6a4:	83 c4 10             	add    $0x10,%esp
c002d6a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (fd_struct != NULL)
c002d6aa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002d6ae:	74 1b                	je     c002d6cb <read+0xc1>
    status = file_read (fd_struct->ptr, buffer, size);
c002d6b0:	8b 55 10             	mov    0x10(%ebp),%edx
c002d6b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d6b6:	8b 00                	mov    (%eax),%eax
c002d6b8:	83 ec 04             	sub    $0x4,%esp
c002d6bb:	52                   	push   %edx
c002d6bc:	ff 75 0c             	pushl  0xc(%ebp)
c002d6bf:	50                   	push   %eax
c002d6c0:	e8 17 09 00 00       	call   c002dfdc <file_read>
c002d6c5:	83 c4 10             	add    $0x10,%esp
c002d6c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  return status;
c002d6cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002d6ce:	c9                   	leave  
c002d6cf:	c3                   	ret    

c002d6d0 <gdt_init>:

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void
gdt_init (void)
{
c002d6d0:	55                   	push   %ebp
c002d6d1:	89 e5                	mov    %esp,%ebp
c002d6d3:	83 ec 18             	sub    $0x18,%esp
  uint64_t gdtr_operand;

  /* Initialize GDT. */
  gdt[SEL_NULL / sizeof *gdt] = 0;
c002d6d6:	c7 05 e0 a3 03 c0 00 	movl   $0x0,0xc003a3e0
c002d6dd:	00 00 00 
c002d6e0:	c7 05 e4 a3 03 c0 00 	movl   $0x0,0xc003a3e4
c002d6e7:	00 00 00 
  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc (0);
c002d6ea:	83 ec 0c             	sub    $0xc,%esp
c002d6ed:	6a 00                	push   $0x0
c002d6ef:	e8 fe 01 00 00       	call   c002d8f2 <make_code_desc>
c002d6f4:	83 c4 10             	add    $0x10,%esp
c002d6f7:	a3 e8 a3 03 c0       	mov    %eax,0xc003a3e8
c002d6fc:	89 15 ec a3 03 c0    	mov    %edx,0xc003a3ec
  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc (0);
c002d702:	83 ec 0c             	sub    $0xc,%esp
c002d705:	6a 00                	push   $0x0
c002d707:	e8 09 02 00 00       	call   c002d915 <make_data_desc>
c002d70c:	83 c4 10             	add    $0x10,%esp
c002d70f:	a3 f0 a3 03 c0       	mov    %eax,0xc003a3f0
c002d714:	89 15 f4 a3 03 c0    	mov    %edx,0xc003a3f4
  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc (3);
c002d71a:	83 ec 0c             	sub    $0xc,%esp
c002d71d:	6a 03                	push   $0x3
c002d71f:	e8 ce 01 00 00       	call   c002d8f2 <make_code_desc>
c002d724:	83 c4 10             	add    $0x10,%esp
c002d727:	a3 f8 a3 03 c0       	mov    %eax,0xc003a3f8
c002d72c:	89 15 fc a3 03 c0    	mov    %edx,0xc003a3fc
  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc (3);
c002d732:	83 ec 0c             	sub    $0xc,%esp
c002d735:	6a 03                	push   $0x3
c002d737:	e8 d9 01 00 00       	call   c002d915 <make_data_desc>
c002d73c:	83 c4 10             	add    $0x10,%esp
c002d73f:	a3 00 a4 03 c0       	mov    %eax,0xc003a400
c002d744:	89 15 04 a4 03 c0    	mov    %edx,0xc003a404
  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc (tss_get ());
c002d74a:	e8 8a 02 00 00       	call   c002d9d9 <tss_get>
c002d74f:	83 ec 0c             	sub    $0xc,%esp
c002d752:	50                   	push   %eax
c002d753:	e8 e0 01 00 00       	call   c002d938 <make_tss_desc>
c002d758:	83 c4 10             	add    $0x10,%esp
c002d75b:	a3 08 a4 03 c0       	mov    %eax,0xc003a408
c002d760:	89 15 0c a4 03 c0    	mov    %edx,0xc003a40c

  /* Load GDTR, TR.  See [IA32-v3a] 2.4.1 "Global Descriptor
     Table Register (GDTR)", 2.4.4 "Task Register (TR)", and
     6.2.4 "Task Register".  */
  gdtr_operand = make_gdtr_operand (sizeof gdt - 1, gdt);
c002d766:	83 ec 08             	sub    $0x8,%esp
c002d769:	68 e0 a3 03 c0       	push   $0xc003a3e0
c002d76e:	6a 2f                	push   $0x2f
c002d770:	e8 e4 01 00 00       	call   c002d959 <make_gdtr_operand>
c002d775:	83 c4 10             	add    $0x10,%esp
c002d778:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d77b:	89 55 f4             	mov    %edx,-0xc(%ebp)
  asm volatile ("lgdt %0" : : "m" (gdtr_operand));
c002d77e:	0f 01 55 f0          	lgdtl  -0x10(%ebp)
  asm volatile ("ltr %w0" : : "q" (SEL_TSS));
c002d782:	b8 28 00 00 00       	mov    $0x28,%eax
c002d787:	0f 00 d8             	ltr    %ax
}
c002d78a:	90                   	nop
c002d78b:	c9                   	leave  
c002d78c:	c3                   	ret    

c002d78d <make_seg_desc>:
               uint32_t limit,
               enum seg_class class,
               int type,
               int dpl,
               enum seg_granularity granularity)
{
c002d78d:	55                   	push   %ebp
c002d78e:	89 e5                	mov    %esp,%ebp
c002d790:	57                   	push   %edi
c002d791:	56                   	push   %esi
c002d792:	53                   	push   %ebx
c002d793:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (limit <= 0xfffff);
c002d796:	81 7d 0c ff ff 0f 00 	cmpl   $0xfffff,0xc(%ebp)
c002d79d:	76 1e                	jbe    c002d7bd <make_seg_desc+0x30>
c002d79f:	83 ec 0c             	sub    $0xc,%esp
c002d7a2:	68 0c 2b 03 c0       	push   $0xc0032b0c
c002d7a7:	68 1d 2b 03 c0       	push   $0xc0032b1d
c002d7ac:	68 e0 2b 03 c0       	push   $0xc0032be0
c002d7b1:	6a 5b                	push   $0x5b
c002d7b3:	68 34 2b 03 c0       	push   $0xc0032b34
c002d7b8:	e8 b1 bf ff ff       	call   c002976e <debug_panic>
  ASSERT (class == CLS_SYSTEM || class == CLS_CODE_DATA);
c002d7bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002d7c1:	74 24                	je     c002d7e7 <make_seg_desc+0x5a>
c002d7c3:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c002d7c7:	74 1e                	je     c002d7e7 <make_seg_desc+0x5a>
c002d7c9:	83 ec 0c             	sub    $0xc,%esp
c002d7cc:	68 4c 2b 03 c0       	push   $0xc0032b4c
c002d7d1:	68 1d 2b 03 c0       	push   $0xc0032b1d
c002d7d6:	68 e0 2b 03 c0       	push   $0xc0032be0
c002d7db:	6a 5c                	push   $0x5c
c002d7dd:	68 34 2b 03 c0       	push   $0xc0032b34
c002d7e2:	e8 87 bf ff ff       	call   c002976e <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c002d7e7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002d7eb:	78 06                	js     c002d7f3 <make_seg_desc+0x66>
c002d7ed:	83 7d 14 0f          	cmpl   $0xf,0x14(%ebp)
c002d7f1:	7e 1e                	jle    c002d811 <make_seg_desc+0x84>
c002d7f3:	83 ec 0c             	sub    $0xc,%esp
c002d7f6:	68 7a 2b 03 c0       	push   $0xc0032b7a
c002d7fb:	68 1d 2b 03 c0       	push   $0xc0032b1d
c002d800:	68 e0 2b 03 c0       	push   $0xc0032be0
c002d805:	6a 5d                	push   $0x5d
c002d807:	68 34 2b 03 c0       	push   $0xc0032b34
c002d80c:	e8 5d bf ff ff       	call   c002976e <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c002d811:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
c002d815:	78 06                	js     c002d81d <make_seg_desc+0x90>
c002d817:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
c002d81b:	7e 1e                	jle    c002d83b <make_seg_desc+0xae>
c002d81d:	83 ec 0c             	sub    $0xc,%esp
c002d820:	68 92 2b 03 c0       	push   $0xc0032b92
c002d825:	68 1d 2b 03 c0       	push   $0xc0032b1d
c002d82a:	68 e0 2b 03 c0       	push   $0xc0032be0
c002d82f:	6a 5e                	push   $0x5e
c002d831:	68 34 2b 03 c0       	push   $0xc0032b34
c002d836:	e8 33 bf ff ff       	call   c002976e <debug_panic>
  ASSERT (granularity == GRAN_BYTE || granularity == GRAN_PAGE);
c002d83b:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c002d83f:	74 24                	je     c002d865 <make_seg_desc+0xd8>
c002d841:	83 7d 1c 01          	cmpl   $0x1,0x1c(%ebp)
c002d845:	74 1e                	je     c002d865 <make_seg_desc+0xd8>
c002d847:	83 ec 0c             	sub    $0xc,%esp
c002d84a:	68 a8 2b 03 c0       	push   $0xc0032ba8
c002d84f:	68 1d 2b 03 c0       	push   $0xc0032b1d
c002d854:	68 e0 2b 03 c0       	push   $0xc0032be0
c002d859:	6a 5f                	push   $0x5f
c002d85b:	68 34 2b 03 c0       	push   $0xc0032b34
c002d860:	e8 09 bf ff ff       	call   c002976e <debug_panic>

  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002d865:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d868:	0f b7 c0             	movzwl %ax,%eax
        | (base << 16));             /* Base 15:0. */
c002d86b:	8b 55 08             	mov    0x8(%ebp),%edx
c002d86e:	c1 e2 10             	shl    $0x10,%edx
  e0 = ((limit & 0xffff)             /* Limit 15:0. */
c002d871:	09 d0                	or     %edx,%eax
c002d873:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002d876:	8b 45 08             	mov    0x8(%ebp),%eax
c002d879:	c1 e8 10             	shr    $0x10,%eax
c002d87c:	0f b6 c0             	movzbl %al,%eax
        | (type << 8)                /* Segment type. */
c002d87f:	8b 55 14             	mov    0x14(%ebp),%edx
c002d882:	c1 e2 08             	shl    $0x8,%edx
c002d885:	09 c2                	or     %eax,%edx
        | (class << 12)              /* 0=system, 1=code/data. */
c002d887:	8b 45 10             	mov    0x10(%ebp),%eax
c002d88a:	c1 e0 0c             	shl    $0xc,%eax
c002d88d:	09 c2                	or     %eax,%edx
        | (dpl << 13)                /* Descriptor privilege. */
c002d88f:	8b 45 18             	mov    0x18(%ebp),%eax
c002d892:	c1 e0 0d             	shl    $0xd,%eax
c002d895:	09 c2                	or     %eax,%edx
        | (1 << 15)                  /* Present. */
        | (limit & 0xf0000)          /* Limit 16:19. */
c002d897:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d89a:	25 00 00 0f 00       	and    $0xf0000,%eax
c002d89f:	09 c2                	or     %eax,%edx
        | (1 << 22)                  /* 32-bit segment. */
        | (granularity << 23)        /* Byte/page granularity. */
c002d8a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002d8a4:	c1 e0 17             	shl    $0x17,%eax
c002d8a7:	09 c2                	or     %eax,%edx
        | (base & 0xff000000));      /* Base 31:24. */
c002d8a9:	8b 45 08             	mov    0x8(%ebp),%eax
c002d8ac:	25 00 00 00 ff       	and    $0xff000000,%eax
c002d8b1:	09 d0                	or     %edx,%eax
  e1 = (((base >> 16) & 0xff)        /* Base 23:16. */
c002d8b3:	0d 00 80 40 00       	or     $0x408000,%eax
c002d8b8:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c002d8bb:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c002d8be:	bf 00 00 00 00       	mov    $0x0,%edi
c002d8c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002d8c6:	ba 00 00 00 00       	mov    $0x0,%edx
c002d8cb:	89 c2                	mov    %eax,%edx
c002d8cd:	b8 00 00 00 00       	mov    $0x0,%eax
c002d8d2:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002d8d5:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c002d8d8:	89 f0                	mov    %esi,%eax
c002d8da:	0b 45 d0             	or     -0x30(%ebp),%eax
c002d8dd:	89 c1                	mov    %eax,%ecx
c002d8df:	89 f8                	mov    %edi,%eax
c002d8e1:	0b 45 d4             	or     -0x2c(%ebp),%eax
c002d8e4:	89 c3                	mov    %eax,%ebx
c002d8e6:	89 c8                	mov    %ecx,%eax
c002d8e8:	89 da                	mov    %ebx,%edx
}
c002d8ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002d8ed:	5b                   	pop    %ebx
c002d8ee:	5e                   	pop    %esi
c002d8ef:	5f                   	pop    %edi
c002d8f0:	5d                   	pop    %ebp
c002d8f1:	c3                   	ret    

c002d8f2 <make_code_desc>:

/* Returns a descriptor for a readable code segment with base at
   0, a limit of 4 GB, and the given DPL. */
static uint64_t
make_code_desc (int dpl)
{
c002d8f2:	55                   	push   %ebp
c002d8f3:	89 e5                	mov    %esp,%ebp
c002d8f5:	83 ec 08             	sub    $0x8,%esp
  return make_seg_desc (0, 0xfffff, CLS_CODE_DATA, 10, dpl, GRAN_PAGE);
c002d8f8:	83 ec 08             	sub    $0x8,%esp
c002d8fb:	6a 01                	push   $0x1
c002d8fd:	ff 75 08             	pushl  0x8(%ebp)
c002d900:	6a 0a                	push   $0xa
c002d902:	6a 01                	push   $0x1
c002d904:	68 ff ff 0f 00       	push   $0xfffff
c002d909:	6a 00                	push   $0x0
c002d90b:	e8 7d fe ff ff       	call   c002d78d <make_seg_desc>
c002d910:	83 c4 20             	add    $0x20,%esp
}
c002d913:	c9                   	leave  
c002d914:	c3                   	ret    

c002d915 <make_data_desc>:

/* Returns a descriptor for a writable data segment with base at
   0, a limit of 4 GB, and the given DPL. */
static uint64_t
make_data_desc (int dpl)
{
c002d915:	55                   	push   %ebp
c002d916:	89 e5                	mov    %esp,%ebp
c002d918:	83 ec 08             	sub    $0x8,%esp
  return make_seg_desc (0, 0xfffff, CLS_CODE_DATA, 2, dpl, GRAN_PAGE);
c002d91b:	83 ec 08             	sub    $0x8,%esp
c002d91e:	6a 01                	push   $0x1
c002d920:	ff 75 08             	pushl  0x8(%ebp)
c002d923:	6a 02                	push   $0x2
c002d925:	6a 01                	push   $0x1
c002d927:	68 ff ff 0f 00       	push   $0xfffff
c002d92c:	6a 00                	push   $0x0
c002d92e:	e8 5a fe ff ff       	call   c002d78d <make_seg_desc>
c002d933:	83 c4 20             	add    $0x20,%esp
}
c002d936:	c9                   	leave  
c002d937:	c3                   	ret    

c002d938 <make_tss_desc>:
   Segment with its base at the given linear address, a limit of
   0x67 bytes (the size of a 32-bit TSS), and a DPL of 0.
   See [IA32-v3a] 6.2.2 "TSS Descriptor". */
static uint64_t
make_tss_desc (void *laddr)
{
c002d938:	55                   	push   %ebp
c002d939:	89 e5                	mov    %esp,%ebp
c002d93b:	83 ec 08             	sub    $0x8,%esp
  return make_seg_desc ((uint32_t) laddr, 0x67, CLS_SYSTEM, 9, 0, GRAN_BYTE);
c002d93e:	8b 45 08             	mov    0x8(%ebp),%eax
c002d941:	83 ec 08             	sub    $0x8,%esp
c002d944:	6a 00                	push   $0x0
c002d946:	6a 00                	push   $0x0
c002d948:	6a 09                	push   $0x9
c002d94a:	6a 00                	push   $0x0
c002d94c:	6a 67                	push   $0x67
c002d94e:	50                   	push   %eax
c002d94f:	e8 39 fe ff ff       	call   c002d78d <make_seg_desc>
c002d954:	83 c4 20             	add    $0x20,%esp
}
c002d957:	c9                   	leave  
c002d958:	c3                   	ret    

c002d959 <make_gdtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand (uint16_t limit, void *base)
{
c002d959:	55                   	push   %ebp
c002d95a:	89 e5                	mov    %esp,%ebp
c002d95c:	57                   	push   %edi
c002d95d:	56                   	push   %esi
c002d95e:	53                   	push   %ebx
c002d95f:	83 ec 14             	sub    $0x14,%esp
c002d962:	8b 45 08             	mov    0x8(%ebp),%eax
c002d965:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c002d969:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c002d96d:	89 c6                	mov    %eax,%esi
c002d96f:	bf 00 00 00 00       	mov    $0x0,%edi
c002d974:	8b 45 0c             	mov    0xc(%ebp),%eax
c002d977:	ba 00 00 00 00       	mov    $0x0,%edx
c002d97c:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002d980:	c1 e0 10             	shl    $0x10,%eax
c002d983:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002d986:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002d989:	89 f0                	mov    %esi,%eax
c002d98b:	0b 45 e0             	or     -0x20(%ebp),%eax
c002d98e:	89 c1                	mov    %eax,%ecx
c002d990:	89 f8                	mov    %edi,%eax
c002d992:	0b 45 e4             	or     -0x1c(%ebp),%eax
c002d995:	89 c3                	mov    %eax,%ebx
c002d997:	89 c8                	mov    %ecx,%eax
c002d999:	89 da                	mov    %ebx,%edx
}
c002d99b:	83 c4 14             	add    $0x14,%esp
c002d99e:	5b                   	pop    %ebx
c002d99f:	5e                   	pop    %esi
c002d9a0:	5f                   	pop    %edi
c002d9a1:	5d                   	pop    %ebp
c002d9a2:	c3                   	ret    

c002d9a3 <tss_init>:
static struct tss *tss;

/* Initializes the kernel TSS. */
void
tss_init (void) 
{
c002d9a3:	55                   	push   %ebp
c002d9a4:	89 e5                	mov    %esp,%ebp
c002d9a6:	83 ec 08             	sub    $0x8,%esp
  /* Our TSS is never used in a call gate or task gate, so only a
     few fields of it are ever referenced, and those are the only
     ones we initialize. */
  tss = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c002d9a9:	83 ec 0c             	sub    $0xc,%esp
c002d9ac:	6a 03                	push   $0x3
c002d9ae:	e8 98 59 ff ff       	call   c002334b <palloc_get_page>
c002d9b3:	83 c4 10             	add    $0x10,%esp
c002d9b6:	a3 10 a4 03 c0       	mov    %eax,0xc003a410
  tss->ss0 = SEL_KDSEG;
c002d9bb:	a1 10 a4 03 c0       	mov    0xc003a410,%eax
c002d9c0:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
  tss->bitmap = 0xdfff;
c002d9c6:	a1 10 a4 03 c0       	mov    0xc003a410,%eax
c002d9cb:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
  tss_update ();
c002d9d1:	e8 37 00 00 00       	call   c002da0d <tss_update>
}
c002d9d6:	90                   	nop
c002d9d7:	c9                   	leave  
c002d9d8:	c3                   	ret    

c002d9d9 <tss_get>:

/* Returns the kernel TSS. */
struct tss *
tss_get (void) 
{
c002d9d9:	55                   	push   %ebp
c002d9da:	89 e5                	mov    %esp,%ebp
c002d9dc:	83 ec 08             	sub    $0x8,%esp
  ASSERT (tss != NULL);
c002d9df:	a1 10 a4 03 c0       	mov    0xc003a410,%eax
c002d9e4:	85 c0                	test   %eax,%eax
c002d9e6:	75 1e                	jne    c002da06 <tss_get+0x2d>
c002d9e8:	83 ec 0c             	sub    $0xc,%esp
c002d9eb:	68 f0 2b 03 c0       	push   $0xc0032bf0
c002d9f0:	68 fc 2b 03 c0       	push   $0xc0032bfc
c002d9f5:	68 28 2c 03 c0       	push   $0xc0032c28
c002d9fa:	6a 5f                	push   $0x5f
c002d9fc:	68 13 2c 03 c0       	push   $0xc0032c13
c002da01:	e8 68 bd ff ff       	call   c002976e <debug_panic>
  return tss;
c002da06:	a1 10 a4 03 c0       	mov    0xc003a410,%eax
}
c002da0b:	c9                   	leave  
c002da0c:	c3                   	ret    

c002da0d <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void
tss_update (void) 
{
c002da0d:	55                   	push   %ebp
c002da0e:	89 e5                	mov    %esp,%ebp
c002da10:	53                   	push   %ebx
c002da11:	83 ec 04             	sub    $0x4,%esp
  ASSERT (tss != NULL);
c002da14:	a1 10 a4 03 c0       	mov    0xc003a410,%eax
c002da19:	85 c0                	test   %eax,%eax
c002da1b:	75 1e                	jne    c002da3b <tss_update+0x2e>
c002da1d:	83 ec 0c             	sub    $0xc,%esp
c002da20:	68 f0 2b 03 c0       	push   $0xc0032bf0
c002da25:	68 fc 2b 03 c0       	push   $0xc0032bfc
c002da2a:	68 30 2c 03 c0       	push   $0xc0032c30
c002da2f:	6a 68                	push   $0x68
c002da31:	68 13 2c 03 c0       	push   $0xc0032c13
c002da36:	e8 33 bd ff ff       	call   c002976e <debug_panic>
  tss->esp0 = (uint8_t *) thread_current () + PGSIZE;
c002da3b:	8b 1d 10 a4 03 c0    	mov    0xc003a410,%ebx
c002da41:	e8 1a 34 ff ff       	call   c0020e60 <thread_current>
c002da46:	05 00 10 00 00       	add    $0x1000,%eax
c002da4b:	89 43 04             	mov    %eax,0x4(%ebx)
}
c002da4e:	90                   	nop
c002da4f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002da52:	c9                   	leave  
c002da53:	c3                   	ret    

c002da54 <filesys_init>:

/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void
filesys_init (bool format) 
{
c002da54:	55                   	push   %ebp
c002da55:	89 e5                	mov    %esp,%ebp
c002da57:	83 ec 18             	sub    $0x18,%esp
c002da5a:	8b 45 08             	mov    0x8(%ebp),%eax
c002da5d:	88 45 f4             	mov    %al,-0xc(%ebp)
  fs_device = block_get_role (BLOCK_FILESYS);
c002da60:	83 ec 0c             	sub    $0xc,%esp
c002da63:	6a 01                	push   $0x1
c002da65:	e8 0f 75 ff ff       	call   c0024f79 <block_get_role>
c002da6a:	83 c4 10             	add    $0x10,%esp
c002da6d:	a3 4c a6 03 c0       	mov    %eax,0xc003a64c
  if (fs_device == NULL)
c002da72:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002da77:	85 c0                	test   %eax,%eax
c002da79:	75 16                	jne    c002da91 <filesys_init+0x3d>
    PANIC ("No file system device found, can't initialize file system.");
c002da7b:	68 3c 2c 03 c0       	push   $0xc0032c3c
c002da80:	68 d4 2c 03 c0       	push   $0xc0032cd4
c002da85:	6a 16                	push   $0x16
c002da87:	68 77 2c 03 c0       	push   $0xc0032c77
c002da8c:	e8 dd bc ff ff       	call   c002976e <debug_panic>

  inode_init ();
c002da91:	e8 9b 0c 00 00       	call   c002e731 <inode_init>
  free_map_init ();
c002da96:	e8 c5 01 00 00       	call   c002dc60 <free_map_init>

  if (format) 
c002da9b:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002da9f:	74 05                	je     c002daa6 <filesys_init+0x52>
    do_format ();
c002daa1:	e8 5b 01 00 00       	call   c002dc01 <do_format>

  free_map_open ();
c002daa6:	e8 15 03 00 00       	call   c002ddc0 <free_map_open>
}
c002daab:	90                   	nop
c002daac:	c9                   	leave  
c002daad:	c3                   	ret    

c002daae <filesys_done>:

/* Shuts down the file system module, writing any unwritten data
   to disk. */
void
filesys_done (void) 
{
c002daae:	55                   	push   %ebp
c002daaf:	89 e5                	mov    %esp,%ebp
c002dab1:	83 ec 08             	sub    $0x8,%esp
  free_map_close ();
c002dab4:	e8 82 03 00 00       	call   c002de3b <free_map_close>
}
c002dab9:	90                   	nop
c002daba:	c9                   	leave  
c002dabb:	c3                   	ret    

c002dabc <filesys_create>:
   Returns true if successful, false otherwise.
   Fails if a file named NAME already exists,
   or if internal memory allocation fails. */
bool
filesys_create (const char *name, off_t initial_size) 
{
c002dabc:	55                   	push   %ebp
c002dabd:	89 e5                	mov    %esp,%ebp
c002dabf:	83 ec 18             	sub    $0x18,%esp
  block_sector_t inode_sector = 0;
c002dac2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  struct dir *dir = dir_open_root ();
c002dac9:	e8 bb 07 00 00       	call   c002e289 <dir_open_root>
c002dace:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bool success = (dir != NULL
                  && free_map_allocate (1, &inode_sector)
                  && inode_create (inode_sector, initial_size)
                  && dir_add (dir, name, inode_sector));
c002dad1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002dad5:	74 4b                	je     c002db22 <filesys_create+0x66>
                  && free_map_allocate (1, &inode_sector)
c002dad7:	83 ec 08             	sub    $0x8,%esp
c002dada:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002dadd:	50                   	push   %eax
c002dade:	6a 01                	push   $0x1
c002dae0:	e8 eb 01 00 00       	call   c002dcd0 <free_map_allocate>
c002dae5:	83 c4 10             	add    $0x10,%esp
c002dae8:	84 c0                	test   %al,%al
c002daea:	74 36                	je     c002db22 <filesys_create+0x66>
                  && inode_create (inode_sector, initial_size)
c002daec:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002daef:	83 ec 08             	sub    $0x8,%esp
c002daf2:	ff 75 0c             	pushl  0xc(%ebp)
c002daf5:	50                   	push   %eax
c002daf6:	e8 4f 0c 00 00       	call   c002e74a <inode_create>
c002dafb:	83 c4 10             	add    $0x10,%esp
c002dafe:	84 c0                	test   %al,%al
c002db00:	74 20                	je     c002db22 <filesys_create+0x66>
                  && dir_add (dir, name, inode_sector));
c002db02:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002db05:	83 ec 04             	sub    $0x4,%esp
c002db08:	50                   	push   %eax
c002db09:	ff 75 08             	pushl  0x8(%ebp)
c002db0c:	ff 75 f4             	pushl  -0xc(%ebp)
c002db0f:	e8 58 09 00 00       	call   c002e46c <dir_add>
c002db14:	83 c4 10             	add    $0x10,%esp
c002db17:	84 c0                	test   %al,%al
c002db19:	74 07                	je     c002db22 <filesys_create+0x66>
c002db1b:	b8 01 00 00 00       	mov    $0x1,%eax
c002db20:	eb 05                	jmp    c002db27 <filesys_create+0x6b>
c002db22:	b8 00 00 00 00       	mov    $0x0,%eax
  bool success = (dir != NULL
c002db27:	88 45 f3             	mov    %al,-0xd(%ebp)
c002db2a:	80 65 f3 01          	andb   $0x1,-0xd(%ebp)
  if (!success && inode_sector != 0) 
c002db2e:	8a 45 f3             	mov    -0xd(%ebp),%al
c002db31:	83 f0 01             	xor    $0x1,%eax
c002db34:	84 c0                	test   %al,%al
c002db36:	74 18                	je     c002db50 <filesys_create+0x94>
c002db38:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002db3b:	85 c0                	test   %eax,%eax
c002db3d:	74 11                	je     c002db50 <filesys_create+0x94>
    free_map_release (inode_sector, 1);
c002db3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002db42:	83 ec 08             	sub    $0x8,%esp
c002db45:	6a 01                	push   $0x1
c002db47:	50                   	push   %eax
c002db48:	e8 03 02 00 00       	call   c002dd50 <free_map_release>
c002db4d:	83 c4 10             	add    $0x10,%esp
  dir_close (dir);
c002db50:	83 ec 0c             	sub    $0xc,%esp
c002db53:	ff 75 f4             	pushl  -0xc(%ebp)
c002db56:	e8 74 07 00 00       	call   c002e2cf <dir_close>
c002db5b:	83 c4 10             	add    $0x10,%esp

  return success;
c002db5e:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002db61:	c9                   	leave  
c002db62:	c3                   	ret    

c002db63 <filesys_open>:
   otherwise.
   Fails if no file named NAME exists,
   or if an internal memory allocation fails. */
struct file *
filesys_open (const char *name)
{
c002db63:	55                   	push   %ebp
c002db64:	89 e5                	mov    %esp,%ebp
c002db66:	83 ec 18             	sub    $0x18,%esp
  struct dir *dir = dir_open_root ();
c002db69:	e8 1b 07 00 00       	call   c002e289 <dir_open_root>
c002db6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct inode *inode = NULL;
c002db71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if (dir != NULL)
c002db78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002db7c:	74 15                	je     c002db93 <filesys_open+0x30>
    dir_lookup (dir, name, &inode);
c002db7e:	83 ec 04             	sub    $0x4,%esp
c002db81:	8d 45 f0             	lea    -0x10(%ebp),%eax
c002db84:	50                   	push   %eax
c002db85:	ff 75 08             	pushl  0x8(%ebp)
c002db88:	ff 75 f4             	pushl  -0xc(%ebp)
c002db8b:	e8 49 08 00 00       	call   c002e3d9 <dir_lookup>
c002db90:	83 c4 10             	add    $0x10,%esp
  dir_close (dir);
c002db93:	83 ec 0c             	sub    $0xc,%esp
c002db96:	ff 75 f4             	pushl  -0xc(%ebp)
c002db99:	e8 31 07 00 00       	call   c002e2cf <dir_close>
c002db9e:	83 c4 10             	add    $0x10,%esp

  return file_open (inode);
c002dba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dba4:	83 ec 0c             	sub    $0xc,%esp
c002dba7:	50                   	push   %eax
c002dba8:	e8 5f 03 00 00       	call   c002df0c <file_open>
c002dbad:	83 c4 10             	add    $0x10,%esp
}
c002dbb0:	c9                   	leave  
c002dbb1:	c3                   	ret    

c002dbb2 <filesys_remove>:
   Returns true if successful, false on failure.
   Fails if no file named NAME exists,
   or if an internal memory allocation fails. */
bool
filesys_remove (const char *name) 
{
c002dbb2:	55                   	push   %ebp
c002dbb3:	89 e5                	mov    %esp,%ebp
c002dbb5:	83 ec 18             	sub    $0x18,%esp
  struct dir *dir = dir_open_root ();
c002dbb8:	e8 cc 06 00 00       	call   c002e289 <dir_open_root>
c002dbbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  bool success = dir != NULL && dir_remove (dir, name);
c002dbc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002dbc4:	74 1c                	je     c002dbe2 <filesys_remove+0x30>
c002dbc6:	83 ec 08             	sub    $0x8,%esp
c002dbc9:	ff 75 08             	pushl  0x8(%ebp)
c002dbcc:	ff 75 f4             	pushl  -0xc(%ebp)
c002dbcf:	e8 ad 09 00 00       	call   c002e581 <dir_remove>
c002dbd4:	83 c4 10             	add    $0x10,%esp
c002dbd7:	84 c0                	test   %al,%al
c002dbd9:	74 07                	je     c002dbe2 <filesys_remove+0x30>
c002dbdb:	b8 01 00 00 00       	mov    $0x1,%eax
c002dbe0:	eb 05                	jmp    c002dbe7 <filesys_remove+0x35>
c002dbe2:	b8 00 00 00 00       	mov    $0x0,%eax
c002dbe7:	88 45 f3             	mov    %al,-0xd(%ebp)
c002dbea:	80 65 f3 01          	andb   $0x1,-0xd(%ebp)
  dir_close (dir); 
c002dbee:	83 ec 0c             	sub    $0xc,%esp
c002dbf1:	ff 75 f4             	pushl  -0xc(%ebp)
c002dbf4:	e8 d6 06 00 00       	call   c002e2cf <dir_close>
c002dbf9:	83 c4 10             	add    $0x10,%esp

  return success;
c002dbfc:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002dbff:	c9                   	leave  
c002dc00:	c3                   	ret    

c002dc01 <do_format>:

/* Formats the file system. */
static void
do_format (void)
{
c002dc01:	55                   	push   %ebp
c002dc02:	89 e5                	mov    %esp,%ebp
c002dc04:	83 ec 08             	sub    $0x8,%esp
  printf ("Formatting file system...");
c002dc07:	83 ec 0c             	sub    $0xc,%esp
c002dc0a:	68 8f 2c 03 c0       	push   $0xc0032c8f
c002dc0f:	e8 9b 97 ff ff       	call   c00273af <printf>
c002dc14:	83 c4 10             	add    $0x10,%esp
  free_map_create ();
c002dc17:	e8 39 02 00 00       	call   c002de55 <free_map_create>
  if (!dir_create (ROOT_DIR_SECTOR, 16))
c002dc1c:	83 ec 08             	sub    $0x8,%esp
c002dc1f:	6a 10                	push   $0x10
c002dc21:	6a 01                	push   $0x1
c002dc23:	e8 df 05 00 00       	call   c002e207 <dir_create>
c002dc28:	83 c4 10             	add    $0x10,%esp
c002dc2b:	83 f0 01             	xor    $0x1,%eax
c002dc2e:	84 c0                	test   %al,%al
c002dc30:	74 16                	je     c002dc48 <do_format+0x47>
    PANIC ("root directory creation failed");
c002dc32:	68 ac 2c 03 c0       	push   $0xc0032cac
c002dc37:	68 e4 2c 03 c0       	push   $0xc0032ce4
c002dc3c:	6a 64                	push   $0x64
c002dc3e:	68 77 2c 03 c0       	push   $0xc0032c77
c002dc43:	e8 26 bb ff ff       	call   c002976e <debug_panic>
  free_map_close ();
c002dc48:	e8 ee 01 00 00       	call   c002de3b <free_map_close>
  printf ("done.\n");
c002dc4d:	83 ec 0c             	sub    $0xc,%esp
c002dc50:	68 cb 2c 03 c0       	push   $0xc0032ccb
c002dc55:	e8 e6 dd ff ff       	call   c002ba40 <puts>
c002dc5a:	83 c4 10             	add    $0x10,%esp
}
c002dc5d:	90                   	nop
c002dc5e:	c9                   	leave  
c002dc5f:	c3                   	ret    

c002dc60 <free_map_init>:
static struct bitmap *free_map;      /* Free map, one bit per sector. */

/* Initializes the free map. */
void
free_map_init (void) 
{
c002dc60:	55                   	push   %ebp
c002dc61:	89 e5                	mov    %esp,%ebp
c002dc63:	83 ec 08             	sub    $0x8,%esp
  free_map = bitmap_create (block_size (fs_device));
c002dc66:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002dc6b:	83 ec 0c             	sub    $0xc,%esp
c002dc6e:	50                   	push   %eax
c002dc6f:	e8 43 75 ff ff       	call   c00251b7 <block_size>
c002dc74:	83 c4 10             	add    $0x10,%esp
c002dc77:	83 ec 0c             	sub    $0xc,%esp
c002dc7a:	50                   	push   %eax
c002dc7b:	e8 65 cb ff ff       	call   c002a7e5 <bitmap_create>
c002dc80:	83 c4 10             	add    $0x10,%esp
c002dc83:	a3 18 a4 03 c0       	mov    %eax,0xc003a418
  if (free_map == NULL)
c002dc88:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dc8d:	85 c0                	test   %eax,%eax
c002dc8f:	75 16                	jne    c002dca7 <free_map_init+0x47>
    PANIC ("bitmap creation failed--file system device is too large");
c002dc91:	68 f0 2c 03 c0       	push   $0xc0032cf0
c002dc96:	68 d4 2d 03 c0       	push   $0xc0032dd4
c002dc9b:	6a 11                	push   $0x11
c002dc9d:	68 28 2d 03 c0       	push   $0xc0032d28
c002dca2:	e8 c7 ba ff ff       	call   c002976e <debug_panic>
  bitmap_mark (free_map, FREE_MAP_SECTOR);
c002dca7:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dcac:	83 ec 08             	sub    $0x8,%esp
c002dcaf:	6a 00                	push   $0x0
c002dcb1:	50                   	push   %eax
c002dcb2:	e8 eb cc ff ff       	call   c002a9a2 <bitmap_mark>
c002dcb7:	83 c4 10             	add    $0x10,%esp
  bitmap_mark (free_map, ROOT_DIR_SECTOR);
c002dcba:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dcbf:	83 ec 08             	sub    $0x8,%esp
c002dcc2:	6a 01                	push   $0x1
c002dcc4:	50                   	push   %eax
c002dcc5:	e8 d8 cc ff ff       	call   c002a9a2 <bitmap_mark>
c002dcca:	83 c4 10             	add    $0x10,%esp
}
c002dccd:	90                   	nop
c002dcce:	c9                   	leave  
c002dccf:	c3                   	ret    

c002dcd0 <free_map_allocate>:
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool
free_map_allocate (size_t cnt, block_sector_t *sectorp)
{
c002dcd0:	55                   	push   %ebp
c002dcd1:	89 e5                	mov    %esp,%ebp
c002dcd3:	83 ec 18             	sub    $0x18,%esp
  block_sector_t sector = bitmap_scan_and_flip (free_map, 0, cnt, false);
c002dcd6:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dcdb:	6a 00                	push   $0x0
c002dcdd:	ff 75 08             	pushl  0x8(%ebp)
c002dce0:	6a 00                	push   $0x0
c002dce2:	50                   	push   %eax
c002dce3:	e8 da d1 ff ff       	call   c002aec2 <bitmap_scan_and_flip>
c002dce8:	83 c4 10             	add    $0x10,%esp
c002dceb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sector != BITMAP_ERROR
c002dcee:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002dcf2:	74 45                	je     c002dd39 <free_map_allocate+0x69>
      && free_map_file != NULL
c002dcf4:	a1 14 a4 03 c0       	mov    0xc003a414,%eax
c002dcf9:	85 c0                	test   %eax,%eax
c002dcfb:	74 3c                	je     c002dd39 <free_map_allocate+0x69>
      && !bitmap_write (free_map, free_map_file))
c002dcfd:	8b 15 14 a4 03 c0    	mov    0xc003a414,%edx
c002dd03:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dd08:	83 ec 08             	sub    $0x8,%esp
c002dd0b:	52                   	push   %edx
c002dd0c:	50                   	push   %eax
c002dd0d:	e8 b3 d2 ff ff       	call   c002afc5 <bitmap_write>
c002dd12:	83 c4 10             	add    $0x10,%esp
c002dd15:	83 f0 01             	xor    $0x1,%eax
c002dd18:	84 c0                	test   %al,%al
c002dd1a:	74 1d                	je     c002dd39 <free_map_allocate+0x69>
    {
      bitmap_set_multiple (free_map, sector, cnt, false); 
c002dd1c:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dd21:	6a 00                	push   $0x0
c002dd23:	ff 75 08             	pushl  0x8(%ebp)
c002dd26:	ff 75 f4             	pushl  -0xc(%ebp)
c002dd29:	50                   	push   %eax
c002dd2a:	e8 06 ce ff ff       	call   c002ab35 <bitmap_set_multiple>
c002dd2f:	83 c4 10             	add    $0x10,%esp
      sector = BITMAP_ERROR;
c002dd32:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
    }
  if (sector != BITMAP_ERROR)
c002dd39:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002dd3d:	74 08                	je     c002dd47 <free_map_allocate+0x77>
    *sectorp = sector;
c002dd3f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002dd42:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002dd45:	89 10                	mov    %edx,(%eax)
  return sector != BITMAP_ERROR;
c002dd47:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002dd4b:	0f 95 c0             	setne  %al
}
c002dd4e:	c9                   	leave  
c002dd4f:	c3                   	ret    

c002dd50 <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void
free_map_release (block_sector_t sector, size_t cnt)
{
c002dd50:	55                   	push   %ebp
c002dd51:	89 e5                	mov    %esp,%ebp
c002dd53:	83 ec 08             	sub    $0x8,%esp
  ASSERT (bitmap_all (free_map, sector, cnt));
c002dd56:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dd5b:	83 ec 04             	sub    $0x4,%esp
c002dd5e:	ff 75 0c             	pushl  0xc(%ebp)
c002dd61:	ff 75 08             	pushl  0x8(%ebp)
c002dd64:	50                   	push   %eax
c002dd65:	e8 6c d0 ff ff       	call   c002add6 <bitmap_all>
c002dd6a:	83 c4 10             	add    $0x10,%esp
c002dd6d:	84 c0                	test   %al,%al
c002dd6f:	75 1e                	jne    c002dd8f <free_map_release+0x3f>
c002dd71:	83 ec 0c             	sub    $0xc,%esp
c002dd74:	68 44 2d 03 c0       	push   $0xc0032d44
c002dd79:	68 67 2d 03 c0       	push   $0xc0032d67
c002dd7e:	68 e4 2d 03 c0       	push   $0xc0032de4
c002dd83:	6a 2f                	push   $0x2f
c002dd85:	68 28 2d 03 c0       	push   $0xc0032d28
c002dd8a:	e8 df b9 ff ff       	call   c002976e <debug_panic>
  bitmap_set_multiple (free_map, sector, cnt, false);
c002dd8f:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dd94:	6a 00                	push   $0x0
c002dd96:	ff 75 0c             	pushl  0xc(%ebp)
c002dd99:	ff 75 08             	pushl  0x8(%ebp)
c002dd9c:	50                   	push   %eax
c002dd9d:	e8 93 cd ff ff       	call   c002ab35 <bitmap_set_multiple>
c002dda2:	83 c4 10             	add    $0x10,%esp
  bitmap_write (free_map, free_map_file);
c002dda5:	8b 15 14 a4 03 c0    	mov    0xc003a414,%edx
c002ddab:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002ddb0:	83 ec 08             	sub    $0x8,%esp
c002ddb3:	52                   	push   %edx
c002ddb4:	50                   	push   %eax
c002ddb5:	e8 0b d2 ff ff       	call   c002afc5 <bitmap_write>
c002ddba:	83 c4 10             	add    $0x10,%esp
}
c002ddbd:	90                   	nop
c002ddbe:	c9                   	leave  
c002ddbf:	c3                   	ret    

c002ddc0 <free_map_open>:

/* Opens the free map file and reads it from disk. */
void
free_map_open (void) 
{
c002ddc0:	55                   	push   %ebp
c002ddc1:	89 e5                	mov    %esp,%ebp
c002ddc3:	83 ec 08             	sub    $0x8,%esp
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002ddc6:	83 ec 0c             	sub    $0xc,%esp
c002ddc9:	6a 00                	push   $0x0
c002ddcb:	e8 71 0a 00 00       	call   c002e841 <inode_open>
c002ddd0:	83 c4 10             	add    $0x10,%esp
c002ddd3:	83 ec 0c             	sub    $0xc,%esp
c002ddd6:	50                   	push   %eax
c002ddd7:	e8 30 01 00 00       	call   c002df0c <file_open>
c002dddc:	83 c4 10             	add    $0x10,%esp
c002dddf:	a3 14 a4 03 c0       	mov    %eax,0xc003a414
  if (free_map_file == NULL)
c002dde4:	a1 14 a4 03 c0       	mov    0xc003a414,%eax
c002dde9:	85 c0                	test   %eax,%eax
c002ddeb:	75 16                	jne    c002de03 <free_map_open+0x43>
    PANIC ("can't open free map");
c002dded:	68 7e 2d 03 c0       	push   $0xc0032d7e
c002ddf2:	68 f8 2d 03 c0       	push   $0xc0032df8
c002ddf7:	6a 3a                	push   $0x3a
c002ddf9:	68 28 2d 03 c0       	push   $0xc0032d28
c002ddfe:	e8 6b b9 ff ff       	call   c002976e <debug_panic>
  if (!bitmap_read (free_map, free_map_file))
c002de03:	8b 15 14 a4 03 c0    	mov    0xc003a414,%edx
c002de09:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002de0e:	83 ec 08             	sub    $0x8,%esp
c002de11:	52                   	push   %edx
c002de12:	50                   	push   %eax
c002de13:	e8 14 d1 ff ff       	call   c002af2c <bitmap_read>
c002de18:	83 c4 10             	add    $0x10,%esp
c002de1b:	83 f0 01             	xor    $0x1,%eax
c002de1e:	84 c0                	test   %al,%al
c002de20:	74 16                	je     c002de38 <free_map_open+0x78>
    PANIC ("can't read free map");
c002de22:	68 92 2d 03 c0       	push   $0xc0032d92
c002de27:	68 f8 2d 03 c0       	push   $0xc0032df8
c002de2c:	6a 3c                	push   $0x3c
c002de2e:	68 28 2d 03 c0       	push   $0xc0032d28
c002de33:	e8 36 b9 ff ff       	call   c002976e <debug_panic>
}
c002de38:	90                   	nop
c002de39:	c9                   	leave  
c002de3a:	c3                   	ret    

c002de3b <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void
free_map_close (void) 
{
c002de3b:	55                   	push   %ebp
c002de3c:	89 e5                	mov    %esp,%ebp
c002de3e:	83 ec 08             	sub    $0x8,%esp
  file_close (free_map_file);
c002de41:	a1 14 a4 03 c0       	mov    0xc003a414,%eax
c002de46:	83 ec 0c             	sub    $0xc,%esp
c002de49:	50                   	push   %eax
c002de4a:	e8 47 01 00 00       	call   c002df96 <file_close>
c002de4f:	83 c4 10             	add    $0x10,%esp
}
c002de52:	90                   	nop
c002de53:	c9                   	leave  
c002de54:	c3                   	ret    

c002de55 <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void
free_map_create (void) 
{
c002de55:	55                   	push   %ebp
c002de56:	89 e5                	mov    %esp,%ebp
c002de58:	83 ec 08             	sub    $0x8,%esp
  /* Create inode. */
  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map)))
c002de5b:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002de60:	83 ec 0c             	sub    $0xc,%esp
c002de63:	50                   	push   %eax
c002de64:	e8 b0 d0 ff ff       	call   c002af19 <bitmap_file_size>
c002de69:	83 c4 10             	add    $0x10,%esp
c002de6c:	83 ec 08             	sub    $0x8,%esp
c002de6f:	50                   	push   %eax
c002de70:	6a 00                	push   $0x0
c002de72:	e8 d3 08 00 00       	call   c002e74a <inode_create>
c002de77:	83 c4 10             	add    $0x10,%esp
c002de7a:	83 f0 01             	xor    $0x1,%eax
c002de7d:	84 c0                	test   %al,%al
c002de7f:	74 16                	je     c002de97 <free_map_create+0x42>
    PANIC ("free map creation failed");
c002de81:	68 a6 2d 03 c0       	push   $0xc0032da6
c002de86:	68 08 2e 03 c0       	push   $0xc0032e08
c002de8b:	6a 4d                	push   $0x4d
c002de8d:	68 28 2d 03 c0       	push   $0xc0032d28
c002de92:	e8 d7 b8 ff ff       	call   c002976e <debug_panic>

  /* Write bitmap to file. */
  free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
c002de97:	83 ec 0c             	sub    $0xc,%esp
c002de9a:	6a 00                	push   $0x0
c002de9c:	e8 a0 09 00 00       	call   c002e841 <inode_open>
c002dea1:	83 c4 10             	add    $0x10,%esp
c002dea4:	83 ec 0c             	sub    $0xc,%esp
c002dea7:	50                   	push   %eax
c002dea8:	e8 5f 00 00 00       	call   c002df0c <file_open>
c002dead:	83 c4 10             	add    $0x10,%esp
c002deb0:	a3 14 a4 03 c0       	mov    %eax,0xc003a414
  if (free_map_file == NULL)
c002deb5:	a1 14 a4 03 c0       	mov    0xc003a414,%eax
c002deba:	85 c0                	test   %eax,%eax
c002debc:	75 16                	jne    c002ded4 <free_map_create+0x7f>
    PANIC ("can't open free map");
c002debe:	68 7e 2d 03 c0       	push   $0xc0032d7e
c002dec3:	68 08 2e 03 c0       	push   $0xc0032e08
c002dec8:	6a 52                	push   $0x52
c002deca:	68 28 2d 03 c0       	push   $0xc0032d28
c002decf:	e8 9a b8 ff ff       	call   c002976e <debug_panic>
  if (!bitmap_write (free_map, free_map_file))
c002ded4:	8b 15 14 a4 03 c0    	mov    0xc003a414,%edx
c002deda:	a1 18 a4 03 c0       	mov    0xc003a418,%eax
c002dedf:	83 ec 08             	sub    $0x8,%esp
c002dee2:	52                   	push   %edx
c002dee3:	50                   	push   %eax
c002dee4:	e8 dc d0 ff ff       	call   c002afc5 <bitmap_write>
c002dee9:	83 c4 10             	add    $0x10,%esp
c002deec:	83 f0 01             	xor    $0x1,%eax
c002deef:	84 c0                	test   %al,%al
c002def1:	74 16                	je     c002df09 <free_map_create+0xb4>
    PANIC ("can't write free map");
c002def3:	68 bf 2d 03 c0       	push   $0xc0032dbf
c002def8:	68 08 2e 03 c0       	push   $0xc0032e08
c002defd:	6a 54                	push   $0x54
c002deff:	68 28 2d 03 c0       	push   $0xc0032d28
c002df04:	e8 65 b8 ff ff       	call   c002976e <debug_panic>
}
c002df09:	90                   	nop
c002df0a:	c9                   	leave  
c002df0b:	c3                   	ret    

c002df0c <file_open>:
/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open (struct inode *inode) 
{
c002df0c:	55                   	push   %ebp
c002df0d:	89 e5                	mov    %esp,%ebp
c002df0f:	83 ec 18             	sub    $0x18,%esp
  struct file *file = calloc (1, sizeof *file);
c002df12:	83 ec 08             	sub    $0x8,%esp
c002df15:	6a 0c                	push   $0xc
c002df17:	6a 01                	push   $0x1
c002df19:	e8 3d 59 ff ff       	call   c002385b <calloc>
c002df1e:	83 c4 10             	add    $0x10,%esp
c002df21:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (inode != NULL && file != NULL)
c002df24:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002df28:	74 24                	je     c002df4e <file_open+0x42>
c002df2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002df2e:	74 1e                	je     c002df4e <file_open+0x42>
    {
      file->inode = inode;
c002df30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df33:	8b 55 08             	mov    0x8(%ebp),%edx
c002df36:	89 10                	mov    %edx,(%eax)
      file->pos = 0;
c002df38:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df3b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      file->deny_write = false;
c002df42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df45:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      return file;
c002df49:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002df4c:	eb 21                	jmp    c002df6f <file_open+0x63>
    }
  else
    {
      inode_close (inode);
c002df4e:	83 ec 0c             	sub    $0xc,%esp
c002df51:	ff 75 08             	pushl  0x8(%ebp)
c002df54:	e8 fa 09 00 00       	call   c002e953 <inode_close>
c002df59:	83 c4 10             	add    $0x10,%esp
      free (file);
c002df5c:	83 ec 0c             	sub    $0xc,%esp
c002df5f:	ff 75 f4             	pushl  -0xc(%ebp)
c002df62:	e8 25 5a ff ff       	call   c002398c <free>
c002df67:	83 c4 10             	add    $0x10,%esp
      return NULL; 
c002df6a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c002df6f:	c9                   	leave  
c002df70:	c3                   	ret    

c002df71 <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen (struct file *file) 
{
c002df71:	55                   	push   %ebp
c002df72:	89 e5                	mov    %esp,%ebp
c002df74:	83 ec 08             	sub    $0x8,%esp
  return file_open (inode_reopen (file->inode));
c002df77:	8b 45 08             	mov    0x8(%ebp),%eax
c002df7a:	8b 00                	mov    (%eax),%eax
c002df7c:	83 ec 0c             	sub    $0xc,%esp
c002df7f:	50                   	push   %eax
c002df80:	e8 a6 09 00 00       	call   c002e92b <inode_reopen>
c002df85:	83 c4 10             	add    $0x10,%esp
c002df88:	83 ec 0c             	sub    $0xc,%esp
c002df8b:	50                   	push   %eax
c002df8c:	e8 7b ff ff ff       	call   c002df0c <file_open>
c002df91:	83 c4 10             	add    $0x10,%esp
}
c002df94:	c9                   	leave  
c002df95:	c3                   	ret    

c002df96 <file_close>:

/* Closes FILE. */
void
file_close (struct file *file) 
{
c002df96:	55                   	push   %ebp
c002df97:	89 e5                	mov    %esp,%ebp
c002df99:	83 ec 08             	sub    $0x8,%esp
  if (file != NULL)
c002df9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002dfa0:	74 2d                	je     c002dfcf <file_close+0x39>
    {
      file_allow_write (file);
c002dfa2:	83 ec 0c             	sub    $0xc,%esp
c002dfa5:	ff 75 08             	pushl  0x8(%ebp)
c002dfa8:	e8 33 01 00 00       	call   c002e0e0 <file_allow_write>
c002dfad:	83 c4 10             	add    $0x10,%esp
      inode_close (file->inode);
c002dfb0:	8b 45 08             	mov    0x8(%ebp),%eax
c002dfb3:	8b 00                	mov    (%eax),%eax
c002dfb5:	83 ec 0c             	sub    $0xc,%esp
c002dfb8:	50                   	push   %eax
c002dfb9:	e8 95 09 00 00       	call   c002e953 <inode_close>
c002dfbe:	83 c4 10             	add    $0x10,%esp
      free (file); 
c002dfc1:	83 ec 0c             	sub    $0xc,%esp
c002dfc4:	ff 75 08             	pushl  0x8(%ebp)
c002dfc7:	e8 c0 59 ff ff       	call   c002398c <free>
c002dfcc:	83 c4 10             	add    $0x10,%esp
    }
}
c002dfcf:	90                   	nop
c002dfd0:	c9                   	leave  
c002dfd1:	c3                   	ret    

c002dfd2 <file_get_inode>:

/* Returns the inode encapsulated by FILE. */
struct inode *
file_get_inode (struct file *file) 
{
c002dfd2:	55                   	push   %ebp
c002dfd3:	89 e5                	mov    %esp,%ebp
  return file->inode;
c002dfd5:	8b 45 08             	mov    0x8(%ebp),%eax
c002dfd8:	8b 00                	mov    (%eax),%eax
}
c002dfda:	5d                   	pop    %ebp
c002dfdb:	c3                   	ret    

c002dfdc <file_read>:
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   Advances FILE's position by the number of bytes read. */
off_t
file_read (struct file *file, void *buffer, off_t size) 
{
c002dfdc:	55                   	push   %ebp
c002dfdd:	89 e5                	mov    %esp,%ebp
c002dfdf:	83 ec 18             	sub    $0x18,%esp
  off_t bytes_read = inode_read_at (file->inode, buffer, size, file->pos);
c002dfe2:	8b 45 08             	mov    0x8(%ebp),%eax
c002dfe5:	8b 50 04             	mov    0x4(%eax),%edx
c002dfe8:	8b 45 08             	mov    0x8(%ebp),%eax
c002dfeb:	8b 00                	mov    (%eax),%eax
c002dfed:	52                   	push   %edx
c002dfee:	ff 75 10             	pushl  0x10(%ebp)
c002dff1:	ff 75 0c             	pushl  0xc(%ebp)
c002dff4:	50                   	push   %eax
c002dff5:	e8 1c 0a 00 00       	call   c002ea16 <inode_read_at>
c002dffa:	83 c4 10             	add    $0x10,%esp
c002dffd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  file->pos += bytes_read;
c002e000:	8b 45 08             	mov    0x8(%ebp),%eax
c002e003:	8b 50 04             	mov    0x4(%eax),%edx
c002e006:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e009:	01 c2                	add    %eax,%edx
c002e00b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e00e:	89 50 04             	mov    %edx,0x4(%eax)
  return bytes_read;
c002e011:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002e014:	c9                   	leave  
c002e015:	c3                   	ret    

c002e016 <file_read_at>:
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   The file's current position is unaffected. */
off_t
file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs) 
{
c002e016:	55                   	push   %ebp
c002e017:	89 e5                	mov    %esp,%ebp
c002e019:	83 ec 08             	sub    $0x8,%esp
  return inode_read_at (file->inode, buffer, size, file_ofs);
c002e01c:	8b 45 08             	mov    0x8(%ebp),%eax
c002e01f:	8b 00                	mov    (%eax),%eax
c002e021:	ff 75 14             	pushl  0x14(%ebp)
c002e024:	ff 75 10             	pushl  0x10(%ebp)
c002e027:	ff 75 0c             	pushl  0xc(%ebp)
c002e02a:	50                   	push   %eax
c002e02b:	e8 e6 09 00 00       	call   c002ea16 <inode_read_at>
c002e030:	83 c4 10             	add    $0x10,%esp
}
c002e033:	c9                   	leave  
c002e034:	c3                   	ret    

c002e035 <file_write>:
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   Advances FILE's position by the number of bytes read. */
off_t
file_write (struct file *file, const void *buffer, off_t size) 
{
c002e035:	55                   	push   %ebp
c002e036:	89 e5                	mov    %esp,%ebp
c002e038:	83 ec 18             	sub    $0x18,%esp
  off_t bytes_written = inode_write_at (file->inode, buffer, size, file->pos);
c002e03b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e03e:	8b 50 04             	mov    0x4(%eax),%edx
c002e041:	8b 45 08             	mov    0x8(%ebp),%eax
c002e044:	8b 00                	mov    (%eax),%eax
c002e046:	52                   	push   %edx
c002e047:	ff 75 10             	pushl  0x10(%ebp)
c002e04a:	ff 75 0c             	pushl  0xc(%ebp)
c002e04d:	50                   	push   %eax
c002e04e:	e8 11 0b 00 00       	call   c002eb64 <inode_write_at>
c002e053:	83 c4 10             	add    $0x10,%esp
c002e056:	89 45 f4             	mov    %eax,-0xc(%ebp)
  file->pos += bytes_written;
c002e059:	8b 45 08             	mov    0x8(%ebp),%eax
c002e05c:	8b 50 04             	mov    0x4(%eax),%edx
c002e05f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e062:	01 c2                	add    %eax,%edx
c002e064:	8b 45 08             	mov    0x8(%ebp),%eax
c002e067:	89 50 04             	mov    %edx,0x4(%eax)
  return bytes_written;
c002e06a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002e06d:	c9                   	leave  
c002e06e:	c3                   	ret    

c002e06f <file_write_at>:
   not yet implemented.)
   The file's current position is unaffected. */
off_t
file_write_at (struct file *file, const void *buffer, off_t size,
               off_t file_ofs) 
{
c002e06f:	55                   	push   %ebp
c002e070:	89 e5                	mov    %esp,%ebp
c002e072:	83 ec 08             	sub    $0x8,%esp
  return inode_write_at (file->inode, buffer, size, file_ofs);
c002e075:	8b 45 08             	mov    0x8(%ebp),%eax
c002e078:	8b 00                	mov    (%eax),%eax
c002e07a:	ff 75 14             	pushl  0x14(%ebp)
c002e07d:	ff 75 10             	pushl  0x10(%ebp)
c002e080:	ff 75 0c             	pushl  0xc(%ebp)
c002e083:	50                   	push   %eax
c002e084:	e8 db 0a 00 00       	call   c002eb64 <inode_write_at>
c002e089:	83 c4 10             	add    $0x10,%esp
}
c002e08c:	c9                   	leave  
c002e08d:	c3                   	ret    

c002e08e <file_deny_write>:

/* Prevents write operations on FILE's underlying inode
   until file_allow_write() is called or FILE is closed. */
void
file_deny_write (struct file *file) 
{
c002e08e:	55                   	push   %ebp
c002e08f:	89 e5                	mov    %esp,%ebp
c002e091:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e094:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e098:	75 1e                	jne    c002e0b8 <file_deny_write+0x2a>
c002e09a:	83 ec 0c             	sub    $0xc,%esp
c002e09d:	68 18 2e 03 c0       	push   $0xc0032e18
c002e0a2:	68 25 2e 03 c0       	push   $0xc0032e25
c002e0a7:	68 60 2e 03 c0       	push   $0xc0032e60
c002e0ac:	6a 79                	push   $0x79
c002e0ae:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002e0b3:	e8 b6 b6 ff ff       	call   c002976e <debug_panic>
  if (!file->deny_write) 
c002e0b8:	8b 45 08             	mov    0x8(%ebp),%eax
c002e0bb:	8a 40 08             	mov    0x8(%eax),%al
c002e0be:	83 f0 01             	xor    $0x1,%eax
c002e0c1:	84 c0                	test   %al,%al
c002e0c3:	74 18                	je     c002e0dd <file_deny_write+0x4f>
    {
      file->deny_write = true;
c002e0c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002e0c8:	c6 40 08 01          	movb   $0x1,0x8(%eax)
      inode_deny_write (file->inode);
c002e0cc:	8b 45 08             	mov    0x8(%ebp),%eax
c002e0cf:	8b 00                	mov    (%eax),%eax
c002e0d1:	83 ec 0c             	sub    $0xc,%esp
c002e0d4:	50                   	push   %eax
c002e0d5:	e8 2e 0c 00 00       	call   c002ed08 <inode_deny_write>
c002e0da:	83 c4 10             	add    $0x10,%esp
    }
}
c002e0dd:	90                   	nop
c002e0de:	c9                   	leave  
c002e0df:	c3                   	ret    

c002e0e0 <file_allow_write>:
/* Re-enables write operations on FILE's underlying inode.
   (Writes might still be denied by some other file that has the
   same inode open.) */
void
file_allow_write (struct file *file) 
{
c002e0e0:	55                   	push   %ebp
c002e0e1:	89 e5                	mov    %esp,%ebp
c002e0e3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e0e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e0ea:	75 21                	jne    c002e10d <file_allow_write+0x2d>
c002e0ec:	83 ec 0c             	sub    $0xc,%esp
c002e0ef:	68 18 2e 03 c0       	push   $0xc0032e18
c002e0f4:	68 25 2e 03 c0       	push   $0xc0032e25
c002e0f9:	68 70 2e 03 c0       	push   $0xc0032e70
c002e0fe:	68 87 00 00 00       	push   $0x87
c002e103:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002e108:	e8 61 b6 ff ff       	call   c002976e <debug_panic>
  if (file->deny_write) 
c002e10d:	8b 45 08             	mov    0x8(%ebp),%eax
c002e110:	8a 40 08             	mov    0x8(%eax),%al
c002e113:	84 c0                	test   %al,%al
c002e115:	74 18                	je     c002e12f <file_allow_write+0x4f>
    {
      file->deny_write = false;
c002e117:	8b 45 08             	mov    0x8(%ebp),%eax
c002e11a:	c6 40 08 00          	movb   $0x0,0x8(%eax)
      inode_allow_write (file->inode);
c002e11e:	8b 45 08             	mov    0x8(%ebp),%eax
c002e121:	8b 00                	mov    (%eax),%eax
c002e123:	83 ec 0c             	sub    $0xc,%esp
c002e126:	50                   	push   %eax
c002e127:	e8 25 0c 00 00       	call   c002ed51 <inode_allow_write>
c002e12c:	83 c4 10             	add    $0x10,%esp
    }
}
c002e12f:	90                   	nop
c002e130:	c9                   	leave  
c002e131:	c3                   	ret    

c002e132 <file_length>:

/* Returns the size of FILE in bytes. */
off_t
file_length (struct file *file) 
{
c002e132:	55                   	push   %ebp
c002e133:	89 e5                	mov    %esp,%ebp
c002e135:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e138:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e13c:	75 21                	jne    c002e15f <file_length+0x2d>
c002e13e:	83 ec 0c             	sub    $0xc,%esp
c002e141:	68 18 2e 03 c0       	push   $0xc0032e18
c002e146:	68 25 2e 03 c0       	push   $0xc0032e25
c002e14b:	68 84 2e 03 c0       	push   $0xc0032e84
c002e150:	68 93 00 00 00       	push   $0x93
c002e155:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002e15a:	e8 0f b6 ff ff       	call   c002976e <debug_panic>
  return inode_length (file->inode);
c002e15f:	8b 45 08             	mov    0x8(%ebp),%eax
c002e162:	8b 00                	mov    (%eax),%eax
c002e164:	83 ec 0c             	sub    $0xc,%esp
c002e167:	50                   	push   %eax
c002e168:	e8 58 0c 00 00       	call   c002edc5 <inode_length>
c002e16d:	83 c4 10             	add    $0x10,%esp
}
c002e170:	c9                   	leave  
c002e171:	c3                   	ret    

c002e172 <file_seek>:

/* Sets the current position in FILE to NEW_POS bytes from the
   start of the file. */
void
file_seek (struct file *file, off_t new_pos)
{
c002e172:	55                   	push   %ebp
c002e173:	89 e5                	mov    %esp,%ebp
c002e175:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e178:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e17c:	75 21                	jne    c002e19f <file_seek+0x2d>
c002e17e:	83 ec 0c             	sub    $0xc,%esp
c002e181:	68 18 2e 03 c0       	push   $0xc0032e18
c002e186:	68 25 2e 03 c0       	push   $0xc0032e25
c002e18b:	68 90 2e 03 c0       	push   $0xc0032e90
c002e190:	68 9c 00 00 00       	push   $0x9c
c002e195:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002e19a:	e8 cf b5 ff ff       	call   c002976e <debug_panic>
  ASSERT (new_pos >= 0);
c002e19f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002e1a3:	79 21                	jns    c002e1c6 <file_seek+0x54>
c002e1a5:	83 ec 0c             	sub    $0xc,%esp
c002e1a8:	68 51 2e 03 c0       	push   $0xc0032e51
c002e1ad:	68 25 2e 03 c0       	push   $0xc0032e25
c002e1b2:	68 90 2e 03 c0       	push   $0xc0032e90
c002e1b7:	68 9d 00 00 00       	push   $0x9d
c002e1bc:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002e1c1:	e8 a8 b5 ff ff       	call   c002976e <debug_panic>
  file->pos = new_pos;
c002e1c6:	8b 45 08             	mov    0x8(%ebp),%eax
c002e1c9:	8b 55 0c             	mov    0xc(%ebp),%edx
c002e1cc:	89 50 04             	mov    %edx,0x4(%eax)
}
c002e1cf:	90                   	nop
c002e1d0:	c9                   	leave  
c002e1d1:	c3                   	ret    

c002e1d2 <file_tell>:

/* Returns the current position in FILE as a byte offset from the
   start of the file. */
off_t
file_tell (struct file *file) 
{
c002e1d2:	55                   	push   %ebp
c002e1d3:	89 e5                	mov    %esp,%ebp
c002e1d5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (file != NULL);
c002e1d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e1dc:	75 21                	jne    c002e1ff <file_tell+0x2d>
c002e1de:	83 ec 0c             	sub    $0xc,%esp
c002e1e1:	68 18 2e 03 c0       	push   $0xc0032e18
c002e1e6:	68 25 2e 03 c0       	push   $0xc0032e25
c002e1eb:	68 9c 2e 03 c0       	push   $0xc0032e9c
c002e1f0:	68 a6 00 00 00       	push   $0xa6
c002e1f5:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002e1fa:	e8 6f b5 ff ff       	call   c002976e <debug_panic>
  return file->pos;
c002e1ff:	8b 45 08             	mov    0x8(%ebp),%eax
c002e202:	8b 40 04             	mov    0x4(%eax),%eax
}
c002e205:	c9                   	leave  
c002e206:	c3                   	ret    

c002e207 <dir_create>:

/* Creates a directory with space for ENTRY_CNT entries in the
   given SECTOR.  Returns true if successful, false on failure. */
bool
dir_create (block_sector_t sector, size_t entry_cnt)
{
c002e207:	55                   	push   %ebp
c002e208:	89 e5                	mov    %esp,%ebp
c002e20a:	83 ec 08             	sub    $0x8,%esp
  return inode_create (sector, entry_cnt * sizeof (struct dir_entry));
c002e20d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002e210:	89 d0                	mov    %edx,%eax
c002e212:	c1 e0 02             	shl    $0x2,%eax
c002e215:	01 d0                	add    %edx,%eax
c002e217:	c1 e0 02             	shl    $0x2,%eax
c002e21a:	83 ec 08             	sub    $0x8,%esp
c002e21d:	50                   	push   %eax
c002e21e:	ff 75 08             	pushl  0x8(%ebp)
c002e221:	e8 24 05 00 00       	call   c002e74a <inode_create>
c002e226:	83 c4 10             	add    $0x10,%esp
}
c002e229:	c9                   	leave  
c002e22a:	c3                   	ret    

c002e22b <dir_open>:

/* Opens and returns the directory for the given INODE, of which
   it takes ownership.  Returns a null pointer on failure. */
struct dir *
dir_open (struct inode *inode) 
{
c002e22b:	55                   	push   %ebp
c002e22c:	89 e5                	mov    %esp,%ebp
c002e22e:	83 ec 18             	sub    $0x18,%esp
  struct dir *dir = calloc (1, sizeof *dir);
c002e231:	83 ec 08             	sub    $0x8,%esp
c002e234:	6a 08                	push   $0x8
c002e236:	6a 01                	push   $0x1
c002e238:	e8 1e 56 ff ff       	call   c002385b <calloc>
c002e23d:	83 c4 10             	add    $0x10,%esp
c002e240:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (inode != NULL && dir != NULL)
c002e243:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e247:	74 1d                	je     c002e266 <dir_open+0x3b>
c002e249:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002e24d:	74 17                	je     c002e266 <dir_open+0x3b>
    {
      dir->inode = inode;
c002e24f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e252:	8b 55 08             	mov    0x8(%ebp),%edx
c002e255:	89 10                	mov    %edx,(%eax)
      dir->pos = 0;
c002e257:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e25a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      return dir;
c002e261:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e264:	eb 21                	jmp    c002e287 <dir_open+0x5c>
    }
  else
    {
      inode_close (inode);
c002e266:	83 ec 0c             	sub    $0xc,%esp
c002e269:	ff 75 08             	pushl  0x8(%ebp)
c002e26c:	e8 e2 06 00 00       	call   c002e953 <inode_close>
c002e271:	83 c4 10             	add    $0x10,%esp
      free (dir);
c002e274:	83 ec 0c             	sub    $0xc,%esp
c002e277:	ff 75 f4             	pushl  -0xc(%ebp)
c002e27a:	e8 0d 57 ff ff       	call   c002398c <free>
c002e27f:	83 c4 10             	add    $0x10,%esp
      return NULL; 
c002e282:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c002e287:	c9                   	leave  
c002e288:	c3                   	ret    

c002e289 <dir_open_root>:

/* Opens the root directory and returns a directory for it.
   Return true if successful, false on failure. */
struct dir *
dir_open_root (void)
{
c002e289:	55                   	push   %ebp
c002e28a:	89 e5                	mov    %esp,%ebp
c002e28c:	83 ec 08             	sub    $0x8,%esp
  return dir_open (inode_open (ROOT_DIR_SECTOR));
c002e28f:	83 ec 0c             	sub    $0xc,%esp
c002e292:	6a 01                	push   $0x1
c002e294:	e8 a8 05 00 00       	call   c002e841 <inode_open>
c002e299:	83 c4 10             	add    $0x10,%esp
c002e29c:	83 ec 0c             	sub    $0xc,%esp
c002e29f:	50                   	push   %eax
c002e2a0:	e8 86 ff ff ff       	call   c002e22b <dir_open>
c002e2a5:	83 c4 10             	add    $0x10,%esp
}
c002e2a8:	c9                   	leave  
c002e2a9:	c3                   	ret    

c002e2aa <dir_reopen>:

/* Opens and returns a new directory for the same inode as DIR.
   Returns a null pointer on failure. */
struct dir *
dir_reopen (struct dir *dir) 
{
c002e2aa:	55                   	push   %ebp
c002e2ab:	89 e5                	mov    %esp,%ebp
c002e2ad:	83 ec 08             	sub    $0x8,%esp
  return dir_open (inode_reopen (dir->inode));
c002e2b0:	8b 45 08             	mov    0x8(%ebp),%eax
c002e2b3:	8b 00                	mov    (%eax),%eax
c002e2b5:	83 ec 0c             	sub    $0xc,%esp
c002e2b8:	50                   	push   %eax
c002e2b9:	e8 6d 06 00 00       	call   c002e92b <inode_reopen>
c002e2be:	83 c4 10             	add    $0x10,%esp
c002e2c1:	83 ec 0c             	sub    $0xc,%esp
c002e2c4:	50                   	push   %eax
c002e2c5:	e8 61 ff ff ff       	call   c002e22b <dir_open>
c002e2ca:	83 c4 10             	add    $0x10,%esp
}
c002e2cd:	c9                   	leave  
c002e2ce:	c3                   	ret    

c002e2cf <dir_close>:

/* Destroys DIR and frees associated resources. */
void
dir_close (struct dir *dir) 
{
c002e2cf:	55                   	push   %ebp
c002e2d0:	89 e5                	mov    %esp,%ebp
c002e2d2:	83 ec 08             	sub    $0x8,%esp
  if (dir != NULL)
c002e2d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e2d9:	74 1f                	je     c002e2fa <dir_close+0x2b>
    {
      inode_close (dir->inode);
c002e2db:	8b 45 08             	mov    0x8(%ebp),%eax
c002e2de:	8b 00                	mov    (%eax),%eax
c002e2e0:	83 ec 0c             	sub    $0xc,%esp
c002e2e3:	50                   	push   %eax
c002e2e4:	e8 6a 06 00 00       	call   c002e953 <inode_close>
c002e2e9:	83 c4 10             	add    $0x10,%esp
      free (dir);
c002e2ec:	83 ec 0c             	sub    $0xc,%esp
c002e2ef:	ff 75 08             	pushl  0x8(%ebp)
c002e2f2:	e8 95 56 ff ff       	call   c002398c <free>
c002e2f7:	83 c4 10             	add    $0x10,%esp
    }
}
c002e2fa:	90                   	nop
c002e2fb:	c9                   	leave  
c002e2fc:	c3                   	ret    

c002e2fd <dir_get_inode>:

/* Returns the inode encapsulated by DIR. */
struct inode *
dir_get_inode (struct dir *dir) 
{
c002e2fd:	55                   	push   %ebp
c002e2fe:	89 e5                	mov    %esp,%ebp
  return dir->inode;
c002e300:	8b 45 08             	mov    0x8(%ebp),%eax
c002e303:	8b 00                	mov    (%eax),%eax
}
c002e305:	5d                   	pop    %ebp
c002e306:	c3                   	ret    

c002e307 <lookup>:
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup (const struct dir *dir, const char *name,
        struct dir_entry *ep, off_t *ofsp) 
{
c002e307:	55                   	push   %ebp
c002e308:	89 e5                	mov    %esp,%ebp
c002e30a:	57                   	push   %edi
c002e30b:	56                   	push   %esi
c002e30c:	53                   	push   %ebx
c002e30d:	83 ec 2c             	sub    $0x2c,%esp
  struct dir_entry e;
  size_t ofs;
  
  ASSERT (dir != NULL);
c002e310:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e314:	75 1e                	jne    c002e334 <lookup+0x2d>
c002e316:	83 ec 0c             	sub    $0xc,%esp
c002e319:	68 a8 2e 03 c0       	push   $0xc0032ea8
c002e31e:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e323:	68 f4 2e 03 c0       	push   $0xc0032ef4
c002e328:	6a 62                	push   $0x62
c002e32a:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e32f:	e8 3a b4 ff ff       	call   c002976e <debug_panic>
  ASSERT (name != NULL);
c002e334:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002e338:	75 1e                	jne    c002e358 <lookup+0x51>
c002e33a:	83 ec 0c             	sub    $0xc,%esp
c002e33d:	68 e5 2e 03 c0       	push   $0xc0032ee5
c002e342:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e347:	68 f4 2e 03 c0       	push   $0xc0032ef4
c002e34c:	6a 63                	push   $0x63
c002e34e:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e353:	e8 16 b4 ff ff       	call   c002976e <debug_panic>

  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e358:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c002e35f:	eb 51                	jmp    c002e3b2 <lookup+0xab>
       ofs += sizeof e) 
    if (e.in_use && !strcmp (name, e.name)) 
c002e361:	8a 45 e3             	mov    -0x1d(%ebp),%al
c002e364:	84 c0                	test   %al,%al
c002e366:	74 46                	je     c002e3ae <lookup+0xa7>
c002e368:	83 ec 08             	sub    $0x8,%esp
c002e36b:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e36e:	83 c0 04             	add    $0x4,%eax
c002e371:	50                   	push   %eax
c002e372:	ff 75 0c             	pushl  0xc(%ebp)
c002e375:	e8 31 a4 ff ff       	call   c00287ab <strcmp>
c002e37a:	83 c4 10             	add    $0x10,%esp
c002e37d:	85 c0                	test   %eax,%eax
c002e37f:	75 2d                	jne    c002e3ae <lookup+0xa7>
      {
        if (ep != NULL)
c002e381:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e385:	74 15                	je     c002e39c <lookup+0x95>
          *ep = e;
c002e387:	8b 45 10             	mov    0x10(%ebp),%eax
c002e38a:	89 c3                	mov    %eax,%ebx
c002e38c:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e38f:	ba 05 00 00 00       	mov    $0x5,%edx
c002e394:	89 df                	mov    %ebx,%edi
c002e396:	89 c6                	mov    %eax,%esi
c002e398:	89 d1                	mov    %edx,%ecx
c002e39a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        if (ofsp != NULL)
c002e39c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002e3a0:	74 08                	je     c002e3aa <lookup+0xa3>
          *ofsp = ofs;
c002e3a2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e3a5:	8b 45 14             	mov    0x14(%ebp),%eax
c002e3a8:	89 10                	mov    %edx,(%eax)
        return true;
c002e3aa:	b0 01                	mov    $0x1,%al
c002e3ac:	eb 23                	jmp    c002e3d1 <lookup+0xca>
       ofs += sizeof e) 
c002e3ae:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e3b2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e3b5:	8b 45 08             	mov    0x8(%ebp),%eax
c002e3b8:	8b 00                	mov    (%eax),%eax
c002e3ba:	52                   	push   %edx
c002e3bb:	6a 14                	push   $0x14
c002e3bd:	8d 55 d0             	lea    -0x30(%ebp),%edx
c002e3c0:	52                   	push   %edx
c002e3c1:	50                   	push   %eax
c002e3c2:	e8 4f 06 00 00       	call   c002ea16 <inode_read_at>
c002e3c7:	83 c4 10             	add    $0x10,%esp
c002e3ca:	83 f8 14             	cmp    $0x14,%eax
c002e3cd:	74 92                	je     c002e361 <lookup+0x5a>
      }
  return false;
c002e3cf:	b0 00                	mov    $0x0,%al
}
c002e3d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e3d4:	5b                   	pop    %ebx
c002e3d5:	5e                   	pop    %esi
c002e3d6:	5f                   	pop    %edi
c002e3d7:	5d                   	pop    %ebp
c002e3d8:	c3                   	ret    

c002e3d9 <dir_lookup>:
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool
dir_lookup (const struct dir *dir, const char *name,
            struct inode **inode) 
{
c002e3d9:	55                   	push   %ebp
c002e3da:	89 e5                	mov    %esp,%ebp
c002e3dc:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;

  ASSERT (dir != NULL);
c002e3df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e3e3:	75 1e                	jne    c002e403 <dir_lookup+0x2a>
c002e3e5:	83 ec 0c             	sub    $0xc,%esp
c002e3e8:	68 a8 2e 03 c0       	push   $0xc0032ea8
c002e3ed:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e3f2:	68 fc 2e 03 c0       	push   $0xc0032efc
c002e3f7:	6a 7c                	push   $0x7c
c002e3f9:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e3fe:	e8 6b b3 ff ff       	call   c002976e <debug_panic>
  ASSERT (name != NULL);
c002e403:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002e407:	75 1e                	jne    c002e427 <dir_lookup+0x4e>
c002e409:	83 ec 0c             	sub    $0xc,%esp
c002e40c:	68 e5 2e 03 c0       	push   $0xc0032ee5
c002e411:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e416:	68 fc 2e 03 c0       	push   $0xc0032efc
c002e41b:	6a 7d                	push   $0x7d
c002e41d:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e422:	e8 47 b3 ff ff       	call   c002976e <debug_panic>

  if (lookup (dir, name, &e, NULL))
c002e427:	6a 00                	push   $0x0
c002e429:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002e42c:	50                   	push   %eax
c002e42d:	ff 75 0c             	pushl  0xc(%ebp)
c002e430:	ff 75 08             	pushl  0x8(%ebp)
c002e433:	e8 cf fe ff ff       	call   c002e307 <lookup>
c002e438:	83 c4 10             	add    $0x10,%esp
c002e43b:	84 c0                	test   %al,%al
c002e43d:	74 18                	je     c002e457 <dir_lookup+0x7e>
    *inode = inode_open (e.inode_sector);
c002e43f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e442:	83 ec 0c             	sub    $0xc,%esp
c002e445:	50                   	push   %eax
c002e446:	e8 f6 03 00 00       	call   c002e841 <inode_open>
c002e44b:	83 c4 10             	add    $0x10,%esp
c002e44e:	89 c2                	mov    %eax,%edx
c002e450:	8b 45 10             	mov    0x10(%ebp),%eax
c002e453:	89 10                	mov    %edx,(%eax)
c002e455:	eb 09                	jmp    c002e460 <dir_lookup+0x87>
  else
    *inode = NULL;
c002e457:	8b 45 10             	mov    0x10(%ebp),%eax
c002e45a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

  return *inode != NULL;
c002e460:	8b 45 10             	mov    0x10(%ebp),%eax
c002e463:	8b 00                	mov    (%eax),%eax
c002e465:	85 c0                	test   %eax,%eax
c002e467:	0f 95 c0             	setne  %al
}
c002e46a:	c9                   	leave  
c002e46b:	c3                   	ret    

c002e46c <dir_add>:
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool
dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)
{
c002e46c:	55                   	push   %ebp
c002e46d:	89 e5                	mov    %esp,%ebp
c002e46f:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;
  off_t ofs;
  bool success = false;
c002e472:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)

  ASSERT (dir != NULL);
c002e476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e47a:	75 21                	jne    c002e49d <dir_add+0x31>
c002e47c:	83 ec 0c             	sub    $0xc,%esp
c002e47f:	68 a8 2e 03 c0       	push   $0xc0032ea8
c002e484:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e489:	68 08 2f 03 c0       	push   $0xc0032f08
c002e48e:	68 94 00 00 00       	push   $0x94
c002e493:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e498:	e8 d1 b2 ff ff       	call   c002976e <debug_panic>
  ASSERT (name != NULL);
c002e49d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002e4a1:	75 21                	jne    c002e4c4 <dir_add+0x58>
c002e4a3:	83 ec 0c             	sub    $0xc,%esp
c002e4a6:	68 e5 2e 03 c0       	push   $0xc0032ee5
c002e4ab:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e4b0:	68 08 2f 03 c0       	push   $0xc0032f08
c002e4b5:	68 95 00 00 00       	push   $0x95
c002e4ba:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e4bf:	e8 aa b2 ff ff       	call   c002976e <debug_panic>

  /* Check NAME for validity. */
  if (*name == '\0' || strlen (name) > NAME_MAX)
c002e4c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e4c7:	8a 00                	mov    (%eax),%al
c002e4c9:	84 c0                	test   %al,%al
c002e4cb:	74 13                	je     c002e4e0 <dir_add+0x74>
c002e4cd:	83 ec 0c             	sub    $0xc,%esp
c002e4d0:	ff 75 0c             	pushl  0xc(%ebp)
c002e4d3:	e8 09 a7 ff ff       	call   c0028be1 <strlen>
c002e4d8:	83 c4 10             	add    $0x10,%esp
c002e4db:	83 f8 0e             	cmp    $0xe,%eax
c002e4de:	76 07                	jbe    c002e4e7 <dir_add+0x7b>
    return false;
c002e4e0:	b0 00                	mov    $0x0,%al
c002e4e2:	e9 98 00 00 00       	jmp    c002e57f <dir_add+0x113>

  /* Check that NAME is not in use. */
  if (lookup (dir, name, NULL, NULL))
c002e4e7:	6a 00                	push   $0x0
c002e4e9:	6a 00                	push   $0x0
c002e4eb:	ff 75 0c             	pushl  0xc(%ebp)
c002e4ee:	ff 75 08             	pushl  0x8(%ebp)
c002e4f1:	e8 11 fe ff ff       	call   c002e307 <lookup>
c002e4f6:	83 c4 10             	add    $0x10,%esp
c002e4f9:	84 c0                	test   %al,%al
c002e4fb:	75 7e                	jne    c002e57b <dir_add+0x10f>
     current end-of-file.
     
     inode_read_at() will only return a short read at end of file.
     Otherwise, we'd need to verify that we didn't get a short
     read due to something intermittent such as low memory. */
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e4fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e504:	eb 13                	jmp    c002e519 <dir_add+0xad>
       ofs += sizeof e) 
    if (!e.in_use)
c002e506:	8a 45 ef             	mov    -0x11(%ebp),%al
c002e509:	83 f0 01             	xor    $0x1,%eax
c002e50c:	84 c0                	test   %al,%al
c002e50e:	75 27                	jne    c002e537 <dir_add+0xcb>
       ofs += sizeof e) 
c002e510:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e513:	83 c0 14             	add    $0x14,%eax
c002e516:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e519:	8b 45 08             	mov    0x8(%ebp),%eax
c002e51c:	8b 00                	mov    (%eax),%eax
c002e51e:	ff 75 f4             	pushl  -0xc(%ebp)
c002e521:	6a 14                	push   $0x14
c002e523:	8d 55 dc             	lea    -0x24(%ebp),%edx
c002e526:	52                   	push   %edx
c002e527:	50                   	push   %eax
c002e528:	e8 e9 04 00 00       	call   c002ea16 <inode_read_at>
c002e52d:	83 c4 10             	add    $0x10,%esp
c002e530:	83 f8 14             	cmp    $0x14,%eax
c002e533:	74 d1                	je     c002e506 <dir_add+0x9a>
c002e535:	eb 01                	jmp    c002e538 <dir_add+0xcc>
      break;
c002e537:	90                   	nop

  /* Write slot. */
  e.in_use = true;
c002e538:	c6 45 ef 01          	movb   $0x1,-0x11(%ebp)
  strlcpy (e.name, name, sizeof e.name);
c002e53c:	83 ec 04             	sub    $0x4,%esp
c002e53f:	6a 0f                	push   $0xf
c002e541:	ff 75 0c             	pushl  0xc(%ebp)
c002e544:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002e547:	83 c0 04             	add    $0x4,%eax
c002e54a:	50                   	push   %eax
c002e54b:	e8 0b a7 ff ff       	call   c0028c5b <strlcpy>
c002e550:	83 c4 10             	add    $0x10,%esp
  e.inode_sector = inode_sector;
c002e553:	8b 45 10             	mov    0x10(%ebp),%eax
c002e556:	89 45 dc             	mov    %eax,-0x24(%ebp)
  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
c002e559:	8b 45 08             	mov    0x8(%ebp),%eax
c002e55c:	8b 00                	mov    (%eax),%eax
c002e55e:	ff 75 f4             	pushl  -0xc(%ebp)
c002e561:	6a 14                	push   $0x14
c002e563:	8d 55 dc             	lea    -0x24(%ebp),%edx
c002e566:	52                   	push   %edx
c002e567:	50                   	push   %eax
c002e568:	e8 f7 05 00 00       	call   c002eb64 <inode_write_at>
c002e56d:	83 c4 10             	add    $0x10,%esp
c002e570:	83 f8 14             	cmp    $0x14,%eax
c002e573:	0f 94 c0             	sete   %al
c002e576:	88 45 f3             	mov    %al,-0xd(%ebp)
c002e579:	eb 01                	jmp    c002e57c <dir_add+0x110>
    goto done;
c002e57b:	90                   	nop

 done:
  return success;
c002e57c:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002e57f:	c9                   	leave  
c002e580:	c3                   	ret    

c002e581 <dir_remove>:
/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool
dir_remove (struct dir *dir, const char *name) 
{
c002e581:	55                   	push   %ebp
c002e582:	89 e5                	mov    %esp,%ebp
c002e584:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;
  struct inode *inode = NULL;
c002e587:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  bool success = false;
c002e58e:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  off_t ofs;

  ASSERT (dir != NULL);
c002e592:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e596:	75 21                	jne    c002e5b9 <dir_remove+0x38>
c002e598:	83 ec 0c             	sub    $0xc,%esp
c002e59b:	68 a8 2e 03 c0       	push   $0xc0032ea8
c002e5a0:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e5a5:	68 10 2f 03 c0       	push   $0xc0032f10
c002e5aa:	68 c0 00 00 00       	push   $0xc0
c002e5af:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e5b4:	e8 b5 b1 ff ff       	call   c002976e <debug_panic>
  ASSERT (name != NULL);
c002e5b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002e5bd:	75 21                	jne    c002e5e0 <dir_remove+0x5f>
c002e5bf:	83 ec 0c             	sub    $0xc,%esp
c002e5c2:	68 e5 2e 03 c0       	push   $0xc0032ee5
c002e5c7:	68 b4 2e 03 c0       	push   $0xc0032eb4
c002e5cc:	68 10 2f 03 c0       	push   $0xc0032f10
c002e5d1:	68 c1 00 00 00       	push   $0xc1
c002e5d6:	68 cb 2e 03 c0       	push   $0xc0032ecb
c002e5db:	e8 8e b1 ff ff       	call   c002976e <debug_panic>

  /* Find directory entry. */
  if (!lookup (dir, name, &e, &ofs))
c002e5e0:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e5e3:	50                   	push   %eax
c002e5e4:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002e5e7:	50                   	push   %eax
c002e5e8:	ff 75 0c             	pushl  0xc(%ebp)
c002e5eb:	ff 75 08             	pushl  0x8(%ebp)
c002e5ee:	e8 14 fd ff ff       	call   c002e307 <lookup>
c002e5f3:	83 c4 10             	add    $0x10,%esp
c002e5f6:	83 f0 01             	xor    $0x1,%eax
c002e5f9:	84 c0                	test   %al,%al
c002e5fb:	75 4d                	jne    c002e64a <dir_remove+0xc9>
    goto done;

  /* Open inode. */
  inode = inode_open (e.inode_sector);
c002e5fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002e600:	83 ec 0c             	sub    $0xc,%esp
c002e603:	50                   	push   %eax
c002e604:	e8 38 02 00 00       	call   c002e841 <inode_open>
c002e609:	83 c4 10             	add    $0x10,%esp
c002e60c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (inode == NULL)
c002e60f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002e613:	74 38                	je     c002e64d <dir_remove+0xcc>
    goto done;

  /* Erase directory entry. */
  e.in_use = false;
c002e615:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if (inode_write_at (dir->inode, &e, sizeof e, ofs) != sizeof e) 
c002e619:	8b 55 d8             	mov    -0x28(%ebp),%edx
c002e61c:	8b 45 08             	mov    0x8(%ebp),%eax
c002e61f:	8b 00                	mov    (%eax),%eax
c002e621:	52                   	push   %edx
c002e622:	6a 14                	push   $0x14
c002e624:	8d 55 dc             	lea    -0x24(%ebp),%edx
c002e627:	52                   	push   %edx
c002e628:	50                   	push   %eax
c002e629:	e8 36 05 00 00       	call   c002eb64 <inode_write_at>
c002e62e:	83 c4 10             	add    $0x10,%esp
c002e631:	83 f8 14             	cmp    $0x14,%eax
c002e634:	75 1a                	jne    c002e650 <dir_remove+0xcf>
    goto done;

  /* Remove inode. */
  inode_remove (inode);
c002e636:	83 ec 0c             	sub    $0xc,%esp
c002e639:	ff 75 f4             	pushl  -0xc(%ebp)
c002e63c:	e8 9e 03 00 00       	call   c002e9df <inode_remove>
c002e641:	83 c4 10             	add    $0x10,%esp
  success = true;
c002e644:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
c002e648:	eb 07                	jmp    c002e651 <dir_remove+0xd0>
    goto done;
c002e64a:	90                   	nop
c002e64b:	eb 04                	jmp    c002e651 <dir_remove+0xd0>
    goto done;
c002e64d:	90                   	nop
c002e64e:	eb 01                	jmp    c002e651 <dir_remove+0xd0>
    goto done;
c002e650:	90                   	nop

 done:
  inode_close (inode);
c002e651:	83 ec 0c             	sub    $0xc,%esp
c002e654:	ff 75 f4             	pushl  -0xc(%ebp)
c002e657:	e8 f7 02 00 00       	call   c002e953 <inode_close>
c002e65c:	83 c4 10             	add    $0x10,%esp
  return success;
c002e65f:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c002e662:	c9                   	leave  
c002e663:	c3                   	ret    

c002e664 <dir_readdir>:
/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool
dir_readdir (struct dir *dir, char name[NAME_MAX + 1])
{
c002e664:	55                   	push   %ebp
c002e665:	89 e5                	mov    %esp,%ebp
c002e667:	83 ec 28             	sub    $0x28,%esp
  struct dir_entry e;

  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002e66a:	eb 33                	jmp    c002e69f <dir_readdir+0x3b>
    {
      dir->pos += sizeof e;
c002e66c:	8b 45 08             	mov    0x8(%ebp),%eax
c002e66f:	8b 40 04             	mov    0x4(%eax),%eax
c002e672:	83 c0 14             	add    $0x14,%eax
c002e675:	89 c2                	mov    %eax,%edx
c002e677:	8b 45 08             	mov    0x8(%ebp),%eax
c002e67a:	89 50 04             	mov    %edx,0x4(%eax)
      if (e.in_use)
c002e67d:	8a 45 f7             	mov    -0x9(%ebp),%al
c002e680:	84 c0                	test   %al,%al
c002e682:	74 1b                	je     c002e69f <dir_readdir+0x3b>
        {
          strlcpy (name, e.name, NAME_MAX + 1);
c002e684:	83 ec 04             	sub    $0x4,%esp
c002e687:	6a 0f                	push   $0xf
c002e689:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c002e68c:	83 c0 04             	add    $0x4,%eax
c002e68f:	50                   	push   %eax
c002e690:	ff 75 0c             	pushl  0xc(%ebp)
c002e693:	e8 c3 a5 ff ff       	call   c0028c5b <strlcpy>
c002e698:	83 c4 10             	add    $0x10,%esp
          return true;
c002e69b:	b0 01                	mov    $0x1,%al
c002e69d:	eb 22                	jmp    c002e6c1 <dir_readdir+0x5d>
  while (inode_read_at (dir->inode, &e, sizeof e, dir->pos) == sizeof e) 
c002e69f:	8b 45 08             	mov    0x8(%ebp),%eax
c002e6a2:	8b 50 04             	mov    0x4(%eax),%edx
c002e6a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002e6a8:	8b 00                	mov    (%eax),%eax
c002e6aa:	52                   	push   %edx
c002e6ab:	6a 14                	push   $0x14
c002e6ad:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c002e6b0:	52                   	push   %edx
c002e6b1:	50                   	push   %eax
c002e6b2:	e8 5f 03 00 00       	call   c002ea16 <inode_read_at>
c002e6b7:	83 c4 10             	add    $0x10,%esp
c002e6ba:	83 f8 14             	cmp    $0x14,%eax
c002e6bd:	74 ad                	je     c002e66c <dir_readdir+0x8>
        } 
    }
  return false;
c002e6bf:	b0 00                	mov    $0x0,%al
}
c002e6c1:	c9                   	leave  
c002e6c2:	c3                   	ret    

c002e6c3 <bytes_to_sectors>:

/* Returns the number of sectors to allocate for an inode SIZE
   bytes long. */
static inline size_t
bytes_to_sectors (off_t size)
{
c002e6c3:	55                   	push   %ebp
c002e6c4:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (size, BLOCK_SECTOR_SIZE);
c002e6c6:	8b 45 08             	mov    0x8(%ebp),%eax
c002e6c9:	05 ff 01 00 00       	add    $0x1ff,%eax
c002e6ce:	85 c0                	test   %eax,%eax
c002e6d0:	79 05                	jns    c002e6d7 <bytes_to_sectors+0x14>
c002e6d2:	05 ff 01 00 00       	add    $0x1ff,%eax
c002e6d7:	c1 f8 09             	sar    $0x9,%eax
}
c002e6da:	5d                   	pop    %ebp
c002e6db:	c3                   	ret    

c002e6dc <byte_to_sector>:
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector (const struct inode *inode, off_t pos) 
{
c002e6dc:	55                   	push   %ebp
c002e6dd:	89 e5                	mov    %esp,%ebp
c002e6df:	83 ec 08             	sub    $0x8,%esp
  ASSERT (inode != NULL);
c002e6e2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e6e6:	75 1e                	jne    c002e706 <byte_to_sector+0x2a>
c002e6e8:	83 ec 0c             	sub    $0xc,%esp
c002e6eb:	68 1c 2f 03 c0       	push   $0xc0032f1c
c002e6f0:	68 2a 2f 03 c0       	push   $0xc0032f2a
c002e6f5:	68 a8 2f 03 c0       	push   $0xc0032fa8
c002e6fa:	6a 31                	push   $0x31
c002e6fc:	68 41 2f 03 c0       	push   $0xc0032f41
c002e701:	e8 68 b0 ff ff       	call   c002976e <debug_panic>
  if (pos < inode->data.length)
c002e706:	8b 45 08             	mov    0x8(%ebp),%eax
c002e709:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e70c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002e70f:	7e 19                	jle    c002e72a <byte_to_sector+0x4e>
    return inode->data.start + pos / BLOCK_SECTOR_SIZE;
c002e711:	8b 45 08             	mov    0x8(%ebp),%eax
c002e714:	8b 50 18             	mov    0x18(%eax),%edx
c002e717:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e71a:	85 c0                	test   %eax,%eax
c002e71c:	79 05                	jns    c002e723 <byte_to_sector+0x47>
c002e71e:	05 ff 01 00 00       	add    $0x1ff,%eax
c002e723:	c1 f8 09             	sar    $0x9,%eax
c002e726:	01 d0                	add    %edx,%eax
c002e728:	eb 05                	jmp    c002e72f <byte_to_sector+0x53>
  else
    return -1;
c002e72a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002e72f:	c9                   	leave  
c002e730:	c3                   	ret    

c002e731 <inode_init>:
static struct list open_inodes;

/* Initializes the inode module. */
void
inode_init (void) 
{
c002e731:	55                   	push   %ebp
c002e732:	89 e5                	mov    %esp,%ebp
c002e734:	83 ec 08             	sub    $0x8,%esp
  list_init (&open_inodes);
c002e737:	83 ec 0c             	sub    $0xc,%esp
c002e73a:	68 20 a4 03 c0       	push   $0xc003a420
c002e73f:	e8 9b b2 ff ff       	call   c00299df <list_init>
c002e744:	83 c4 10             	add    $0x10,%esp
}
c002e747:	90                   	nop
c002e748:	c9                   	leave  
c002e749:	c3                   	ret    

c002e74a <inode_create>:
   device.
   Returns true if successful.
   Returns false if memory or disk allocation fails. */
bool
inode_create (block_sector_t sector, off_t length)
{
c002e74a:	55                   	push   %ebp
c002e74b:	89 e5                	mov    %esp,%ebp
c002e74d:	83 ec 18             	sub    $0x18,%esp
  struct inode_disk *disk_inode = NULL;
c002e750:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  bool success = false;
c002e757:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (length >= 0);
c002e75b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002e75f:	79 1e                	jns    c002e77f <inode_create+0x35>
c002e761:	83 ec 0c             	sub    $0xc,%esp
c002e764:	68 57 2f 03 c0       	push   $0xc0032f57
c002e769:	68 2a 2f 03 c0       	push   $0xc0032f2a
c002e76e:	68 b8 2f 03 c0       	push   $0xc0032fb8
c002e773:	6a 4e                	push   $0x4e
c002e775:	68 41 2f 03 c0       	push   $0xc0032f41
c002e77a:	e8 ef af ff ff       	call   c002976e <debug_panic>

  /* If this assertion fails, the inode structure is not exactly
     one sector in size, and you should fix that. */
  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);

  disk_inode = calloc (1, sizeof *disk_inode);
c002e77f:	83 ec 08             	sub    $0x8,%esp
c002e782:	68 00 02 00 00       	push   $0x200
c002e787:	6a 01                	push   $0x1
c002e789:	e8 cd 50 ff ff       	call   c002385b <calloc>
c002e78e:	83 c4 10             	add    $0x10,%esp
c002e791:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (disk_inode != NULL)
c002e794:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002e798:	0f 84 9e 00 00 00    	je     c002e83c <inode_create+0xf2>
    {
      size_t sectors = bytes_to_sectors (length);
c002e79e:	83 ec 0c             	sub    $0xc,%esp
c002e7a1:	ff 75 0c             	pushl  0xc(%ebp)
c002e7a4:	e8 1a ff ff ff       	call   c002e6c3 <bytes_to_sectors>
c002e7a9:	83 c4 10             	add    $0x10,%esp
c002e7ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
      disk_inode->length = length;
c002e7af:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e7b2:	8b 55 0c             	mov    0xc(%ebp),%edx
c002e7b5:	89 50 04             	mov    %edx,0x4(%eax)
      disk_inode->magic = INODE_MAGIC;
c002e7b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e7bb:	c7 40 08 44 4f 4e 49 	movl   $0x494e4f44,0x8(%eax)
      if (free_map_allocate (sectors, &disk_inode->start)) 
c002e7c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e7c5:	83 ec 08             	sub    $0x8,%esp
c002e7c8:	50                   	push   %eax
c002e7c9:	ff 75 e8             	pushl  -0x18(%ebp)
c002e7cc:	e8 ff f4 ff ff       	call   c002dcd0 <free_map_allocate>
c002e7d1:	83 c4 10             	add    $0x10,%esp
c002e7d4:	84 c0                	test   %al,%al
c002e7d6:	74 56                	je     c002e82e <inode_create+0xe4>
        {
          block_write (fs_device, sector, disk_inode);
c002e7d8:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002e7dd:	83 ec 04             	sub    $0x4,%esp
c002e7e0:	ff 75 ec             	pushl  -0x14(%ebp)
c002e7e3:	ff 75 08             	pushl  0x8(%ebp)
c002e7e6:	50                   	push   %eax
c002e7e7:	e8 4f 69 ff ff       	call   c002513b <block_write>
c002e7ec:	83 c4 10             	add    $0x10,%esp
          if (sectors > 0) 
c002e7ef:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002e7f3:	74 35                	je     c002e82a <inode_create+0xe0>
            {
              static char zeros[BLOCK_SECTOR_SIZE];
              size_t i;
              
              for (i = 0; i < sectors; i++) 
c002e7f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e7fc:	eb 24                	jmp    c002e822 <inode_create+0xd8>
                block_write (fs_device, disk_inode->start + i, zeros);
c002e7fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e801:	8b 10                	mov    (%eax),%edx
c002e803:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e806:	01 c2                	add    %eax,%edx
c002e808:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002e80d:	83 ec 04             	sub    $0x4,%esp
c002e810:	68 40 a4 03 c0       	push   $0xc003a440
c002e815:	52                   	push   %edx
c002e816:	50                   	push   %eax
c002e817:	e8 1f 69 ff ff       	call   c002513b <block_write>
c002e81c:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < sectors; i++) 
c002e81f:	ff 45 f0             	incl   -0x10(%ebp)
c002e822:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e825:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002e828:	72 d4                	jb     c002e7fe <inode_create+0xb4>
            }
          success = true; 
c002e82a:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
        } 
      free (disk_inode);
c002e82e:	83 ec 0c             	sub    $0xc,%esp
c002e831:	ff 75 ec             	pushl  -0x14(%ebp)
c002e834:	e8 53 51 ff ff       	call   c002398c <free>
c002e839:	83 c4 10             	add    $0x10,%esp
    }
  return success;
c002e83c:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c002e83f:	c9                   	leave  
c002e840:	c3                   	ret    

c002e841 <inode_open>:
/* Reads an inode from SECTOR
   and returns a `struct inode' that contains it.
   Returns a null pointer if memory allocation fails. */
struct inode *
inode_open (block_sector_t sector)
{
c002e841:	55                   	push   %ebp
c002e842:	89 e5                	mov    %esp,%ebp
c002e844:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  struct inode *inode;

  /* Check whether this inode is already open. */
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002e847:	83 ec 0c             	sub    $0xc,%esp
c002e84a:	68 20 a4 03 c0       	push   $0xc003a420
c002e84f:	e8 e0 b1 ff ff       	call   c0029a34 <list_begin>
c002e854:	83 c4 10             	add    $0x10,%esp
c002e857:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002e85a:	eb 3e                	jmp    c002e89a <inode_open+0x59>
       e = list_next (e)) 
    {
      inode = list_entry (e, struct inode, elem);
c002e85c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e85f:	83 c0 04             	add    $0x4,%eax
c002e862:	83 e8 04             	sub    $0x4,%eax
c002e865:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (inode->sector == sector) 
c002e868:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e86b:	8b 40 08             	mov    0x8(%eax),%eax
c002e86e:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e871:	75 16                	jne    c002e889 <inode_open+0x48>
        {
          inode_reopen (inode);
c002e873:	83 ec 0c             	sub    $0xc,%esp
c002e876:	ff 75 f0             	pushl  -0x10(%ebp)
c002e879:	e8 ad 00 00 00       	call   c002e92b <inode_reopen>
c002e87e:	83 c4 10             	add    $0x10,%esp
          return inode; 
c002e881:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e884:	e9 a0 00 00 00       	jmp    c002e929 <inode_open+0xe8>
       e = list_next (e)) 
c002e889:	83 ec 0c             	sub    $0xc,%esp
c002e88c:	ff 75 f4             	pushl  -0xc(%ebp)
c002e88f:	e8 d2 b1 ff ff       	call   c0029a66 <list_next>
c002e894:	83 c4 10             	add    $0x10,%esp
c002e897:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&open_inodes); e != list_end (&open_inodes);
c002e89a:	83 ec 0c             	sub    $0xc,%esp
c002e89d:	68 20 a4 03 c0       	push   $0xc003a420
c002e8a2:	e8 09 b2 ff ff       	call   c0029ab0 <list_end>
c002e8a7:	83 c4 10             	add    $0x10,%esp
c002e8aa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002e8ad:	75 ad                	jne    c002e85c <inode_open+0x1b>
        }
    }

  /* Allocate memory. */
  inode = malloc (sizeof *inode);
c002e8af:	83 ec 0c             	sub    $0xc,%esp
c002e8b2:	68 18 02 00 00       	push   $0x218
c002e8b7:	e8 d6 4d ff ff       	call   c0023692 <malloc>
c002e8bc:	83 c4 10             	add    $0x10,%esp
c002e8bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (inode == NULL)
c002e8c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002e8c6:	75 07                	jne    c002e8cf <inode_open+0x8e>
    return NULL;
c002e8c8:	b8 00 00 00 00       	mov    $0x0,%eax
c002e8cd:	eb 5a                	jmp    c002e929 <inode_open+0xe8>

  /* Initialize. */
  list_push_front (&open_inodes, &inode->elem);
c002e8cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e8d2:	83 ec 08             	sub    $0x8,%esp
c002e8d5:	50                   	push   %eax
c002e8d6:	68 20 a4 03 c0       	push   $0xc003a420
c002e8db:	e8 b9 b4 ff ff       	call   c0029d99 <list_push_front>
c002e8e0:	83 c4 10             	add    $0x10,%esp
  inode->sector = sector;
c002e8e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e8e6:	8b 55 08             	mov    0x8(%ebp),%edx
c002e8e9:	89 50 08             	mov    %edx,0x8(%eax)
  inode->open_cnt = 1;
c002e8ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e8ef:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
  inode->deny_write_cnt = 0;
c002e8f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e8f9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  inode->removed = false;
c002e900:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e903:	c6 40 10 00          	movb   $0x0,0x10(%eax)
  block_read (fs_device, inode->sector, &inode->data);
c002e907:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e90a:	8d 48 18             	lea    0x18(%eax),%ecx
c002e90d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e910:	8b 50 08             	mov    0x8(%eax),%edx
c002e913:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002e918:	83 ec 04             	sub    $0x4,%esp
c002e91b:	51                   	push   %ecx
c002e91c:	52                   	push   %edx
c002e91d:	50                   	push   %eax
c002e91e:	e8 c9 67 ff ff       	call   c00250ec <block_read>
c002e923:	83 c4 10             	add    $0x10,%esp
  return inode;
c002e926:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002e929:	c9                   	leave  
c002e92a:	c3                   	ret    

c002e92b <inode_reopen>:

/* Reopens and returns INODE. */
struct inode *
inode_reopen (struct inode *inode)
{
c002e92b:	55                   	push   %ebp
c002e92c:	89 e5                	mov    %esp,%ebp
  if (inode != NULL)
c002e92e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e932:	74 0f                	je     c002e943 <inode_reopen+0x18>
    inode->open_cnt++;
c002e934:	8b 45 08             	mov    0x8(%ebp),%eax
c002e937:	8b 40 0c             	mov    0xc(%eax),%eax
c002e93a:	8d 50 01             	lea    0x1(%eax),%edx
c002e93d:	8b 45 08             	mov    0x8(%ebp),%eax
c002e940:	89 50 0c             	mov    %edx,0xc(%eax)
  return inode;
c002e943:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002e946:	5d                   	pop    %ebp
c002e947:	c3                   	ret    

c002e948 <inode_get_inumber>:

/* Returns INODE's inode number. */
block_sector_t
inode_get_inumber (const struct inode *inode)
{
c002e948:	55                   	push   %ebp
c002e949:	89 e5                	mov    %esp,%ebp
  return inode->sector;
c002e94b:	8b 45 08             	mov    0x8(%ebp),%eax
c002e94e:	8b 40 08             	mov    0x8(%eax),%eax
}
c002e951:	5d                   	pop    %ebp
c002e952:	c3                   	ret    

c002e953 <inode_close>:
/* Closes INODE and writes it to disk.
   If this was the last reference to INODE, frees its memory.
   If INODE was also a removed inode, frees its blocks. */
void
inode_close (struct inode *inode) 
{
c002e953:	55                   	push   %ebp
c002e954:	89 e5                	mov    %esp,%ebp
c002e956:	83 ec 08             	sub    $0x8,%esp
  /* Ignore null pointer. */
  if (inode == NULL)
c002e959:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e95d:	74 7d                	je     c002e9dc <inode_close+0x89>
    return;

  /* Release resources if this was the last opener. */
  if (--inode->open_cnt == 0)
c002e95f:	8b 45 08             	mov    0x8(%ebp),%eax
c002e962:	8b 40 0c             	mov    0xc(%eax),%eax
c002e965:	8d 50 ff             	lea    -0x1(%eax),%edx
c002e968:	8b 45 08             	mov    0x8(%ebp),%eax
c002e96b:	89 50 0c             	mov    %edx,0xc(%eax)
c002e96e:	8b 45 08             	mov    0x8(%ebp),%eax
c002e971:	8b 40 0c             	mov    0xc(%eax),%eax
c002e974:	85 c0                	test   %eax,%eax
c002e976:	75 65                	jne    c002e9dd <inode_close+0x8a>
    {
      /* Remove from inode list and release lock. */
      list_remove (&inode->elem);
c002e978:	8b 45 08             	mov    0x8(%ebp),%eax
c002e97b:	83 ec 0c             	sub    $0xc,%esp
c002e97e:	50                   	push   %eax
c002e97f:	e8 61 b4 ff ff       	call   c0029de5 <list_remove>
c002e984:	83 c4 10             	add    $0x10,%esp
 
      /* Deallocate blocks if removed. */
      if (inode->removed) 
c002e987:	8b 45 08             	mov    0x8(%ebp),%eax
c002e98a:	8a 40 10             	mov    0x10(%eax),%al
c002e98d:	84 c0                	test   %al,%al
c002e98f:	74 3b                	je     c002e9cc <inode_close+0x79>
        {
          free_map_release (inode->sector, 1);
c002e991:	8b 45 08             	mov    0x8(%ebp),%eax
c002e994:	8b 40 08             	mov    0x8(%eax),%eax
c002e997:	83 ec 08             	sub    $0x8,%esp
c002e99a:	6a 01                	push   $0x1
c002e99c:	50                   	push   %eax
c002e99d:	e8 ae f3 ff ff       	call   c002dd50 <free_map_release>
c002e9a2:	83 c4 10             	add    $0x10,%esp
          free_map_release (inode->data.start,
c002e9a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9a8:	8b 40 1c             	mov    0x1c(%eax),%eax
c002e9ab:	83 ec 0c             	sub    $0xc,%esp
c002e9ae:	50                   	push   %eax
c002e9af:	e8 0f fd ff ff       	call   c002e6c3 <bytes_to_sectors>
c002e9b4:	83 c4 10             	add    $0x10,%esp
c002e9b7:	89 c2                	mov    %eax,%edx
c002e9b9:	8b 45 08             	mov    0x8(%ebp),%eax
c002e9bc:	8b 40 18             	mov    0x18(%eax),%eax
c002e9bf:	83 ec 08             	sub    $0x8,%esp
c002e9c2:	52                   	push   %edx
c002e9c3:	50                   	push   %eax
c002e9c4:	e8 87 f3 ff ff       	call   c002dd50 <free_map_release>
c002e9c9:	83 c4 10             	add    $0x10,%esp
                            bytes_to_sectors (inode->data.length)); 
        }

      free (inode); 
c002e9cc:	83 ec 0c             	sub    $0xc,%esp
c002e9cf:	ff 75 08             	pushl  0x8(%ebp)
c002e9d2:	e8 b5 4f ff ff       	call   c002398c <free>
c002e9d7:	83 c4 10             	add    $0x10,%esp
c002e9da:	eb 01                	jmp    c002e9dd <inode_close+0x8a>
    return;
c002e9dc:	90                   	nop
    }
}
c002e9dd:	c9                   	leave  
c002e9de:	c3                   	ret    

c002e9df <inode_remove>:

/* Marks INODE to be deleted when it is closed by the last caller who
   has it open. */
void
inode_remove (struct inode *inode) 
{
c002e9df:	55                   	push   %ebp
c002e9e0:	89 e5                	mov    %esp,%ebp
c002e9e2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (inode != NULL);
c002e9e5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002e9e9:	75 21                	jne    c002ea0c <inode_remove+0x2d>
c002e9eb:	83 ec 0c             	sub    $0xc,%esp
c002e9ee:	68 1c 2f 03 c0       	push   $0xc0032f1c
c002e9f3:	68 2a 2f 03 c0       	push   $0xc0032f2a
c002e9f8:	68 c8 2f 03 c0       	push   $0xc0032fc8
c002e9fd:	68 c1 00 00 00       	push   $0xc1
c002ea02:	68 41 2f 03 c0       	push   $0xc0032f41
c002ea07:	e8 62 ad ff ff       	call   c002976e <debug_panic>
  inode->removed = true;
c002ea0c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ea0f:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c002ea13:	90                   	nop
c002ea14:	c9                   	leave  
c002ea15:	c3                   	ret    

c002ea16 <inode_read_at>:
/* Reads SIZE bytes from INODE into BUFFER, starting at position OFFSET.
   Returns the number of bytes actually read, which may be less
   than SIZE if an error occurs or end of file is reached. */
off_t
inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) 
{
c002ea16:	55                   	push   %ebp
c002ea17:	89 e5                	mov    %esp,%ebp
c002ea19:	53                   	push   %ebx
c002ea1a:	83 ec 34             	sub    $0x34,%esp
  uint8_t *buffer = buffer_;
c002ea1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ea20:	89 45 ec             	mov    %eax,-0x14(%ebp)
  off_t bytes_read = 0;
c002ea23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  uint8_t *bounce = NULL;
c002ea2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  while (size > 0) 
c002ea31:	e9 08 01 00 00       	jmp    c002eb3e <inode_read_at+0x128>
    {
      /* Disk sector to read, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset);
c002ea36:	83 ec 08             	sub    $0x8,%esp
c002ea39:	ff 75 14             	pushl  0x14(%ebp)
c002ea3c:	ff 75 08             	pushl  0x8(%ebp)
c002ea3f:	e8 98 fc ff ff       	call   c002e6dc <byte_to_sector>
c002ea44:	83 c4 10             	add    $0x10,%esp
c002ea47:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002ea4a:	8b 45 14             	mov    0x14(%ebp),%eax
c002ea4d:	25 ff 01 00 80       	and    $0x800001ff,%eax
c002ea52:	85 c0                	test   %eax,%eax
c002ea54:	79 07                	jns    c002ea5d <inode_read_at+0x47>
c002ea56:	48                   	dec    %eax
c002ea57:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c002ea5c:	40                   	inc    %eax
c002ea5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /* Bytes left in inode, bytes left in sector, lesser of the two. */
      off_t inode_left = inode_length (inode) - offset;
c002ea60:	83 ec 0c             	sub    $0xc,%esp
c002ea63:	ff 75 08             	pushl  0x8(%ebp)
c002ea66:	e8 5a 03 00 00       	call   c002edc5 <inode_length>
c002ea6b:	83 c4 10             	add    $0x10,%esp
c002ea6e:	2b 45 14             	sub    0x14(%ebp),%eax
c002ea71:	89 45 e0             	mov    %eax,-0x20(%ebp)
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002ea74:	b8 00 02 00 00       	mov    $0x200,%eax
c002ea79:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002ea7c:	89 45 dc             	mov    %eax,-0x24(%ebp)
      int min_left = inode_left < sector_left ? inode_left : sector_left;
c002ea7f:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002ea82:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002ea85:	39 d0                	cmp    %edx,%eax
c002ea87:	7e 02                	jle    c002ea8b <inode_read_at+0x75>
c002ea89:	89 d0                	mov    %edx,%eax
c002ea8b:	89 45 d8             	mov    %eax,-0x28(%ebp)

      /* Number of bytes to actually copy out of this sector. */
      int chunk_size = size < min_left ? size : min_left;
c002ea8e:	8b 55 10             	mov    0x10(%ebp),%edx
c002ea91:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002ea94:	39 d0                	cmp    %edx,%eax
c002ea96:	7e 02                	jle    c002ea9a <inode_read_at+0x84>
c002ea98:	89 d0                	mov    %edx,%eax
c002ea9a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (chunk_size <= 0)
c002ea9d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002eaa1:	0f 8e a3 00 00 00    	jle    c002eb4a <inode_read_at+0x134>
        break;

      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002eaa7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002eaab:	75 28                	jne    c002ead5 <inode_read_at+0xbf>
c002eaad:	81 7d d4 00 02 00 00 	cmpl   $0x200,-0x2c(%ebp)
c002eab4:	75 1f                	jne    c002ead5 <inode_read_at+0xbf>
        {
          /* Read full sector directly into caller's buffer. */
          block_read (fs_device, sector_idx, buffer + bytes_read);
c002eab6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002eab9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002eabc:	01 c2                	add    %eax,%edx
c002eabe:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002eac3:	83 ec 04             	sub    $0x4,%esp
c002eac6:	52                   	push   %edx
c002eac7:	ff 75 e8             	pushl  -0x18(%ebp)
c002eaca:	50                   	push   %eax
c002eacb:	e8 1c 66 ff ff       	call   c00250ec <block_read>
c002ead0:	83 c4 10             	add    $0x10,%esp
c002ead3:	eb 57                	jmp    c002eb2c <inode_read_at+0x116>
        }
      else 
        {
          /* Read sector into bounce buffer, then partially copy
             into caller's buffer. */
          if (bounce == NULL) 
c002ead5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ead9:	75 19                	jne    c002eaf4 <inode_read_at+0xde>
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002eadb:	83 ec 0c             	sub    $0xc,%esp
c002eade:	68 00 02 00 00       	push   $0x200
c002eae3:	e8 aa 4b ff ff       	call   c0023692 <malloc>
c002eae8:	83 c4 10             	add    $0x10,%esp
c002eaeb:	89 45 f0             	mov    %eax,-0x10(%ebp)
              if (bounce == NULL)
c002eaee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002eaf2:	74 59                	je     c002eb4d <inode_read_at+0x137>
                break;
            }
          block_read (fs_device, sector_idx, bounce);
c002eaf4:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002eaf9:	83 ec 04             	sub    $0x4,%esp
c002eafc:	ff 75 f0             	pushl  -0x10(%ebp)
c002eaff:	ff 75 e8             	pushl  -0x18(%ebp)
c002eb02:	50                   	push   %eax
c002eb03:	e8 e4 65 ff ff       	call   c00250ec <block_read>
c002eb08:	83 c4 10             	add    $0x10,%esp
          memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
c002eb0b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002eb0e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002eb11:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002eb14:	01 d1                	add    %edx,%ecx
c002eb16:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002eb19:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002eb1c:	01 da                	add    %ebx,%edx
c002eb1e:	83 ec 04             	sub    $0x4,%esp
c002eb21:	50                   	push   %eax
c002eb22:	51                   	push   %ecx
c002eb23:	52                   	push   %edx
c002eb24:	e8 85 9a ff ff       	call   c00285ae <memcpy>
c002eb29:	83 c4 10             	add    $0x10,%esp
        }
      
      /* Advance. */
      size -= chunk_size;
c002eb2c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002eb2f:	29 45 10             	sub    %eax,0x10(%ebp)
      offset += chunk_size;
c002eb32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002eb35:	01 45 14             	add    %eax,0x14(%ebp)
      bytes_read += chunk_size;
c002eb38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002eb3b:	01 45 f4             	add    %eax,-0xc(%ebp)
  while (size > 0) 
c002eb3e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002eb42:	0f 8f ee fe ff ff    	jg     c002ea36 <inode_read_at+0x20>
c002eb48:	eb 04                	jmp    c002eb4e <inode_read_at+0x138>
        break;
c002eb4a:	90                   	nop
c002eb4b:	eb 01                	jmp    c002eb4e <inode_read_at+0x138>
                break;
c002eb4d:	90                   	nop
    }
  free (bounce);
c002eb4e:	83 ec 0c             	sub    $0xc,%esp
c002eb51:	ff 75 f0             	pushl  -0x10(%ebp)
c002eb54:	e8 33 4e ff ff       	call   c002398c <free>
c002eb59:	83 c4 10             	add    $0x10,%esp

  return bytes_read;
c002eb5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002eb5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002eb62:	c9                   	leave  
c002eb63:	c3                   	ret    

c002eb64 <inode_write_at>:
   (Normally a write at end of file would extend the inode, but
   growth is not yet implemented.) */
off_t
inode_write_at (struct inode *inode, const void *buffer_, off_t size,
                off_t offset) 
{
c002eb64:	55                   	push   %ebp
c002eb65:	89 e5                	mov    %esp,%ebp
c002eb67:	53                   	push   %ebx
c002eb68:	83 ec 34             	sub    $0x34,%esp
  const uint8_t *buffer = buffer_;
c002eb6b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002eb6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  off_t bytes_written = 0;
c002eb71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  uint8_t *bounce = NULL;
c002eb78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if (inode->deny_write_cnt)
c002eb7f:	8b 45 08             	mov    0x8(%ebp),%eax
c002eb82:	8b 40 14             	mov    0x14(%eax),%eax
c002eb85:	85 c0                	test   %eax,%eax
c002eb87:	0f 84 55 01 00 00    	je     c002ece2 <inode_write_at+0x17e>
    return 0;
c002eb8d:	b8 00 00 00 00       	mov    $0x0,%eax
c002eb92:	e9 6c 01 00 00       	jmp    c002ed03 <inode_write_at+0x19f>

  while (size > 0) 
    {
      /* Sector to write, starting byte offset within sector. */
      block_sector_t sector_idx = byte_to_sector (inode, offset);
c002eb97:	83 ec 08             	sub    $0x8,%esp
c002eb9a:	ff 75 14             	pushl  0x14(%ebp)
c002eb9d:	ff 75 08             	pushl  0x8(%ebp)
c002eba0:	e8 37 fb ff ff       	call   c002e6dc <byte_to_sector>
c002eba5:	83 c4 10             	add    $0x10,%esp
c002eba8:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c002ebab:	8b 45 14             	mov    0x14(%ebp),%eax
c002ebae:	25 ff 01 00 80       	and    $0x800001ff,%eax
c002ebb3:	85 c0                	test   %eax,%eax
c002ebb5:	79 07                	jns    c002ebbe <inode_write_at+0x5a>
c002ebb7:	48                   	dec    %eax
c002ebb8:	0d 00 fe ff ff       	or     $0xfffffe00,%eax
c002ebbd:	40                   	inc    %eax
c002ebbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /* Bytes left in inode, bytes left in sector, lesser of the two. */
      off_t inode_left = inode_length (inode) - offset;
c002ebc1:	83 ec 0c             	sub    $0xc,%esp
c002ebc4:	ff 75 08             	pushl  0x8(%ebp)
c002ebc7:	e8 f9 01 00 00       	call   c002edc5 <inode_length>
c002ebcc:	83 c4 10             	add    $0x10,%esp
c002ebcf:	2b 45 14             	sub    0x14(%ebp),%eax
c002ebd2:	89 45 e0             	mov    %eax,-0x20(%ebp)
      int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c002ebd5:	b8 00 02 00 00       	mov    $0x200,%eax
c002ebda:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002ebdd:	89 45 dc             	mov    %eax,-0x24(%ebp)
      int min_left = inode_left < sector_left ? inode_left : sector_left;
c002ebe0:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002ebe3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002ebe6:	39 d0                	cmp    %edx,%eax
c002ebe8:	7e 02                	jle    c002ebec <inode_write_at+0x88>
c002ebea:	89 d0                	mov    %edx,%eax
c002ebec:	89 45 d8             	mov    %eax,-0x28(%ebp)

      /* Number of bytes to actually write into this sector. */
      int chunk_size = size < min_left ? size : min_left;
c002ebef:	8b 55 10             	mov    0x10(%ebp),%edx
c002ebf2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002ebf5:	39 d0                	cmp    %edx,%eax
c002ebf7:	7e 02                	jle    c002ebfb <inode_write_at+0x97>
c002ebf9:	89 d0                	mov    %edx,%eax
c002ebfb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (chunk_size <= 0)
c002ebfe:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002ec02:	0f 8e e6 00 00 00    	jle    c002ecee <inode_write_at+0x18a>
        break;

      if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c002ec08:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002ec0c:	75 2b                	jne    c002ec39 <inode_write_at+0xd5>
c002ec0e:	81 7d d4 00 02 00 00 	cmpl   $0x200,-0x2c(%ebp)
c002ec15:	75 22                	jne    c002ec39 <inode_write_at+0xd5>
        {
          /* Write full sector directly to disk. */
          block_write (fs_device, sector_idx, buffer + bytes_written);
c002ec17:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ec1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ec1d:	01 c2                	add    %eax,%edx
c002ec1f:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002ec24:	83 ec 04             	sub    $0x4,%esp
c002ec27:	52                   	push   %edx
c002ec28:	ff 75 e8             	pushl  -0x18(%ebp)
c002ec2b:	50                   	push   %eax
c002ec2c:	e8 0a 65 ff ff       	call   c002513b <block_write>
c002ec31:	83 c4 10             	add    $0x10,%esp
c002ec34:	e9 97 00 00 00       	jmp    c002ecd0 <inode_write_at+0x16c>
        }
      else 
        {
          /* We need a bounce buffer. */
          if (bounce == NULL) 
c002ec39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ec3d:	75 1d                	jne    c002ec5c <inode_write_at+0xf8>
            {
              bounce = malloc (BLOCK_SECTOR_SIZE);
c002ec3f:	83 ec 0c             	sub    $0xc,%esp
c002ec42:	68 00 02 00 00       	push   $0x200
c002ec47:	e8 46 4a ff ff       	call   c0023692 <malloc>
c002ec4c:	83 c4 10             	add    $0x10,%esp
c002ec4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
              if (bounce == NULL)
c002ec52:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ec56:	0f 84 95 00 00 00    	je     c002ecf1 <inode_write_at+0x18d>
            }

          /* If the sector contains data before or after the chunk
             we're writing, then we need to read in the sector
             first.  Otherwise we start with a sector of all zeros. */
          if (sector_ofs > 0 || chunk_size < sector_left) 
c002ec5c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002ec60:	7f 08                	jg     c002ec6a <inode_write_at+0x106>
c002ec62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ec65:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c002ec68:	7d 19                	jge    c002ec83 <inode_write_at+0x11f>
            block_read (fs_device, sector_idx, bounce);
c002ec6a:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002ec6f:	83 ec 04             	sub    $0x4,%esp
c002ec72:	ff 75 f0             	pushl  -0x10(%ebp)
c002ec75:	ff 75 e8             	pushl  -0x18(%ebp)
c002ec78:	50                   	push   %eax
c002ec79:	e8 6e 64 ff ff       	call   c00250ec <block_read>
c002ec7e:	83 c4 10             	add    $0x10,%esp
c002ec81:	eb 15                	jmp    c002ec98 <inode_write_at+0x134>
          else
            memset (bounce, 0, BLOCK_SECTOR_SIZE);
c002ec83:	83 ec 04             	sub    $0x4,%esp
c002ec86:	68 00 02 00 00       	push   $0x200
c002ec8b:	6a 00                	push   $0x0
c002ec8d:	ff 75 f0             	pushl  -0x10(%ebp)
c002ec90:	e8 f3 9e ff ff       	call   c0028b88 <memset>
c002ec95:	83 c4 10             	add    $0x10,%esp
          memcpy (bounce + sector_ofs, buffer + bytes_written, chunk_size);
c002ec98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ec9b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002ec9e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002eca1:	01 d1                	add    %edx,%ecx
c002eca3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002eca6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002eca9:	01 da                	add    %ebx,%edx
c002ecab:	83 ec 04             	sub    $0x4,%esp
c002ecae:	50                   	push   %eax
c002ecaf:	51                   	push   %ecx
c002ecb0:	52                   	push   %edx
c002ecb1:	e8 f8 98 ff ff       	call   c00285ae <memcpy>
c002ecb6:	83 c4 10             	add    $0x10,%esp
          block_write (fs_device, sector_idx, bounce);
c002ecb9:	a1 4c a6 03 c0       	mov    0xc003a64c,%eax
c002ecbe:	83 ec 04             	sub    $0x4,%esp
c002ecc1:	ff 75 f0             	pushl  -0x10(%ebp)
c002ecc4:	ff 75 e8             	pushl  -0x18(%ebp)
c002ecc7:	50                   	push   %eax
c002ecc8:	e8 6e 64 ff ff       	call   c002513b <block_write>
c002eccd:	83 c4 10             	add    $0x10,%esp
        }

      /* Advance. */
      size -= chunk_size;
c002ecd0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ecd3:	29 45 10             	sub    %eax,0x10(%ebp)
      offset += chunk_size;
c002ecd6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ecd9:	01 45 14             	add    %eax,0x14(%ebp)
      bytes_written += chunk_size;
c002ecdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002ecdf:	01 45 f4             	add    %eax,-0xc(%ebp)
  while (size > 0) 
c002ece2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002ece6:	0f 8f ab fe ff ff    	jg     c002eb97 <inode_write_at+0x33>
c002ecec:	eb 04                	jmp    c002ecf2 <inode_write_at+0x18e>
        break;
c002ecee:	90                   	nop
c002ecef:	eb 01                	jmp    c002ecf2 <inode_write_at+0x18e>
                break;
c002ecf1:	90                   	nop
    }
  free (bounce);
c002ecf2:	83 ec 0c             	sub    $0xc,%esp
c002ecf5:	ff 75 f0             	pushl  -0x10(%ebp)
c002ecf8:	e8 8f 4c ff ff       	call   c002398c <free>
c002ecfd:	83 c4 10             	add    $0x10,%esp

  return bytes_written;
c002ed00:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ed03:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002ed06:	c9                   	leave  
c002ed07:	c3                   	ret    

c002ed08 <inode_deny_write>:

/* Disables writes to INODE.
   May be called at most once per inode opener. */
void
inode_deny_write (struct inode *inode) 
{
c002ed08:	55                   	push   %ebp
c002ed09:	89 e5                	mov    %esp,%ebp
c002ed0b:	83 ec 08             	sub    $0x8,%esp
  inode->deny_write_cnt++;
c002ed0e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed11:	8b 40 14             	mov    0x14(%eax),%eax
c002ed14:	8d 50 01             	lea    0x1(%eax),%edx
c002ed17:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed1a:	89 50 14             	mov    %edx,0x14(%eax)
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002ed1d:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed20:	8b 50 14             	mov    0x14(%eax),%edx
c002ed23:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed26:	8b 40 0c             	mov    0xc(%eax),%eax
c002ed29:	39 c2                	cmp    %eax,%edx
c002ed2b:	7e 21                	jle    c002ed4e <inode_deny_write+0x46>
c002ed2d:	83 ec 0c             	sub    $0xc,%esp
c002ed30:	68 64 2f 03 c0       	push   $0xc0032f64
c002ed35:	68 2a 2f 03 c0       	push   $0xc0032f2a
c002ed3a:	68 d8 2f 03 c0       	push   $0xc0032fd8
c002ed3f:	68 46 01 00 00       	push   $0x146
c002ed44:	68 41 2f 03 c0       	push   $0xc0032f41
c002ed49:	e8 20 aa ff ff       	call   c002976e <debug_panic>
}
c002ed4e:	90                   	nop
c002ed4f:	c9                   	leave  
c002ed50:	c3                   	ret    

c002ed51 <inode_allow_write>:
/* Re-enables writes to INODE.
   Must be called once by each inode opener who has called
   inode_deny_write() on the inode, before closing the inode. */
void
inode_allow_write (struct inode *inode) 
{
c002ed51:	55                   	push   %ebp
c002ed52:	89 e5                	mov    %esp,%ebp
c002ed54:	83 ec 08             	sub    $0x8,%esp
  ASSERT (inode->deny_write_cnt > 0);
c002ed57:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed5a:	8b 40 14             	mov    0x14(%eax),%eax
c002ed5d:	85 c0                	test   %eax,%eax
c002ed5f:	7f 21                	jg     c002ed82 <inode_allow_write+0x31>
c002ed61:	83 ec 0c             	sub    $0xc,%esp
c002ed64:	68 8d 2f 03 c0       	push   $0xc0032f8d
c002ed69:	68 2a 2f 03 c0       	push   $0xc0032f2a
c002ed6e:	68 ec 2f 03 c0       	push   $0xc0032fec
c002ed73:	68 4f 01 00 00       	push   $0x14f
c002ed78:	68 41 2f 03 c0       	push   $0xc0032f41
c002ed7d:	e8 ec a9 ff ff       	call   c002976e <debug_panic>
  ASSERT (inode->deny_write_cnt <= inode->open_cnt);
c002ed82:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed85:	8b 50 14             	mov    0x14(%eax),%edx
c002ed88:	8b 45 08             	mov    0x8(%ebp),%eax
c002ed8b:	8b 40 0c             	mov    0xc(%eax),%eax
c002ed8e:	39 c2                	cmp    %eax,%edx
c002ed90:	7e 21                	jle    c002edb3 <inode_allow_write+0x62>
c002ed92:	83 ec 0c             	sub    $0xc,%esp
c002ed95:	68 64 2f 03 c0       	push   $0xc0032f64
c002ed9a:	68 2a 2f 03 c0       	push   $0xc0032f2a
c002ed9f:	68 ec 2f 03 c0       	push   $0xc0032fec
c002eda4:	68 50 01 00 00       	push   $0x150
c002eda9:	68 41 2f 03 c0       	push   $0xc0032f41
c002edae:	e8 bb a9 ff ff       	call   c002976e <debug_panic>
  inode->deny_write_cnt--;
c002edb3:	8b 45 08             	mov    0x8(%ebp),%eax
c002edb6:	8b 40 14             	mov    0x14(%eax),%eax
c002edb9:	8d 50 ff             	lea    -0x1(%eax),%edx
c002edbc:	8b 45 08             	mov    0x8(%ebp),%eax
c002edbf:	89 50 14             	mov    %edx,0x14(%eax)
}
c002edc2:	90                   	nop
c002edc3:	c9                   	leave  
c002edc4:	c3                   	ret    

c002edc5 <inode_length>:

/* Returns the length, in bytes, of INODE's data. */
off_t
inode_length (const struct inode *inode)
{
c002edc5:	55                   	push   %ebp
c002edc6:	89 e5                	mov    %esp,%ebp
  return inode->data.length;
c002edc8:	8b 45 08             	mov    0x8(%ebp),%eax
c002edcb:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c002edce:	5d                   	pop    %ebp
c002edcf:	c3                   	ret    

c002edd0 <fsutil_ls>:
#include "threads/vaddr.h"

/* List files in the root directory. */
void
fsutil_ls (char **argv UNUSED) 
{
c002edd0:	55                   	push   %ebp
c002edd1:	89 e5                	mov    %esp,%ebp
c002edd3:	83 ec 28             	sub    $0x28,%esp
  struct dir *dir;
  char name[NAME_MAX + 1];
  
  printf ("Files in the root directory:\n");
c002edd6:	83 ec 0c             	sub    $0xc,%esp
c002edd9:	68 00 30 03 c0       	push   $0xc0033000
c002edde:	e8 5d cc ff ff       	call   c002ba40 <puts>
c002ede3:	83 c4 10             	add    $0x10,%esp
  dir = dir_open_root ();
c002ede6:	e8 9e f4 ff ff       	call   c002e289 <dir_open_root>
c002edeb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (dir == NULL)
c002edee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002edf2:	75 25                	jne    c002ee19 <fsutil_ls+0x49>
    PANIC ("root dir open failed1");
c002edf4:	68 1d 30 03 c0       	push   $0xc003301d
c002edf9:	68 cc 32 03 c0       	push   $0xc00332cc
c002edfe:	6a 18                	push   $0x18
c002ee00:	68 33 30 03 c0       	push   $0xc0033033
c002ee05:	e8 64 a9 ff ff       	call   c002976e <debug_panic>
  while (dir_readdir (dir, name))
    printf ("%s\n", name);
c002ee0a:	83 ec 0c             	sub    $0xc,%esp
c002ee0d:	8d 45 e5             	lea    -0x1b(%ebp),%eax
c002ee10:	50                   	push   %eax
c002ee11:	e8 2a cc ff ff       	call   c002ba40 <puts>
c002ee16:	83 c4 10             	add    $0x10,%esp
  while (dir_readdir (dir, name))
c002ee19:	83 ec 08             	sub    $0x8,%esp
c002ee1c:	8d 45 e5             	lea    -0x1b(%ebp),%eax
c002ee1f:	50                   	push   %eax
c002ee20:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee23:	e8 3c f8 ff ff       	call   c002e664 <dir_readdir>
c002ee28:	83 c4 10             	add    $0x10,%esp
c002ee2b:	84 c0                	test   %al,%al
c002ee2d:	75 db                	jne    c002ee0a <fsutil_ls+0x3a>
  dir_close (dir);
c002ee2f:	83 ec 0c             	sub    $0xc,%esp
c002ee32:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee35:	e8 95 f4 ff ff       	call   c002e2cf <dir_close>
c002ee3a:	83 c4 10             	add    $0x10,%esp
  printf ("End of listing.\n");
c002ee3d:	83 ec 0c             	sub    $0xc,%esp
c002ee40:	68 4a 30 03 c0       	push   $0xc003304a
c002ee45:	e8 f6 cb ff ff       	call   c002ba40 <puts>
c002ee4a:	83 c4 10             	add    $0x10,%esp
}
c002ee4d:	90                   	nop
c002ee4e:	c9                   	leave  
c002ee4f:	c3                   	ret    

c002ee50 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void
fsutil_cat (char **argv)
{
c002ee50:	55                   	push   %ebp
c002ee51:	89 e5                	mov    %esp,%ebp
c002ee53:	83 ec 28             	sub    $0x28,%esp
  const char *file_name = argv[1];
c002ee56:	8b 45 08             	mov    0x8(%ebp),%eax
c002ee59:	8b 40 04             	mov    0x4(%eax),%eax
c002ee5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  struct file *file;
  char *buffer;

  printf ("Printing '%s' to the console...\n", file_name);
c002ee5f:	83 ec 08             	sub    $0x8,%esp
c002ee62:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee65:	68 5c 30 03 c0       	push   $0xc003305c
c002ee6a:	e8 40 85 ff ff       	call   c00273af <printf>
c002ee6f:	83 c4 10             	add    $0x10,%esp
  file = filesys_open (file_name);
c002ee72:	83 ec 0c             	sub    $0xc,%esp
c002ee75:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee78:	e8 e6 ec ff ff       	call   c002db63 <filesys_open>
c002ee7d:	83 c4 10             	add    $0x10,%esp
c002ee80:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (file == NULL)
c002ee83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ee87:	75 1c                	jne    c002eea5 <fsutil_cat+0x55>
    PANIC ("%s: open failed2", file_name);
c002ee89:	83 ec 0c             	sub    $0xc,%esp
c002ee8c:	ff 75 f4             	pushl  -0xc(%ebp)
c002ee8f:	68 7d 30 03 c0       	push   $0xc003307d
c002ee94:	68 d8 32 03 c0       	push   $0xc00332d8
c002ee99:	6a 2c                	push   $0x2c
c002ee9b:	68 33 30 03 c0       	push   $0xc0033033
c002eea0:	e8 c9 a8 ff ff       	call   c002976e <debug_panic>
  buffer = palloc_get_page (PAL_ASSERT);
c002eea5:	83 ec 0c             	sub    $0xc,%esp
c002eea8:	6a 01                	push   $0x1
c002eeaa:	e8 9c 44 ff ff       	call   c002334b <palloc_get_page>
c002eeaf:	83 c4 10             	add    $0x10,%esp
c002eeb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for (;;) 
    {
      off_t pos = file_tell (file);
c002eeb5:	83 ec 0c             	sub    $0xc,%esp
c002eeb8:	ff 75 f0             	pushl  -0x10(%ebp)
c002eebb:	e8 12 f3 ff ff       	call   c002e1d2 <file_tell>
c002eec0:	83 c4 10             	add    $0x10,%esp
c002eec3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      off_t n = file_read (file, buffer, PGSIZE);
c002eec6:	83 ec 04             	sub    $0x4,%esp
c002eec9:	68 00 10 00 00       	push   $0x1000
c002eece:	ff 75 ec             	pushl  -0x14(%ebp)
c002eed1:	ff 75 f0             	pushl  -0x10(%ebp)
c002eed4:	e8 03 f1 ff ff       	call   c002dfdc <file_read>
c002eed9:	83 c4 10             	add    $0x10,%esp
c002eedc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (n == 0)
c002eedf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002eee3:	74 17                	je     c002eefc <fsutil_cat+0xac>
        break;

      hex_dump (pos, buffer, n, true); 
c002eee5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002eee8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002eeeb:	6a 01                	push   $0x1
c002eeed:	52                   	push   %edx
c002eeee:	ff 75 ec             	pushl  -0x14(%ebp)
c002eef1:	50                   	push   %eax
c002eef2:	e8 ef 8f ff ff       	call   c0027ee6 <hex_dump>
c002eef7:	83 c4 10             	add    $0x10,%esp
    {
c002eefa:	eb b9                	jmp    c002eeb5 <fsutil_cat+0x65>
        break;
c002eefc:	90                   	nop
    }
  palloc_free_page (buffer);
c002eefd:	83 ec 0c             	sub    $0xc,%esp
c002ef00:	ff 75 ec             	pushl  -0x14(%ebp)
c002ef03:	e8 9b 45 ff ff       	call   c00234a3 <palloc_free_page>
c002ef08:	83 c4 10             	add    $0x10,%esp
  file_close (file);
c002ef0b:	83 ec 0c             	sub    $0xc,%esp
c002ef0e:	ff 75 f0             	pushl  -0x10(%ebp)
c002ef11:	e8 80 f0 ff ff       	call   c002df96 <file_close>
c002ef16:	83 c4 10             	add    $0x10,%esp
}
c002ef19:	90                   	nop
c002ef1a:	c9                   	leave  
c002ef1b:	c3                   	ret    

c002ef1c <fsutil_rm>:

/* Deletes file ARGV[1]. */
void
fsutil_rm (char **argv) 
{
c002ef1c:	55                   	push   %ebp
c002ef1d:	89 e5                	mov    %esp,%ebp
c002ef1f:	83 ec 18             	sub    $0x18,%esp
  const char *file_name = argv[1];
c002ef22:	8b 45 08             	mov    0x8(%ebp),%eax
c002ef25:	8b 40 04             	mov    0x4(%eax),%eax
c002ef28:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Deleting '%s'...\n", file_name);
c002ef2b:	83 ec 08             	sub    $0x8,%esp
c002ef2e:	ff 75 f4             	pushl  -0xc(%ebp)
c002ef31:	68 8e 30 03 c0       	push   $0xc003308e
c002ef36:	e8 74 84 ff ff       	call   c00273af <printf>
c002ef3b:	83 c4 10             	add    $0x10,%esp
  if (!filesys_remove (file_name))
c002ef3e:	83 ec 0c             	sub    $0xc,%esp
c002ef41:	ff 75 f4             	pushl  -0xc(%ebp)
c002ef44:	e8 69 ec ff ff       	call   c002dbb2 <filesys_remove>
c002ef49:	83 c4 10             	add    $0x10,%esp
c002ef4c:	83 f0 01             	xor    $0x1,%eax
c002ef4f:	84 c0                	test   %al,%al
c002ef51:	74 1c                	je     c002ef6f <fsutil_rm+0x53>
    PANIC ("%s: delete failed\n", file_name);
c002ef53:	83 ec 0c             	sub    $0xc,%esp
c002ef56:	ff 75 f4             	pushl  -0xc(%ebp)
c002ef59:	68 a0 30 03 c0       	push   $0xc00330a0
c002ef5e:	68 e4 32 03 c0       	push   $0xc00332e4
c002ef63:	6a 43                	push   $0x43
c002ef65:	68 33 30 03 c0       	push   $0xc0033033
c002ef6a:	e8 ff a7 ff ff       	call   c002976e <debug_panic>
}
c002ef6f:	90                   	nop
c002ef70:	c9                   	leave  
c002ef71:	c3                   	ret    

c002ef72 <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void
fsutil_extract (char **argv UNUSED) 
{
c002ef72:	55                   	push   %ebp
c002ef73:	89 e5                	mov    %esp,%ebp
c002ef75:	83 ec 38             	sub    $0x38,%esp

  struct block *src;
  void *header, *data;

  /* Allocate buffers. */
  header = malloc (BLOCK_SECTOR_SIZE);
c002ef78:	83 ec 0c             	sub    $0xc,%esp
c002ef7b:	68 00 02 00 00       	push   $0x200
c002ef80:	e8 0d 47 ff ff       	call   c0023692 <malloc>
c002ef85:	83 c4 10             	add    $0x10,%esp
c002ef88:	89 45 f4             	mov    %eax,-0xc(%ebp)
  data = malloc (BLOCK_SECTOR_SIZE);
c002ef8b:	83 ec 0c             	sub    $0xc,%esp
c002ef8e:	68 00 02 00 00       	push   $0x200
c002ef93:	e8 fa 46 ff ff       	call   c0023692 <malloc>
c002ef98:	83 c4 10             	add    $0x10,%esp
c002ef9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (header == NULL || data == NULL)
c002ef9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002efa2:	74 06                	je     c002efaa <fsutil_extract+0x38>
c002efa4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002efa8:	75 16                	jne    c002efc0 <fsutil_extract+0x4e>
    PANIC ("couldn't allocate buffers");
c002efaa:	68 b3 30 03 c0       	push   $0xc00330b3
c002efaf:	68 f0 32 03 c0       	push   $0xc00332f0
c002efb4:	6a 54                	push   $0x54
c002efb6:	68 33 30 03 c0       	push   $0xc0033033
c002efbb:	e8 ae a7 ff ff       	call   c002976e <debug_panic>

  /* Open source block device. */
  src = block_get_role (BLOCK_SCRATCH);
c002efc0:	83 ec 0c             	sub    $0xc,%esp
c002efc3:	6a 02                	push   $0x2
c002efc5:	e8 af 5f ff ff       	call   c0024f79 <block_get_role>
c002efca:	83 c4 10             	add    $0x10,%esp
c002efcd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (src == NULL)
c002efd0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002efd4:	75 16                	jne    c002efec <fsutil_extract+0x7a>
    PANIC ("couldn't open scratch device");
c002efd6:	68 cd 30 03 c0       	push   $0xc00330cd
c002efdb:	68 f0 32 03 c0       	push   $0xc00332f0
c002efe0:	6a 59                	push   $0x59
c002efe2:	68 33 30 03 c0       	push   $0xc0033033
c002efe7:	e8 82 a7 ff ff       	call   c002976e <debug_panic>

  printf ("Extracting ustar archive from scratch device "
c002efec:	83 ec 0c             	sub    $0xc,%esp
c002efef:	68 ec 30 03 c0       	push   $0xc00330ec
c002eff4:	e8 47 ca ff ff       	call   c002ba40 <puts>
c002eff9:	83 c4 10             	add    $0x10,%esp
      const char *error;
      enum ustar_type type;
      int size;

      /* Read and parse ustar header. */
      block_read (src, sector++, header);
c002effc:	a1 40 a6 03 c0       	mov    0xc003a640,%eax
c002f001:	8d 50 01             	lea    0x1(%eax),%edx
c002f004:	89 15 40 a6 03 c0    	mov    %edx,0xc003a640
c002f00a:	83 ec 04             	sub    $0x4,%esp
c002f00d:	ff 75 f4             	pushl  -0xc(%ebp)
c002f010:	50                   	push   %eax
c002f011:	ff 75 ec             	pushl  -0x14(%ebp)
c002f014:	e8 d3 60 ff ff       	call   c00250ec <block_read>
c002f019:	83 c4 10             	add    $0x10,%esp
      error = ustar_parse_header (header, &file_name, &type, &size);
c002f01c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002f01f:	50                   	push   %eax
c002f020:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002f023:	50                   	push   %eax
c002f024:	8d 45 dc             	lea    -0x24(%ebp),%eax
c002f027:	50                   	push   %eax
c002f028:	ff 75 f4             	pushl  -0xc(%ebp)
c002f02b:	e8 9d a5 ff ff       	call   c00295cd <ustar_parse_header>
c002f030:	83 c4 10             	add    $0x10,%esp
c002f033:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (error != NULL)
c002f036:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002f03a:	74 23                	je     c002f05f <fsutil_extract+0xed>
        PANIC ("bad ustar header in sector %"PRDSNu" (%s)", sector - 1, error);
c002f03c:	a1 40 a6 03 c0       	mov    0xc003a640,%eax
c002f041:	48                   	dec    %eax
c002f042:	83 ec 08             	sub    $0x8,%esp
c002f045:	ff 75 e8             	pushl  -0x18(%ebp)
c002f048:	50                   	push   %eax
c002f049:	68 30 31 03 c0       	push   $0xc0033130
c002f04e:	68 f0 32 03 c0       	push   $0xc00332f0
c002f053:	6a 69                	push   $0x69
c002f055:	68 33 30 03 c0       	push   $0xc0033033
c002f05a:	e8 0f a7 ff ff       	call   c002976e <debug_panic>

      if (type == USTAR_EOF)
c002f05f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f062:	83 f8 ff             	cmp    $0xffffffff,%eax
c002f065:	75 6c                	jne    c002f0d3 <fsutil_extract+0x161>

  /* Erase the ustar header from the start of the block device,
     so that the extraction operation is idempotent.  We erase
     two blocks because two blocks of zeros are the ustar
     end-of-archive marker. */
  printf ("Erasing ustar archive...\n");
c002f067:	83 ec 0c             	sub    $0xc,%esp
c002f06a:	68 53 31 03 c0       	push   $0xc0033153
c002f06f:	e8 cc c9 ff ff       	call   c002ba40 <puts>
c002f074:	83 c4 10             	add    $0x10,%esp
  memset (header, 0, BLOCK_SECTOR_SIZE);
c002f077:	83 ec 04             	sub    $0x4,%esp
c002f07a:	68 00 02 00 00       	push   $0x200
c002f07f:	6a 00                	push   $0x0
c002f081:	ff 75 f4             	pushl  -0xc(%ebp)
c002f084:	e8 ff 9a ff ff       	call   c0028b88 <memset>
c002f089:	83 c4 10             	add    $0x10,%esp
  block_write (src, 0, header);
c002f08c:	83 ec 04             	sub    $0x4,%esp
c002f08f:	ff 75 f4             	pushl  -0xc(%ebp)
c002f092:	6a 00                	push   $0x0
c002f094:	ff 75 ec             	pushl  -0x14(%ebp)
c002f097:	e8 9f 60 ff ff       	call   c002513b <block_write>
c002f09c:	83 c4 10             	add    $0x10,%esp
  block_write (src, 1, header);
c002f09f:	83 ec 04             	sub    $0x4,%esp
c002f0a2:	ff 75 f4             	pushl  -0xc(%ebp)
c002f0a5:	6a 01                	push   $0x1
c002f0a7:	ff 75 ec             	pushl  -0x14(%ebp)
c002f0aa:	e8 8c 60 ff ff       	call   c002513b <block_write>
c002f0af:	83 c4 10             	add    $0x10,%esp

  free (data);
c002f0b2:	83 ec 0c             	sub    $0xc,%esp
c002f0b5:	ff 75 f0             	pushl  -0x10(%ebp)
c002f0b8:	e8 cf 48 ff ff       	call   c002398c <free>
c002f0bd:	83 c4 10             	add    $0x10,%esp
  free (header);
c002f0c0:	83 ec 0c             	sub    $0xc,%esp
c002f0c3:	ff 75 f4             	pushl  -0xc(%ebp)
c002f0c6:	e8 c1 48 ff ff       	call   c002398c <free>
c002f0cb:	83 c4 10             	add    $0x10,%esp
}
c002f0ce:	e9 43 01 00 00       	jmp    c002f216 <fsutil_extract+0x2a4>
      else if (type == USTAR_DIRECTORY)
c002f0d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f0d6:	83 f8 35             	cmp    $0x35,%eax
c002f0d9:	75 19                	jne    c002f0f4 <fsutil_extract+0x182>
        printf ("ignoring directory %s\n", file_name);
c002f0db:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f0de:	83 ec 08             	sub    $0x8,%esp
c002f0e1:	50                   	push   %eax
c002f0e2:	68 6c 31 03 c0       	push   $0xc003316c
c002f0e7:	e8 c3 82 ff ff       	call   c00273af <printf>
c002f0ec:	83 c4 10             	add    $0x10,%esp
c002f0ef:	e9 08 ff ff ff       	jmp    c002effc <fsutil_extract+0x8a>
      else if (type == USTAR_REGULAR)
c002f0f4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002f0f7:	83 f8 30             	cmp    $0x30,%eax
c002f0fa:	0f 85 fc fe ff ff    	jne    c002effc <fsutil_extract+0x8a>
          printf ("Putting '%s' into the file system...\n", file_name);
c002f100:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f103:	83 ec 08             	sub    $0x8,%esp
c002f106:	50                   	push   %eax
c002f107:	68 84 31 03 c0       	push   $0xc0033184
c002f10c:	e8 9e 82 ff ff       	call   c00273af <printf>
c002f111:	83 c4 10             	add    $0x10,%esp
          if (!filesys_create (file_name, size))
c002f114:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002f117:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f11a:	83 ec 08             	sub    $0x8,%esp
c002f11d:	52                   	push   %edx
c002f11e:	50                   	push   %eax
c002f11f:	e8 98 e9 ff ff       	call   c002dabc <filesys_create>
c002f124:	83 c4 10             	add    $0x10,%esp
c002f127:	83 f0 01             	xor    $0x1,%eax
c002f12a:	84 c0                	test   %al,%al
c002f12c:	74 1d                	je     c002f14b <fsutil_extract+0x1d9>
            PANIC ("%s: create failed", file_name);
c002f12e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f131:	83 ec 0c             	sub    $0xc,%esp
c002f134:	50                   	push   %eax
c002f135:	68 aa 31 03 c0       	push   $0xc00331aa
c002f13a:	68 f0 32 03 c0       	push   $0xc00332f0
c002f13f:	6a 7a                	push   $0x7a
c002f141:	68 33 30 03 c0       	push   $0xc0033033
c002f146:	e8 23 a6 ff ff       	call   c002976e <debug_panic>
          dst = filesys_open (file_name);
c002f14b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f14e:	83 ec 0c             	sub    $0xc,%esp
c002f151:	50                   	push   %eax
c002f152:	e8 0c ea ff ff       	call   c002db63 <filesys_open>
c002f157:	83 c4 10             	add    $0x10,%esp
c002f15a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          if (dst == NULL)
c002f15d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002f161:	0f 85 95 00 00 00    	jne    c002f1fc <fsutil_extract+0x28a>
            PANIC ("%s: open failed3", file_name);
c002f167:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f16a:	83 ec 0c             	sub    $0xc,%esp
c002f16d:	50                   	push   %eax
c002f16e:	68 bc 31 03 c0       	push   $0xc00331bc
c002f173:	68 f0 32 03 c0       	push   $0xc00332f0
c002f178:	6a 7d                	push   $0x7d
c002f17a:	68 33 30 03 c0       	push   $0xc0033033
c002f17f:	e8 ea a5 ff ff       	call   c002976e <debug_panic>
                                : size);
c002f184:	8b 45 d4             	mov    -0x2c(%ebp),%eax
              int chunk_size = (size > BLOCK_SECTOR_SIZE
c002f187:	3d 00 02 00 00       	cmp    $0x200,%eax
c002f18c:	7e 05                	jle    c002f193 <fsutil_extract+0x221>
c002f18e:	b8 00 02 00 00       	mov    $0x200,%eax
c002f193:	89 45 e0             	mov    %eax,-0x20(%ebp)
              block_read (src, sector++, data);
c002f196:	a1 40 a6 03 c0       	mov    0xc003a640,%eax
c002f19b:	8d 50 01             	lea    0x1(%eax),%edx
c002f19e:	89 15 40 a6 03 c0    	mov    %edx,0xc003a640
c002f1a4:	83 ec 04             	sub    $0x4,%esp
c002f1a7:	ff 75 f0             	pushl  -0x10(%ebp)
c002f1aa:	50                   	push   %eax
c002f1ab:	ff 75 ec             	pushl  -0x14(%ebp)
c002f1ae:	e8 39 5f ff ff       	call   c00250ec <block_read>
c002f1b3:	83 c4 10             	add    $0x10,%esp
              if (file_write (dst, data, chunk_size) != chunk_size)
c002f1b6:	83 ec 04             	sub    $0x4,%esp
c002f1b9:	ff 75 e0             	pushl  -0x20(%ebp)
c002f1bc:	ff 75 f0             	pushl  -0x10(%ebp)
c002f1bf:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f1c2:	e8 6e ee ff ff       	call   c002e035 <file_write>
c002f1c7:	83 c4 10             	add    $0x10,%esp
c002f1ca:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c002f1cd:	74 24                	je     c002f1f3 <fsutil_extract+0x281>
                PANIC ("%s: write failed with %d bytes unwritten",
c002f1cf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002f1d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002f1d5:	83 ec 08             	sub    $0x8,%esp
c002f1d8:	52                   	push   %edx
c002f1d9:	50                   	push   %eax
c002f1da:	68 d0 31 03 c0       	push   $0xc00331d0
c002f1df:	68 f0 32 03 c0       	push   $0xc00332f0
c002f1e4:	68 88 00 00 00       	push   $0x88
c002f1e9:	68 33 30 03 c0       	push   $0xc0033033
c002f1ee:	e8 7b a5 ff ff       	call   c002976e <debug_panic>
              size -= chunk_size;
c002f1f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f1f6:	2b 45 e0             	sub    -0x20(%ebp),%eax
c002f1f9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          while (size > 0)
c002f1fc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002f1ff:	85 c0                	test   %eax,%eax
c002f201:	7f 81                	jg     c002f184 <fsutil_extract+0x212>
          file_close (dst);
c002f203:	83 ec 0c             	sub    $0xc,%esp
c002f206:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f209:	e8 88 ed ff ff       	call   c002df96 <file_close>
c002f20e:	83 c4 10             	add    $0x10,%esp
    {
c002f211:	e9 e6 fd ff ff       	jmp    c002effc <fsutil_extract+0x8a>
}
c002f216:	c9                   	leave  
c002f217:	c3                   	ret    

c002f218 <fsutil_append>:
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void
fsutil_append (char **argv)
{
c002f218:	55                   	push   %ebp
c002f219:	89 e5                	mov    %esp,%ebp
c002f21b:	83 ec 28             	sub    $0x28,%esp
  static block_sector_t sector = 0;

  const char *file_name = argv[1];
c002f21e:	8b 45 08             	mov    0x8(%ebp),%eax
c002f221:	8b 40 04             	mov    0x4(%eax),%eax
c002f224:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *buffer;
  struct file *src;
  struct block *dst;
  off_t size;

  printf ("Appending '%s' to ustar archive on scratch device...\n", file_name);
c002f227:	83 ec 08             	sub    $0x8,%esp
c002f22a:	ff 75 f0             	pushl  -0x10(%ebp)
c002f22d:	68 fc 31 03 c0       	push   $0xc00331fc
c002f232:	e8 78 81 ff ff       	call   c00273af <printf>
c002f237:	83 c4 10             	add    $0x10,%esp

  /* Allocate buffer. */
  buffer = malloc (BLOCK_SECTOR_SIZE);
c002f23a:	83 ec 0c             	sub    $0xc,%esp
c002f23d:	68 00 02 00 00       	push   $0x200
c002f242:	e8 4b 44 ff ff       	call   c0023692 <malloc>
c002f247:	83 c4 10             	add    $0x10,%esp
c002f24a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (buffer == NULL)
c002f24d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002f251:	75 19                	jne    c002f26c <fsutil_append+0x54>
    PANIC ("couldn't allocate buffer");
c002f253:	68 32 32 03 c0       	push   $0xc0033232
c002f258:	68 00 33 03 c0       	push   $0xc0033300
c002f25d:	68 b6 00 00 00       	push   $0xb6
c002f262:	68 33 30 03 c0       	push   $0xc0033033
c002f267:	e8 02 a5 ff ff       	call   c002976e <debug_panic>

  /* Open source file. */
  src = filesys_open (file_name);
c002f26c:	83 ec 0c             	sub    $0xc,%esp
c002f26f:	ff 75 f0             	pushl  -0x10(%ebp)
c002f272:	e8 ec e8 ff ff       	call   c002db63 <filesys_open>
c002f277:	83 c4 10             	add    $0x10,%esp
c002f27a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if (src == NULL)
c002f27d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002f281:	75 1f                	jne    c002f2a2 <fsutil_append+0x8a>
    PANIC ("%s: open failed4", file_name);
c002f283:	83 ec 0c             	sub    $0xc,%esp
c002f286:	ff 75 f0             	pushl  -0x10(%ebp)
c002f289:	68 4b 32 03 c0       	push   $0xc003324b
c002f28e:	68 00 33 03 c0       	push   $0xc0033300
c002f293:	68 bb 00 00 00       	push   $0xbb
c002f298:	68 33 30 03 c0       	push   $0xc0033033
c002f29d:	e8 cc a4 ff ff       	call   c002976e <debug_panic>
  size = file_length (src);
c002f2a2:	83 ec 0c             	sub    $0xc,%esp
c002f2a5:	ff 75 e8             	pushl  -0x18(%ebp)
c002f2a8:	e8 85 ee ff ff       	call   c002e132 <file_length>
c002f2ad:	83 c4 10             	add    $0x10,%esp
c002f2b0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Open target block device. */
  dst = block_get_role (BLOCK_SCRATCH);
c002f2b3:	83 ec 0c             	sub    $0xc,%esp
c002f2b6:	6a 02                	push   $0x2
c002f2b8:	e8 bc 5c ff ff       	call   c0024f79 <block_get_role>
c002f2bd:	83 c4 10             	add    $0x10,%esp
c002f2c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (dst == NULL)
c002f2c3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002f2c7:	75 19                	jne    c002f2e2 <fsutil_append+0xca>
    PANIC ("couldn't open scratch device");
c002f2c9:	68 cd 30 03 c0       	push   $0xc00330cd
c002f2ce:	68 00 33 03 c0       	push   $0xc0033300
c002f2d3:	68 c1 00 00 00       	push   $0xc1
c002f2d8:	68 33 30 03 c0       	push   $0xc0033033
c002f2dd:	e8 8c a4 ff ff       	call   c002976e <debug_panic>
  
  /* Write ustar header to first sector. */
  if (!ustar_make_header (file_name, USTAR_REGULAR, size, buffer))
c002f2e2:	ff 75 ec             	pushl  -0x14(%ebp)
c002f2e5:	ff 75 f4             	pushl  -0xc(%ebp)
c002f2e8:	6a 30                	push   $0x30
c002f2ea:	ff 75 f0             	pushl  -0x10(%ebp)
c002f2ed:	e8 5c a0 ff ff       	call   c002934e <ustar_make_header>
c002f2f2:	83 c4 10             	add    $0x10,%esp
c002f2f5:	83 f0 01             	xor    $0x1,%eax
c002f2f8:	84 c0                	test   %al,%al
c002f2fa:	74 1f                	je     c002f31b <fsutil_append+0x103>
    PANIC ("%s: name too long for ustar format", file_name);
c002f2fc:	83 ec 0c             	sub    $0xc,%esp
c002f2ff:	ff 75 f0             	pushl  -0x10(%ebp)
c002f302:	68 5c 32 03 c0       	push   $0xc003325c
c002f307:	68 00 33 03 c0       	push   $0xc0033300
c002f30c:	68 c5 00 00 00       	push   $0xc5
c002f311:	68 33 30 03 c0       	push   $0xc0033033
c002f316:	e8 53 a4 ff ff       	call   c002976e <debug_panic>
  block_write (dst, sector++, buffer);
c002f31b:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002f320:	8d 50 01             	lea    0x1(%eax),%edx
c002f323:	89 15 44 a6 03 c0    	mov    %edx,0xc003a644
c002f329:	83 ec 04             	sub    $0x4,%esp
c002f32c:	ff 75 ec             	pushl  -0x14(%ebp)
c002f32f:	50                   	push   %eax
c002f330:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f333:	e8 03 5e ff ff       	call   c002513b <block_write>
c002f338:	83 c4 10             	add    $0x10,%esp

  /* Do copy. */
  while (size > 0) 
c002f33b:	e9 cc 00 00 00       	jmp    c002f40c <fsutil_append+0x1f4>
    {
      int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c002f340:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002f343:	3d 00 02 00 00       	cmp    $0x200,%eax
c002f348:	7e 05                	jle    c002f34f <fsutil_append+0x137>
c002f34a:	b8 00 02 00 00       	mov    $0x200,%eax
c002f34f:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (sector >= block_size (dst))
c002f352:	83 ec 0c             	sub    $0xc,%esp
c002f355:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f358:	e8 5a 5e ff ff       	call   c00251b7 <block_size>
c002f35d:	83 c4 10             	add    $0x10,%esp
c002f360:	89 c2                	mov    %eax,%edx
c002f362:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002f367:	39 c2                	cmp    %eax,%edx
c002f369:	77 1f                	ja     c002f38a <fsutil_append+0x172>
        PANIC ("%s: out of space on scratch device", file_name);
c002f36b:	83 ec 0c             	sub    $0xc,%esp
c002f36e:	ff 75 f0             	pushl  -0x10(%ebp)
c002f371:	68 80 32 03 c0       	push   $0xc0033280
c002f376:	68 00 33 03 c0       	push   $0xc0033300
c002f37b:	68 cd 00 00 00       	push   $0xcd
c002f380:	68 33 30 03 c0       	push   $0xc0033033
c002f385:	e8 e4 a3 ff ff       	call   c002976e <debug_panic>
      if (file_read (src, buffer, chunk_size) != chunk_size)
c002f38a:	83 ec 04             	sub    $0x4,%esp
c002f38d:	ff 75 e0             	pushl  -0x20(%ebp)
c002f390:	ff 75 ec             	pushl  -0x14(%ebp)
c002f393:	ff 75 e8             	pushl  -0x18(%ebp)
c002f396:	e8 41 ec ff ff       	call   c002dfdc <file_read>
c002f39b:	83 c4 10             	add    $0x10,%esp
c002f39e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c002f3a1:	74 22                	je     c002f3c5 <fsutil_append+0x1ad>
        PANIC ("%s: read failed with %"PROTd" bytes unread", file_name, size);
c002f3a3:	83 ec 08             	sub    $0x8,%esp
c002f3a6:	ff 75 f4             	pushl  -0xc(%ebp)
c002f3a9:	ff 75 f0             	pushl  -0x10(%ebp)
c002f3ac:	68 a4 32 03 c0       	push   $0xc00332a4
c002f3b1:	68 00 33 03 c0       	push   $0xc0033300
c002f3b6:	68 cf 00 00 00       	push   $0xcf
c002f3bb:	68 33 30 03 c0       	push   $0xc0033033
c002f3c0:	e8 a9 a3 ff ff       	call   c002976e <debug_panic>
      memset (buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c002f3c5:	b8 00 02 00 00       	mov    $0x200,%eax
c002f3ca:	2b 45 e0             	sub    -0x20(%ebp),%eax
c002f3cd:	89 c2                	mov    %eax,%edx
c002f3cf:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002f3d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f3d5:	01 c8                	add    %ecx,%eax
c002f3d7:	83 ec 04             	sub    $0x4,%esp
c002f3da:	52                   	push   %edx
c002f3db:	6a 00                	push   $0x0
c002f3dd:	50                   	push   %eax
c002f3de:	e8 a5 97 ff ff       	call   c0028b88 <memset>
c002f3e3:	83 c4 10             	add    $0x10,%esp
      block_write (dst, sector++, buffer);
c002f3e6:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002f3eb:	8d 50 01             	lea    0x1(%eax),%edx
c002f3ee:	89 15 44 a6 03 c0    	mov    %edx,0xc003a644
c002f3f4:	83 ec 04             	sub    $0x4,%esp
c002f3f7:	ff 75 ec             	pushl  -0x14(%ebp)
c002f3fa:	50                   	push   %eax
c002f3fb:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f3fe:	e8 38 5d ff ff       	call   c002513b <block_write>
c002f403:	83 c4 10             	add    $0x10,%esp
      size -= chunk_size;
c002f406:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002f409:	29 45 f4             	sub    %eax,-0xc(%ebp)
  while (size > 0) 
c002f40c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002f410:	0f 8f 2a ff ff ff    	jg     c002f340 <fsutil_append+0x128>
    }

  /* Write ustar end-of-archive marker, which is two consecutive
     sectors full of zeros.  Don't advance our position past
     them, though, in case we have more files to append. */
  memset (buffer, 0, BLOCK_SECTOR_SIZE);
c002f416:	83 ec 04             	sub    $0x4,%esp
c002f419:	68 00 02 00 00       	push   $0x200
c002f41e:	6a 00                	push   $0x0
c002f420:	ff 75 ec             	pushl  -0x14(%ebp)
c002f423:	e8 60 97 ff ff       	call   c0028b88 <memset>
c002f428:	83 c4 10             	add    $0x10,%esp
  block_write (dst, sector, buffer);
c002f42b:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002f430:	83 ec 04             	sub    $0x4,%esp
c002f433:	ff 75 ec             	pushl  -0x14(%ebp)
c002f436:	50                   	push   %eax
c002f437:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f43a:	e8 fc 5c ff ff       	call   c002513b <block_write>
c002f43f:	83 c4 10             	add    $0x10,%esp
  block_write (dst, sector, buffer + 1);
c002f442:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002f445:	8d 50 01             	lea    0x1(%eax),%edx
c002f448:	a1 44 a6 03 c0       	mov    0xc003a644,%eax
c002f44d:	83 ec 04             	sub    $0x4,%esp
c002f450:	52                   	push   %edx
c002f451:	50                   	push   %eax
c002f452:	ff 75 e4             	pushl  -0x1c(%ebp)
c002f455:	e8 e1 5c ff ff       	call   c002513b <block_write>
c002f45a:	83 c4 10             	add    $0x10,%esp

  /* Finish up. */
  file_close (src);
c002f45d:	83 ec 0c             	sub    $0xc,%esp
c002f460:	ff 75 e8             	pushl  -0x18(%ebp)
c002f463:	e8 2e eb ff ff       	call   c002df96 <file_close>
c002f468:	83 c4 10             	add    $0x10,%esp
  free (buffer);
c002f46b:	83 ec 0c             	sub    $0xc,%esp
c002f46e:	ff 75 ec             	pushl  -0x14(%ebp)
c002f471:	e8 16 45 ff ff       	call   c002398c <free>
c002f476:	83 c4 10             	add    $0x10,%esp
}
c002f479:	90                   	nop
c002f47a:	c9                   	leave  
c002f47b:	c3                   	ret    
